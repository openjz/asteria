<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>面试八股-通用 - 星</title><meta name="Description" content=""><meta property="og:title" content="面试八股-通用" />
<meta property="og:description" content="系统 基础 什么是协程 协程是一种运行在用户态的并发机制，类似于一种轻量级的用户态线程，协程一般运行在内核态线程之上（例如，可以按照n:m模型调度" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.shiwj.top/16.z1.interview-bagu-general/" /><meta property="og:image" content="http://blog.shiwj.top/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-07T18:41:33+08:00" />
<meta property="article:modified_time" content="2025-07-05T15:26:54+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://blog.shiwj.top/logo.png"/>

<meta name="twitter:title" content="面试八股-通用"/>
<meta name="twitter:description" content="系统 基础 什么是协程 协程是一种运行在用户态的并发机制，类似于一种轻量级的用户态线程，协程一般运行在内核态线程之上（例如，可以按照n:m模型调度"/>
<meta name="application-name" content="星">
<meta name="apple-mobile-web-app-title" content="星"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://blog.shiwj.top/16.z1.interview-bagu-general/" /><link rel="prev" href="http://blog.shiwj.top/16.interview-bagu-golang/" /><link rel="next" href="http://blog.shiwj.top/17.html-mdn-tutorial/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "面试八股-通用",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/blog.shiwj.top\/16.z1.interview-bagu-general\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "http:\/\/blog.shiwj.top\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048 
                        }],"genre": "posts","keywords": "面试","wordcount":  25521 ,
        "url": "http:\/\/blog.shiwj.top\/16.z1.interview-bagu-general\/","datePublished": "2022-10-07T18:41:33+08:00","dateModified": "2025-07-05T15:26:54+08:00","publisher": {
            "@type": "Organization",
            "name": "shiwj","logo": {
                    "@type": "ImageObject",
                    "url": "http:\/\/blog.shiwj.top\/images\/avatar.png",
                    "width":  690 ,
                    "height":  690 
                }},"author": {
                "@type": "Person",
                "name": "shiwj"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 全部 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i>  </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">全部</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">面试八股-通用</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/openjz" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>shiwj</a>
</span>&nbsp;<span class="post-category">included in <a href="/categories/%E7%BC%96%E7%A8%8B/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>编程</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-10-07">2022-10-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;25521 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;51 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#系统">系统</a>
      <ul>
        <li><a href="#基础">基础</a></li>
        <li><a href="#内存管理">内存管理</a></li>
        <li><a href="#linux使用">linux使用</a></li>
        <li><a href="#linux的五种io模型">linux的五种I/O模型</a></li>
        <li><a href="#linux-io多路复用">linux I/O多路复用</a></li>
        <li><a href="#linux进程">linux进程</a></li>
        <li><a href="#linux进程间通信ipc">linux进程间通信（IPC）</a></li>
        <li><a href="#linux线程同步">linux线程同步</a></li>
        <li><a href="#linux内核">linux内核</a></li>
      </ul>
    </li>
    <li><a href="#网络">网络</a>
      <ul>
        <li><a href="#基础-1">基础</a></li>
        <li><a href="#tcp报文结构">TCP报文结构</a></li>
        <li><a href="#tcp三次握手四次挥手">TCP三次握手四次挥手</a></li>
        <li><a href="#tcp如何保证可靠传输">TCP如何保证可靠传输</a></li>
        <li><a href="#tcp流量控制">TCP流量控制</a></li>
        <li><a href="#tcp拥塞控制">TCP拥塞控制</a></li>
        <li><a href="#unix套接字">unix套接字</a></li>
      </ul>
    </li>
    <li><a href="#mysql">mysql</a>
      <ul>
        <li><a href="#索引">索引</a></li>
        <li><a href="#2kw-是数据量上限这个说法从何而来">2kw 是数据量上限这个说法从何而来</a></li>
        <li><a href="#事务">事务</a></li>
        <li><a href="#事务的并发问题">事务的并发问题</a></li>
        <li><a href="#innodb-的锁">InnoDB 的锁</a></li>
        <li><a href="#悲观锁和乐观锁">悲观锁和乐观锁</a></li>
        <li><a href="#如何加锁">如何加锁</a></li>
        <li><a href="#innodb-mvcc">InnoDB MVCC</a></li>
        <li><a href="#mysql的隔离级别">MySQL的隔离级别</a></li>
        <li><a href="#优化">优化</a></li>
        <li><a href="#log">log</a></li>
        <li><a href="#其他">其他</a></li>
      </ul>
    </li>
    <li><a href="#分布式">分布式</a>
      <ul>
        <li><a href="#分布式概念">分布式概念</a></li>
        <li><a href="#分布式锁">分布式锁</a></li>
        <li><a href="#分布式id">分布式id</a></li>
      </ul>
    </li>
    <li><a href="#redis">redis</a>
      <ul>
        <li><a href="#redis的功能">redis的功能</a></li>
        <li><a href="#redis缓存击穿穿透雪崩">redis缓存击穿、穿透、雪崩</a></li>
        <li><a href="#利用redis实现分布式锁">利用redis实现分布式锁</a></li>
        <li><a href="#redis的缓存淘汰策略">redis的缓存淘汰策略</a></li>
        <li><a href="#如何保证缓存和数据库的一致性">如何保证缓存和数据库的一致性</a></li>
      </ul>
    </li>
    <li><a href="#mq">MQ</a>
      <ul>
        <li><a href="#mq的用途">MQ的用途</a></li>
        <li><a href="#kafka的特点">kafka的特点</a></li>
        <li><a href="#kafka原理">kafka原理</a></li>
        <li><a href="#kafka如何保证顺序消费">kafka如何保证顺序消费</a></li>
        <li><a href="#kafka如何防止消息丢失">kafka如何防止消息丢失</a></li>
        <li><a href="#kafka如何防止消息重复">kafka如何防止消息重复</a></li>
      </ul>
    </li>
    <li><a href="#docker和k8s">docker和k8s</a></li>
    <li><a href="#系统设计">系统设计</a>
      <ul>
        <li><a href="#高并发高性能高可用">高并发、高性能、高可用</a></li>
        <li><a href="#restful-api">restful api</a></li>
        <li><a href="#设计模式">设计模式</a></li>
        <li><a href="#如何实现接口的幂等性">如何实现接口的幂等性</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="系统">系统</h2>
<h3 id="基础">基础</h3>
<p><strong>什么是协程</strong></p>
<p>协程是一种运行在用户态的并发机制，类似于一种轻量级的用户态线程，协程一般运行在内核态线程之上（例如，可以按照n:m模型调度，即n个用户态协程运行在m个内核态线程上）。</p>
<p>协程分为有栈和无栈协程，有栈协程是指协程有自己栈空间，类似线程一样，无栈协程是指协程没有自己的栈空间，所有协程共享一个栈空间。golang的goroutine是典型的有栈协程，C++的coroutine是无栈协程。</p>
<p><strong>进程和线程的区别</strong></p>
<ul>
<li>进程是资源分配的基本单位，线程是调度的基本单位</li>
<li>进程间相互隔离，不共享资源，一个挂了不影响其他的，线程共享进程资源，一个线程挂了整个进程全挂</li>
<li>线程运行在进程内部，一个进程包含多个线程</li>
<li>进程存在父子关系，线程不存在</li>
<li>进程上下文切换开销比线程大</li>
<li>进程间通信方式和线程不同</li>
</ul>
<p><strong>死锁的四个条件</strong></p>
<ol>
<li>互斥，资源具有排他性，一个资源只能被一个进程/线程占用</li>
<li>不可剥夺，资源只能由持有方主动释放，不能强行剥夺</li>
<li>持有且等待，一个进程/线程持有资源的同时又请求其他资源</li>
<li>循环等待，资源等待链够形成环形</li>
</ol>
<p><strong>进程/线程调度</strong></p>
<p>抢占式调度，操作系统可以强制暂停正在运行的进程/线程，将CPU让出，现代通用操作系统基本都是抢占式调度（例如Windows、Linux等），通常基于时间片实现，抢占式调度由软中断和硬中断配合实现。</p>
<p>非抢占式调度，CPU资源只能由进程主动让出</p>
<p><strong>调度算法</strong></p>
<ol>
<li>先来先服务，对长作业有利，但是对短作业不利</li>
<li>最短作业优先，会发生饥饿现象</li>
<li>高响应比优先，综合考虑执行时间和等待时间，响应比=（等待时间+执行时间）/执行时间，照顾到了长进程</li>
<li>最高优先级调度，每次选择优先级最高的进程调度执行，优先级可以是静态的和动态的</li>
<li>多级反馈队列调度
<ol>
<li>系统设置多个就绪队列，每个队列有不同的优先级和时间片长度。高优先级队列时间片短，低优先级队列时间片长。</li>
<li>新到达的进程通常先进入最高优先级队列，获得较高的响应速度。</li>
<li>如果进程在高优先级队列的时间片内没有完成，会被降到下一级队列。反之，如果低优先级队列的进程长时间未被调度，也可以提升其优先级，防止饥饿。</li>
<li>总是优先调度高优先级队列中的进程，只有高优先级队列空闲时才调度低优先级队列。</li>
</ol>
</li>
<li>时间片轮转</li>
</ol>
<p><strong>页面置换策略</strong></p>
<p>页面置换策略，也就是缓存淘汰策略</p>
<ol>
<li>先进先出</li>
<li>最近最久未使用（LRU），通常用一个双向链表维护缓存页面信息，每当由页面被访问时，将其移动到链表头部，这样，链表尾部的页面就是最近最久未使用的页面，每次淘汰时选择链表尾部的页面。</li>
<li>最不常用（LFU），为每个页面维护一个访问计数器，每次淘汰访问次数最小的页面。</li>
<li>时钟页面置换，对每个内存页加个访问位，被访问到置位1，新页面为0，页面置换时扫描，将访问位为0时换出，访问位为1的重置为0。</li>
<li>最佳页面置换，最理想的页面置换，是一个概念，不是某个具体的算法。</li>
</ol>
<p><strong>系统调用的执行过程</strong></p>
<ol>
<li>应用程序在用户态通过库函数（如read、write、open等）发起系统调用请求。</li>
<li>系统调用会触发一次软中断（如x86上的int 0x80或syscall指令），CPU从用户态切换到内核态，进入操作系统内核。</li>
<li>系统调用id和参数通过寄存器或栈传递给内核，内核根据系统调用id找到对应的内核服务例程。</li>
<li>内核根据请求执行相应的操作（如文件读写、进程管理、内存分配等），访问硬件或内核资源。</li>
<li>内核将执行结果返回给用户程序，CPU从内核态切换回用户态，应用程序继续运行。</li>
</ol>
<p>软中断是中断的软件实现，和硬中断相对，软中断可以让cpu从用户态切换到内核态，主要用于实现系统调用和内核任务调度等。</p>
<h3 id="内存管理">内存管理</h3>
<p><strong>虚拟内存和物理内存</strong></p>
<p>虚拟内存是操作系统为每个进程提供的、看起来连续且独立的内存空间，又称逻辑内存空间。每个进程都认为自己拥有完整的、独立的内存，不会与其他进程冲突。虚拟内存的大小通常大于实际物理内存，依赖于磁盘空间（如交换分区或页面文件）进行扩展。</p>
<p>物理内存指的是计算机实际安装的内存条（RAM），是所有进程和操作系统共享的真实硬件资源。</p>
<p>虚拟内存和物理内存的映射由操作系统和硬件（MMU，内存管理单元）共同完成。操作系统将虚拟地址空间划分为页（Page），通过页表（Page Table）记录虚拟页与物理页的对应关系。当进程访问虚拟地址时，MMU 会根据页表将虚拟地址转换为物理地址，实现虚拟内存到物理内存的映射。如果访问的虚拟页不在物理内存中，会触发缺页中断，操作系统将所需数据从磁盘调入物理内存。</p>
<p>总结：</p>
<p>虚拟内存：进程看到的逻辑内存空间
物理内存：实际的硬件内存
映射方式：通过页表和MMU将虚拟地址映射到物理地址</p>
<p><strong>内存碎片</strong></p>
<p>内存碎片是指在内存分配和释放过程中，内存空间被分割成许多零散的小块，导致无法有效利用，无法分配大块连续内存</p>
<p><strong>如何处理内存碎片</strong></p>
<p>通过内存分配算法优化内存分配，尽量减少内存碎片产生，例如最佳适应算法（Best Fit），查找最小的满足请求的空闲块，可能导致内存碎片更小，但速度慢。</p>
<p>内存紧缩（Compaction），将内存中分散的小块空闲空间整理成大块连续空间（主要用于外部碎片，常见于早期操作系统）。</p>
<p>分页和分段机制，通过虚拟内存的分页（Page）和分段（Segment）技术，将物理内存分为固定大小的页或段，有效避免或减少外部碎片。</p>
<h3 id="linux使用">linux使用</h3>
<ul>
<li><code>ps</code>，查看进程状态
<ul>
<li>ps命令参数分三种风格，带“-”的是unix风格，不带的是bsd风格，“&ndash;”是GNU风格，最坑的是不同风格的输出不一样
<blockquote>
<p>比如，ps -aux 和 ps aux其实完全不一样，-aux是想打印用户x的所有进程，如果用户x不存在，ps会帮你把命令改写成ps aux</p>
</blockquote>
</li>
<li>查看所有进程
<ul>
<li>ps -e，ps -ef，ps -eF，ps -ely</li>
<li>ps aux，ps ax</li>
</ul>
</li>
<li>查看进程树，ps -ejH，ps axjf</li>
<li><code>ps aux</code>，<code>x</code>列出没有控制终端的进程，<code>u</code>列出更多信息（用户、CPU、内存等）、<code>a</code>列出所有用户的进程</li>
<li>ps aux字段含义
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">USER          进程所有者的用户名
</span></span><span class="line"><span class="cl">PID           进程ID（Process ID）
</span></span><span class="line"><span class="cl">START         进程激活时间
</span></span><span class="line"><span class="cl">%CPU          进程的cpu占用率
</span></span><span class="line"><span class="cl">%MEM          进程使用内存的百分比
</span></span><span class="line"><span class="cl">VSZ           进程使用的虚拟内存大小，以K为单位
</span></span><span class="line"><span class="cl">RSS           驻留空间的大小。显示当前常驻内存的程序的K字节数。
</span></span><span class="line"><span class="cl">TTY           与进程关联的终端（tty）
</span></span><span class="line"><span class="cl">STAT          进程状态，包括下面的状态： 
</span></span><span class="line"><span class="cl">      D    不可中断的sleep，通常在IO
</span></span><span class="line"><span class="cl">      R    正在运行，或在可运行队列中的进程
</span></span><span class="line"><span class="cl">      S    可中断的sleep状态，通常是在等待事件将其唤醒
</span></span><span class="line"><span class="cl">      T    暂停状态（ctrl+z），即进程挂起状态
</span></span><span class="line"><span class="cl">      t    由于调试器跟踪而暂停
</span></span><span class="line"><span class="cl">      Z    僵尸进程，进程已执行完毕，但父进程没有回收其退出状态，这时候进程会成为僵尸进程  
</span></span><span class="line"><span class="cl">           和孤儿进程不同，孤儿进程是指父进程已结束，由init进程接管的进程
</span></span><span class="line"><span class="cl">      W    进入内存交换（从内核2.6开始无效）
</span></span><span class="line"><span class="cl">      X    正在被销毁（非常短暂，几乎不可能被看到）
</span></span><span class="line"><span class="cl">  状态描述
</span></span><span class="line"><span class="cl">      &lt;    高优先级
</span></span><span class="line"><span class="cl">      N    低优先级
</span></span><span class="line"><span class="cl">      L    有些页被锁进内存
</span></span><span class="line"><span class="cl">      s    session leader（会话首进程）
</span></span><span class="line"><span class="cl">      +    在前台进程组中
</span></span><span class="line"><span class="cl">      l    多线程，克隆线程
</span></span><span class="line"><span class="cl">TIME          进程使用的总CPU时间
</span></span><span class="line"><span class="cl">COMMAND       被执行的命令行
</span></span><span class="line"><span class="cl">NI            进程的优先级值，较小的数字意味着占用较少的CPU时间
</span></span><span class="line"><span class="cl">PRI           进程优先级。
</span></span><span class="line"><span class="cl">PPID          父进程ID
</span></span><span class="line"><span class="cl">WCHAN         进程等待的内核事件名  
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>linux中的虚拟内存不是指swap，是指进程的逻辑地址空间，只有实际访问到的内存会被映射到物理内存，这部分物理内存叫常驻内存。</p>
</blockquote>
</li>
</ul>
</li>
<li><code>grep</code>，文本搜索，<code>-c</code>：仅显示找到的行数，<code>-n</code>：显示行号，<code>-i</code>：忽略大小写，<code>-v</code>：反向搜索（搜索不包含指定字符串的行）</li>
<li><code>crontab</code>，定时任务，格式，“分 时 日 月 星期 命令”</li>
<li><code>free</code>，查看内存，默认按KB查看，-b，按字节展示，-k，按KB展示，-m，按MB展示，-g，按GB展示，-h，按适当的单位展示，-s N，隔N秒输出一次
<ul>
<li>第一行是内存，第二行是swap</li>
<li>total是总内存，used是已使用的内存，free是未使用的内存，shared是共享使用的内存，buff/cache是buffer和cache使用的内存，available是应用程序可用的内存。</li>
<li>和free相比，available算入了page cache
<blockquote>
<p>buffer是指buffer cache，buffer cache是存储在内存中的文件块（一个文件块大小不能超过内存页大小）</p>
<p>cache是指page cache，一般翻译成页高速缓存，是用内存做磁盘缓存，包含对普通文件、块设备文件、内存映射文件的缓存。对块设备文件的缓存就是buffer cache。</p>
</blockquote>
</li>
<li>free命令来自<code>/proc/meminfo</code>文件，直接查看这个文件也行</li>
</ul>
</li>
<li><code>top</code>，实时查看当前系统中的进程状态
<ul>
<li>第一部分，系统总体状况
<ul>
<li>第一行，当前时间，运行时间（up 2 day），当前用户数量，系统在之前1分钟、5分钟、15分钟的平均负载</li>
<li>第二行（进程信息），系统中的进程总数，正在运行的进程数，睡眠的进程数，正在停止的进程数，僵尸进程数。</li>
<li>第三行（cpu占用），用户模式，系统模式&hellip;</li>
<li>第四、五行（内存信息，和free命令差不多）</li>
</ul>
</li>
<li>第二部分，各个进程的详细信息，以下是各字段含义
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">PID — 进程id
</span></span><span class="line"><span class="cl">USER — 进程所有者
</span></span><span class="line"><span class="cl">PR — 进程优先级，值越小优先级越高
</span></span><span class="line"><span class="cl">NI — nice值。静态优先级，值越小优先级越高
</span></span><span class="line"><span class="cl">VIRT — 进程使用的虚拟内存总量，单位kb。
</span></span><span class="line"><span class="cl">RES — 常驻内存大小，单位kb。
</span></span><span class="line"><span class="cl">SHR — 共享内存大小，单位kb
</span></span><span class="line"><span class="cl">S —进程状态。
</span></span><span class="line"><span class="cl">%CPU — cpu占用
</span></span><span class="line"><span class="cl">%MEM — 内存占用
</span></span><span class="line"><span class="cl">TIME+ — 进程使用的CPU时间总计，最小单位是秒
</span></span><span class="line"><span class="cl">COMMAND — 命令
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><code>tar</code>，压缩和打包命令</li>
<li><code>netstat</code>，查看网络状态
<ul>
<li>按域查看，-4，-6，-A &lt;域&gt;，&ndash;域，具体的域有inet（ipv4）、inet6（ipv6）等等</li>
<li>按socket查看，-t，&ndash;tcp，-u，&ndash;udp，-x，&ndash;unix，-w，&ndash;raw等等</li>
<li>-a，查看所有socket（默认只显示建立连接的），-n，显示ip而不是域名，-p，显示pid（只有当前用户的进程号），-o，显示timers，-l，只显示监听，-e，显示用户和inode</li>
<li>-r，查看路由表，-i，查看网卡，-s，查看网络连接统计数据</li>
<li>-c，持续输出</li>
</ul>
</li>
<li><code>ping</code>，用于检测和目标主机的网络连接
<ul>
<li>利用icmp协议的echo信息检查目的主机的可达性、延迟、报文丢失情况
<blockquote>
<p>icmp协议（网络控制报文协议）是一种差错报告和信息查询协议，当数据传输出现错误时，利用icmp协议通知源主机数据传输出错，也可以利用icmp查询一些信息。</p>
<p>icmp报文放在ip报文的数据部分中，从报文结构上来看，icmp是ip的上层协议，但是icmp承担了ip层的任务，因此我们将icmp视为ip层协议</p>
</blockquote>
</li>
</ul>
</li>
<li><code>traceroute</code>，用于查看到目的主机的路由路径
<ul>
<li>traceroute有三种实现，icmp、udp、tcp</li>
<li>udp，<code>traceroute xxx</code>或<code>traceroute -T xxx</code>，traceroute默认使用udp。向目的主机发送很多不同TTL的UDP报文，并访问一个大于30000的端口号，如果在传输到某个路由器时TTL的值减为0，则路由器回送一个超时的ICMP报文，如果报文到达了目的主机，则目的主机会回送一个端口不可达的ICMP报文。</li>
<li>icmp，<code>traceroute -I xxx</code>。利用icmp echo实现，向目的主机发送很多不同TTL的ICMP echo请求报文，如果在传输到某个路由器时TTL的值减为0，则路由器回送一个超时的ICMP报文，如果报文到达了目的主机，则目的主机会回送一个ICMP echo响应报文。
<blockquote>
<p>TTL通常是指“报文最大生存时间”，但是在icmp里，TTL就是指路由器的跳数</p>
</blockquote>
</li>
<li>tcp，<code>traceroute -T xxx</code></li>
<li>问题
<ul>
<li>使用时看不到目的主机，使用udp协议时可能会出现这种情况，原因是目的主机没开放udp服务，回送不了“端口不可达”icmp报文</li>
<li>使用时看不到中间路由器，可能是因为中间路由器不支持回送超时icmp报文</li>
</ul>
</li>
<li>windows下的tracert使用icmp实现</li>
</ul>
</li>
<li><code>kill</code>，按进程id发信号
<ul>
<li>kill -l 可以查看所有信号的编号</li>
<li>kill默认发送的是TERM信号（编号15），会要求进程退出，进程在退出前可以做一些善后工作</li>
<li>kill -9 发送的是KILL信号，让进程强制退出，不给进程善后的机会</li>
</ul>
</li>
<li><code>killall</code>，按进程名字发信号</li>
<li><code>pkill</code>，筛选进程并发信号</li>
<li><code>pgrep</code>，筛选进程</li>
<li>linux的硬连接和软连接
<ul>
<li>一个linux文件元信息分为两部分，一部分是文件名，另一部分是inode，inode存放了文件的属性、数据块指针等</li>
<li>软连接，软连接类似于windows中的快捷方式，软连接不会对inode有真正的引用</li>
<li>硬连接是对inode的真正引用，只有把硬连接全部删除，文件才会被删掉</li>
</ul>
</li>
</ul>
<h3 id="linux的五种io模型">linux的五种I/O模型</h3>
<ul>
<li>阻塞式I/O
<ul>
<li>普通的IO操作都是阻塞式I/O</li>
<li>阻塞式I/O可能会被永久阻塞，比如网络连接一直没有数据过来</li>
</ul>
</li>
<li>非阻塞式I/O
<ul>
<li>如果I/O操作因为不满足条件而无法完成，调用会立即出错返回</li>
<li><strong>误区1</strong>，阻塞式I/O和异步I/O混为一谈
<ul>
<li>非阻塞是强调不会进入阻塞状态，调用一旦返回，这次调用就已经完成了。</li>
<li>异步I/O强调的是I/O操作和调用方并行，异步调用发起后立即返回的不是最终结果，而是告诉调用者一个“已收到”信息，最终执行完成后通过某种手段通知调用方执行结果。</li>
</ul>
</li>
<li><strong>误区2</strong>，非阻塞式I/O会造成进程或线程一直占用CPU
<ul>
<li>占用CPU的不是非阻塞式I/O，而是程序员轮询非阻塞式I/O造成的（比如写个死循环不停地调用非阻塞式I/O，直到成功为止）</li>
</ul>
</li>
</ul>
</li>
<li>信号驱动I/O
<ul>
<li>内核用SIGIO这个信号通知进程有事件到达，是一种异步通知机制</li>
<li>一般是UDP通信会使用这个I/O模型，原因是系统统一使用SIGIO这一个信号表示I/O事件，UDP只有两个事件会发出这个信号（数据到达和发生错误），比较容易判断和处理，而TCP有一堆事件会发出这个信号，而且信号发出过于频繁，没法采用这个I/O模型</li>
</ul>
</li>
<li>I/O多路复用
<ul>
<li>同时从多个文件描述符里读数据，可以在同一个线程内一个循环搞定，降低程序复杂度</li>
<li>通过 I/O 复用函数向内核注册一组文件描述符，当某个文件描述符准备好数据时，I/O 复用函数把其中就绪的文件描述符返回给用户程序，用户程序只需要轮询I/O复用函数即可，I/O复用函数是阻塞式的，因此轮询并不会占用cpu资源</li>
</ul>
</li>
<li>异步I/O
<ul>
<li>以上四种I/O模型，最多只能实现异步形式的通知，而最重要的数据传输都是同步的，即数据传输都要由用户线程或进程亲自完成。</li>
<li>异步I/O数据传输由内核接管，用户进程只需要发起I/O请求和等待完成通知即可</li>
</ul>
</li>
</ul>
<h3 id="linux-io多路复用">linux I/O多路复用</h3>
<ul>
<li>linux的IO多路复用，多路是指多个文件描述符，复用是指单线程或单进程可以同时监听多个文件描述符</li>
<li>I/O多路复用是linux的五种I/O模型中的一种，是为了解决在同一个用户进程内同时读写多个文件描述符的问题</li>
<li>三种，select/pselect、poll、epoll</li>
<li>通过 I/O 复用函数向内核注册一组文件描述符，当某个文件描述符准备好数据时，I/O 复用函数把其中就绪的文件描述符返回给用户程序，用户程序只需要轮询I/O复用函数即可。I/O复用函数是阻塞式的，因此循环调用并不会占用cpu资源。</li>
<li>I/O复用函数实际上是把文件描述符的状态检查交给内核去接管，用户进程只需要读写数据。</li>
<li>I/O多路复用通过超时时间来控制文件描述符的阻塞时间</li>
<li>select
<ul>
<li>传给内核的文件描述符集用一个位图来表示，同时要传入一个最大文件描述符+1这个一个值，告诉内核传入的描述符数，内核常量FD_SETSIZE表示这个值的最大值（1024）。</li>
<li>select返回准备好的描述符数，并且会根据准备好的描述符集覆写用户传入的位图。等于说是select返回以后，用户还得自己去遍历传入的位图，下一次调用select的时候再重新设置位图。</li>
<li>按事件类型将文件描述符集分为可读、可写和异常三个文件描述符集，可以根据需要传入一个或多个文件描述符集。</li>
<li>select的变体pselect，调用的时候可以额外指定一个信号屏蔽字</li>
</ul>
</li>
<li>poll
<ul>
<li>poll不像select一样为每个条件分别构造一个描述符集，而是采用一个数组，每个元素都是一个结构体，指定了文件描述符和事件类型。事件类型有两个，一个由用户写入，作为参数，一个由内核写入，作为返回。</li>
<li>poll突破了文件描述符1024上限的限制</li>
</ul>
</li>
<li>epoll
<ul>
<li>epoll由linux 2.6版本引入</li>
<li>epoll有三个函数
<ul>
<li>epoll_create，创建epoll句柄（也是一个文件描述符）</li>
<li>epoll_ctl，注册文件描述符和事件</li>
<li>epoll_wait，等待事件发生</li>
</ul>
</li>
<li>相比select和poll，epoll解决了什么问题
<ol>
<li>解决了select文件描述符上限是1024这个问题</li>
<li>对于select和poll，内核通过轮询来检查文件描述符的状态，文件描述符越多，效率越低</li>
<li>select和poll的每次调用是不相关的，每次调用都要重新构造参数，每次调用都会发生从用户态到内核态的内存拷贝</li>
</ol>
</li>
<li>epoll的原理
<ul>
<li>epoll背后有一套数据结构在做支撑，因此不需要每次调用epoll_wait之前都重新注册文件描述符，减少了内存拷贝</li>
<li>epoll不是通过轮询来检查文件描述符的状态，而是给每个文件描述符注册一个回调函数，一旦有注册事件发生，就会调用回调函数把文件描述符加入一个就绪列表，epoll_wait函数只是把这个就绪列表返回给用户，效率大大提升。</li>
<li>epoll有两种工作模式LT（level-trigger, 水平触发，默认）和ET（edge-trigger, 边缘触发）
<ul>
<li>LT是如果一个文件描述符处于就绪状态，内核就会通知你操作，即使你每次都不做操作，内核还是每次都会通知你。LT同时支持阻塞式I/O和非阻塞式I/O</li>
<li>ET是内核只有在文件描述符发生变化的时候才会通知你，如果文件描述符就绪了，你没有做任何操作或者数据没读完，下次内核就不会继续通知你了，因为文件描述符的状态没有变。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="linux进程">linux进程</h3>
<ul>
<li>fork是一种copy-on-write机制</li>
<li><strong>孤儿进程</strong>，父进程结束的进程，由init进程接管，父进程变为init进程</li>
<li><strong>僵尸进程</strong>，进程结束执行后，其进程控制块（task_struct）一直没被父进程回收，处于这个状态的进程叫做僵尸进程。
<ul>
<li>进程控制块通常是由父进程调用wait函数来回收，以获取子进程的返回码，运行状态等信息。</li>
<li>解决办法，kill掉其父进程，僵尸进程会被init进程接管并回收。</li>
</ul>
</li>
<li>进程组
<ul>
<li>每个进程都属于一个进程组</li>
<li>每个进程组有一个组长进程，组长进程的进程id和进程组一致</li>
<li>fork的子进程默认加入父进程的进程组</li>
</ul>
</li>
<li><strong>会话（session）</strong>
<ul>
<li>会话和一个控制终端相关联，一个会话包含多个进程组，其中有一个是前台进程组，其他的是后台进程组</li>
<li>会话首进程是控制进程，没有终端，会话首进程成为一个新进程组的组长</li>
<li>用户在shell中启动的一个进程组称为一个作业</li>
<li>只有前台作业能接受终端输入</li>
</ul>
</li>
<li>孤儿进程组
<ul>
<li>如果一个组的某个进程的父进程是同一会话中的另一个组的进程，那么这个组就不是孤儿进程组，否则它是孤儿进程组</li>
<li>换个说法，一个组的所有进程的父进程要么是组内的一个进程，要么是会话外的一个进程。</li>
<li>对于孤儿进程组，操作系统会给它们中的停止进程发送SIGHUP（挂断）信号。</li>
</ul>
</li>
<li><strong>守护进程</strong>
<ul>
<li>守护进程是一种长期在系统后台运行的进程</li>
<li>内核守护进程
<ul>
<li>ps命令输出的方括号中的进程是内核守护进程</li>
<li>所有的内核进程由2号进程kthreadd创建，kthreadd也是一个内核进程。</li>
<li>比如kswapd，负责内存换页</li>
</ul>
</li>
<li>用户守护进程
<ul>
<li>由1号进程init创建，init是用户态进程(init进程是传统的linux初始化进程，systemd是较新的Linux初始化进程，pid也是1)</li>
<li>比如inetd服务，负责侦听系统网络端口</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="linux进程间通信ipc">linux进程间通信（IPC）</h3>
<ul>
<li><strong>信号</strong>，信号是一种软中断机制
<ul>
<li>进程可以给一个信号注册一个处理函数，一旦接收到信号，就执行这个处理函数</li>
<li>如何发信号
<ul>
<li>用户按下某些终端按键，如ctrl+c</li>
<li>用户使用某些特殊命令，如kill</li>
<li>函数调用，如kill、raise、alarm</li>
</ul>
</li>
<li>作业控制信号
<ul>
<li>SIGINT，中断信号（ctrl+c），值为2，允许程序在退出前清理资源</li>
<li>SIGABRT，异常终止信号</li>
<li>SIGQUIT，退出（ctrl+\）</li>
<li>SIGTSTP，暂停（ctrl+z），可以忽视</li>
<li>SIGSTOP，暂停，不能忽视</li>
<li>SIGCONT，继续执行信号</li>
<li>SIGHUP信号，挂断会话</li>
</ul>
</li>
<li>其他信号
<ul>
<li>SIGTERM，请求退出</li>
<li>SIGKILL，强制退出，值为9，程序会立即被终止，无法进行任何清理或资源释放</li>
<li>SIGIO，IO事件</li>
</ul>
</li>
</ul>
</li>
<li><strong>管道</strong>
<ul>
<li>只能在有公共祖先的进程间通信，比如父子进程</li>
<li>调用pipe函数创建管道，返回两个文件描述符，对应管道的两端</li>
<li>通常的做法是在父进程创建管道，然后fork子进程，这样子进程也拥有了这个管道。进程把自己不用的那端关掉。</li>
<li>协同进程，现在有一个程序P，它从标准输入读，写到标准输出，如果有一个进程A，利用管道写P的标准输入，读P的标准输出，那么执行P的进程就是A的协同进程。
<ul>
<li>具体实现，A fork 进程B，创建两个管道p1和p2，p1的方向是从A到B，p2的方向相反，然后在进程B中执行程序P，并将P的标准输入改为p1的读端，将P的标准输出改为p2的写端，这样就实现了A输出到P的标准输入，A从P的标准输入读，此时，B是A的协同进程。</li>
</ul>
</li>
</ul>
</li>
<li><strong>FIFO</strong>，又称命名管道
<ul>
<li>和管道不同，FIFO可以在两个不相关的进程之间使用</li>
<li>FIFO创建在文件系统中，有路径名</li>
</ul>
</li>
<li>三种XSI IPC（XSI是POSIX.1中的X/Open系统接口的简写，属于一种Unix规范）
<ul>
<li><strong>消息队列</strong>
<ul>
<li>是内核中的一个链表，由消息队列标识符标识</li>
<li>消息队列可以实现全双工通信</li>
<li>消息队列最初的设计目的是提供全双工的高速通信，但随着后来很多新的IPC机制的提出，消息队列的性能优势已经不复存在，并且由于它存在的一些问题，新的程序里已经不推荐使用消息队列了。</li>
<li>缺陷，没有引用计数</li>
</ul>
</li>
<li><strong>信号量</strong>，是一个计数器，用来控制对临界资源的访问
<ul>
<li>缺陷，信号量不是一个单个非负值，而是一个信号量值的集合；信号量的定义和初始化不是原子的；无端增加程序的复杂性</li>
</ul>
</li>
<li><strong>共享内存</strong>
<ul>
<li>共享内存允许多个进程共享一段内存空间，数据不需要来回拷贝，所以共享内存是一种最快的IPC</li>
<li>共享内存段要先申请，然后连接到进程自己的内存地址空间</li>
</ul>
</li>
<li>XSI IPC的统一缺陷
<ul>
<li>它们在内核中是全局的，没有引用计数，不会自动回收，必须手动释放</li>
<li>XSI IPC的资源不是文件描述符的形式，而是各自专用的标识符</li>
</ul>
</li>
</ul>
</li>
<li><strong>posix信号量</strong>
<ul>
<li>解决了XSI信号量的不少问题，性能更高，没有信号量集的设定，不需要手动管理</li>
<li>推荐用这个</li>
</ul>
</li>
<li><strong>内存映射/存储映射</strong>（memory-mapped I/O mmap）
<ul>
<li>把一个文件直接映射为一段内存地址，读写这段内存地址就相当于对这个文件I/O</li>
<li>利用mmap实现</li>
</ul>
</li>
<li><strong>socket</strong>
<ul>
<li>tcp、udp、unix域</li>
</ul>
</li>
<li><strong>记录锁</strong>
<ul>
<li>对文件上锁，可以只对文件的一部分上锁</li>
<li>三种操作：共享读、独占写、解锁</li>
<li>记录锁只能用于多进程，不能用于多线程</li>
</ul>
</li>
</ul>
<h3 id="linux线程同步">linux线程同步</h3>
<ul>
<li>线程基本操作
<ul>
<li>创建，pthread_create</li>
<li>终止，pthread_exit</li>
<li>等待其他线程执行完毕，pthread_join</li>
<li>请求取消另外一个线程，pthread_cancel，取消是一种非正常退出</li>
<li>分离，pthread_detach，join操作不能等待分离线程</li>
</ul>
</li>
<li>线程其他操作
<ul>
<li>获取线程id</li>
<li>注册线程清理函数</li>
</ul>
</li>
<li>线程同步
<ul>
<li>所有锁都可以设置阻塞时间</li>
<li><strong>互斥量mutex</strong></li>
<li><strong>读写锁</strong></li>
<li><strong>条件变量</strong>
<ul>
<li>和互斥量配合使用</li>
<li>使用步骤
<ol>
<li>用户设定一个条件</li>
<li>一个线程因等待条件成立而阻塞，<code>pthread_cond_wait()</code></li>
<li>另外一个线程使条件成立，<code>pthread_cond_broadcast()</code>或<code>pthread_cond_signal()</code></li>
</ol>
</li>
<li>条件变量分为两部分: 条件和变量。条件本身是由互斥量保护的，线程在改变条件状态前先要锁住互斥量。具体过程是这样的：线程进入wait前，由用户加锁mutex，线程进入wait后释放mutex，保证wait过程是原子操作；唤醒也一样，唤醒前先加锁，唤醒后解锁；</li>
<li>条件变量类似于一个信号，线程本质上等待的是信号状态的改变</li>
</ul>
</li>
<li><strong>自旋锁</strong>，不会让线程进入阻塞状态，而是进入忙等待状态，一直占用cpu资源</li>
<li><strong>屏障</strong>，各个线程在各自的某个位置设置一个屏障，先执行到屏障的线程停下来等待，等足够多的线程执行到屏障位置，大家再一起往下执行。pthread_join就是一种屏障，只不过只有一个线程在等待。</li>
</ul>
</li>
</ul>
<h3 id="linux内核">linux内核</h3>
<ul>
<li>linux内核主要负责
<ul>
<li>内存管理</li>
<li>进程和线程管理</li>
<li>设备驱动</li>
</ul>
</li>
<li>内核态和用户态
<ul>
<li>内核态是内核程序运行的空间</li>
<li>用户态是用户程序运行的空间</li>
</ul>
</li>
<li>系统调用，内核态对用户态提供的访问接口</li>
<li>内存管理
<ul>
<li>存储层次，CPU、缓存、内存、外存</li>
<li>段页式内存管理
<ul>
<li>把内存划分为大的段，在段内部分页</li>
<li>一个地址的高位是段地址，地位是页地址</li>
<li>段表相当于是页表的索引</li>
</ul>
</li>
<li>快表（TLB）和页表，块表是页表的缓存</li>
<li>numa，现代多核cpu通常是numa结构，每个核心都有自己的cache，可访问内存区域等，构成了每个核心的内存访问子系统</li>
</ul>
</li>
<li>进程的内存布局
<ul>
<li>代码区</li>
<li>数据区，已初始化的变量区</li>
<li>BSS区，未初始化的变量区</li>
<li>堆区</li>
<li>栈区</li>
</ul>
</li>
</ul>
<h2 id="网络">网络</h2>
<h3 id="基础-1">基础</h3>
<ul>
<li>网络体系结构
<ul>
<li>OSI七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层
<ul>
<li>会话层想要解决两个应用程序之间的会话管理问题</li>
<li>表示层想要解决的是两个应用程序之间通信的语法语义问题，数据转换问题（编码解码，压缩和解压缩）</li>
</ul>
</li>
<li>五层：物理层，数据链路层，网络层，传输层，应用层</li>
<li>TCP/IP四层：网络接口层，网络层，传输层，应用层</li>
</ul>
</li>
<li>数据链路层协议，CSMA/CD、PPP、PPPoE</li>
<li>网络层协议，IP、ARP、RARP、OSPF、RIP、BGP
<ul>
<li>路由协议，OSPF、RIP、BGP，内部网关协议IGP是一类协议</li>
<li>OSPF，是一种内部网关协议，开放最短路径优先协议，基于IP</li>
<li>RIP，是一种内部网关协议，距离矢量，基于UDP</li>
<li>BGP，边界网关协议，距离矢量，基于TCP</li>
</ul>
</li>
<li>传输层协议，TCP、UDP</li>
<li>哪些基于UDP，RIP、DNS、DHCP</li>
<li>http状态码
<ul>
<li>1开头，信息性状态码，接受的请求正在处理</li>
<li>2开头，成功</li>
<li>3开头，重定向</li>
<li>4开头，客户端错误</li>
<li>5开头，服务端错误</li>
</ul>
</li>
<li>HTTP 1.0 为短连接，HTTP 1.1 支持长连接</li>
</ul>
<h3 id="tcp报文结构">TCP报文结构</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">TCP报文结构（20字节定长首部 + 可选首部 + 数据部分）
</span></span><span class="line"><span class="cl">下面是20字节定长首部的结构示意图：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  0      4       8      12      16      20      24      28      32
</span></span><span class="line"><span class="cl">  +-------+-------+-------+-------+-------+-------+-------+-------+
</span></span><span class="line"><span class="cl">  |        源端口（16位）         |      目的端口（16位）         |
</span></span><span class="line"><span class="cl">  +-------------------------------+-------------------------------+
</span></span><span class="line"><span class="cl">  |                        序号（32位）                          |
</span></span><span class="line"><span class="cl">  +---------------------------------------------------------------+
</span></span><span class="line"><span class="cl">  |                     确认号（32位）                           |
</span></span><span class="line"><span class="cl">  +---------------------------------------------------------------+
</span></span><span class="line"><span class="cl">  | 数据偏移 | 保留 | 控制位 |        窗口（16位）                |
</span></span><span class="line"><span class="cl">  |  (4位)  | (6位)| (6位)  |                                    |
</span></span><span class="line"><span class="cl">  +-------------------------------+-------------------------------+
</span></span><span class="line"><span class="cl">  |         校验和（16位）        |    紧急指针（16位）            |
</span></span><span class="line"><span class="cl">  +-------------------------------+-------------------------------+
</span></span><span class="line"><span class="cl">  |           选项（可变）        |           填充（可变）         |
</span></span><span class="line"><span class="cl">  +---------------------------------------------------------------+
</span></span><span class="line"><span class="cl">  |                        数据部分（可变）                       |
</span></span><span class="line"><span class="cl">  +---------------------------------------------------------------+
</span></span></code></pre></td></tr></table>
</div>
</div><p>说明：</p>
<ul>
<li>序号，4字节，报文序号</li>
<li>确认号，4字节，期望下次收到报文的序号</li>
<li>数据偏移：4位，TCP首部长度（以4字节为单位），因此TCP首部最长60字节</li>
<li>保留：6位，保留未用</li>
<li>控制位：6位（URG, ACK, PSH, RST, SYN, FIN）
<ul>
<li>紧急字段URG，当URG=1时，代表此报文段中有紧急数据，应尽快传送。</li>
<li><strong>确认字段ACK</strong>，当ACK=1时，表示确认，且确认号有效；当ACK=0时，确认号字段无效。</li>
<li>推送字段PSH，当PSH=1时，则报文段会被尽快地交付给目的方，不会对这样的报文段使用缓存策略。</li>
<li>复位字段RST，当RST为1时，表明TCP连接中出现了严重的差错，必须释放连接，然后再重新建立连接。</li>
<li><strong>同步字段SYN</strong>，当SYN=1时，表示发起一个连接请求。</li>
<li><strong>终止字段FIN</strong>，用来释放连接。当FIN=1时，表明此报文段的发送端的数据已发送完成，并要求释放连接。</li>
</ul>
</li>
<li>窗口：2字节，接收窗口大小</li>
<li>校验和：2字节，首部和数据的校验</li>
<li>紧急指针：2字节，紧急数据的偏移量</li>
<li>选项和填充：可选字段，首部长度大于20字节时存在</li>
<li>数据部分：实际传输的数据内容</li>
</ul>
<h3 id="tcp三次握手四次挥手">TCP三次握手四次挥手</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">================ TCP三次握手交互 ==================
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Client                                          Server
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            |                                |  CLOSED
</span></span><span class="line"><span class="cl">CLOSED      |                                |  LISTEN
</span></span><span class="line"><span class="cl">            | ---- SYN(seq=x) -------------&gt; |  
</span></span><span class="line"><span class="cl">SYN-SENT    |                                |  
</span></span><span class="line"><span class="cl">            | &lt;--- SYN(seq=y),ACK(ack=x+1) - |
</span></span><span class="line"><span class="cl">            |                                |  SYN-RCVD
</span></span><span class="line"><span class="cl">            | ---- ACK(ack=y+1) ------------&gt;|  
</span></span><span class="line"><span class="cl">ESTABLISHED |                                |  ESTABLISHED
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">================ TCP四次挥手交互 ==================
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Client                                         Server
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ESTABLISHED |                               |  ESTABLISHED
</span></span><span class="line"><span class="cl">            | ---- FIN(seq=u) -------------&gt;|  
</span></span><span class="line"><span class="cl">FIN-WAIT-1  |                               |  
</span></span><span class="line"><span class="cl">            | &lt;--- ACK(ack=u+1) ------------|  
</span></span><span class="line"><span class="cl">FIN-WAIT-2  |                               |  CLOSE-WAIT
</span></span><span class="line"><span class="cl">            | &lt;--- FIN(seq=v) --------------|  
</span></span><span class="line"><span class="cl">            |                               |  LAST-ACK
</span></span><span class="line"><span class="cl">            | ---- ACK(ack=v+1) -----------&gt;|  
</span></span><span class="line"><span class="cl">TIME-WAIT   |                               |  CLOSED
</span></span><span class="line"><span class="cl">CLOSED      |                               |
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>三次握手</strong></p>
<ul>
<li>客户端状态变迁：CLOSED,SYN-SENT,ESTABLISHED</li>
<li>服务端状态变迁：CLOSED,LISTEN,SYN-RCVD,ESTABLISHED</li>
<li>过程
<ol>
<li>服务端从CLOSED变为LISTEN</li>
<li>客户端发送 SYN,seq=x,从CLOSED变为SYN-SENT，x是客户端设定的初始序号</li>
<li>服务端发送 SYN,ACK,seq=y,ack=x+1，从LISTEN变为SYN-RCVD</li>
<li>客户端发送 ACK,seq=x+1,ack=y+1,从SYN-SENT变为ESTABLISHED</li>
<li>服务端进入ESTABLISHED</li>
</ol>
</li>
</ul>
<p><strong>为什么不能两次握手</strong></p>
<ul>
<li>两次握手的话，服务端只有两个状态，监听和建立连接，服务端很有可能因为一个延迟收到的连接请求单方面进入连接状态，浪费资源。比如客户端向服务端发起连接，客户端重试了一次，第二次成功建立了链接，等连接释放后，服务端才接收到第一次连接请求，当方面进入了连接状态，而客户端并没有进入连接，白白浪费了客户端资源。</li>
<li>而客户端没有这个问题，因为客户端是主动发起连接的一方，只要客户端不想进入连接，不管他接收到什么数据，都不会影响客户端。</li>
<li>加了第三次握手以后，重试的连接请求只能导致客户端进入SYN-RCVD状态，不会导致进入连接状态</li>
</ul>
<p><strong>四次挥手</strong></p>
<ul>
<li>一方主动断开
<ul>
<li>主动断开方A状态变化，ESTABLISHED,FIN-WAIT-1,FIN-WAIT-2,TIME-WAIT,CLOSED</li>
<li>被动断开方B状态变化，ESTABLISHED,CLOSE-WAIT,LAST-ACK,CLOSED</li>
<li>A发送 FIN,seq=x，A从ESTABLISHED变为FIN-WAIT-1</li>
<li>B发送 ACK,ack=x+1，B从ESTABLISHED变为CLOSED-WAIT</li>
<li>A从FIN-WAIT-1变为FIN-WAIT-2</li>
<li>B发送 FIN,ACK,seq=y,ack=x+1，B从CLOSED-WAIT变为LAST-ACK</li>
<li>A发送ACK,seq=x+1,ack=y+1,A从FIN-WAIT-2变为TIME-WAIT（等待2MSL），最后变为CLOSED</li>
<li>B从LAST-ACK变为CLOSED</li>
</ul>
</li>
<li>两方同时断开
<ul>
<li>双方同时向对方发送FIN，同时回复ACK，分别进行两次挥手，同时释放连接</li>
</ul>
</li>
</ul>
<p><strong>为什么要四次挥手</strong></p>
<p>让被动断开的一方把剩余数据传输完毕</p>
<p><strong>主动断开的一方为什么要等待2MSL</strong></p>
<p>MSL是报文在网络中的最大生存时间，2MSL正好是报文一次往返的时间，这是为了确保对方收到了最后的ACK，避免对方ACK丢失重发FIN时主动关闭方收不到，从而无法关闭连接。</p>
<p>同时也是为了防止新连接收到网络上遗留的上次连接的旧数据包。</p>
<h3 id="tcp如何保证可靠传输">TCP如何保证可靠传输</h3>
<ul>
<li>序列号和确认号<br>
每个TCP报文段都有一个序列号，用于标识数据的顺序；接收方通过确认号来告诉发送方自己已经收到的数据。
<ul>
<li>选择确认（SACK），场景：接收方收到了一些数据，但另一些数据没有收到（或未按序到达），接收方希望发送方有选择地重传，而不是重传整个窗口的数据。</li>
</ul>
</li>
<li>超时重传<br>
发送方在规定的时间内没有收到确认应答，会自动重传未被确认的数据包</li>
<li>有序传输<br>
接收方会根据序号将乱序到达的数据重新排序后交给应用层</li>
<li>校验和<br>
TCP报文段包含一个校验和字段，用于检测数据在传输过程中是否发生了错误。</li>
</ul>
<h3 id="tcp流量控制">TCP流量控制</h3>
<p>流量控制是指让发送方发送不要太快，让接收方来得及接收，主要利用滑动窗口来实现流量控制。</p>
<p><strong>什么是滑动窗口</strong></p>
<ul>
<li>发送窗口和接收窗口
<ul>
<li>发送窗口中是允许发送的字节，发送窗口之前是已发送并得到确认的字节，发送窗口之后是不允许发送的字节</li>
<li>接收窗口中是允许接收的字节，接收窗口之前是已经收到并确认过的字节，接收窗口之后是不允许接收的字节</li>
<li>发送窗口是发送方的发送缓存的一部分；接收窗口是接收方的接收缓存的一部分</li>
</ul>
</li>
<li>窗口中的每个字节都有序号<br>
发送窗口的序号是发送方的序号，接收窗口的序号是接收方的序号，相互独立，各是各的</li>
<li>发送方和接收方
<ul>
<li>每一方都有自己的发送窗口和接收窗口；因此A的发送窗口和B的接收窗口是一对，反之是另外一对</li>
</ul>
</li>
</ul>
<p><strong>如何利用滑动窗口控制流量</strong></p>
<p>B会在每个TCP报文里带上自己当前的接收窗口大小，将自己的接收窗口大小发送给A，A会根据接收窗口的大小确定自己发送窗口的大小，因此发送窗口一定不会大于接收窗口</p>
<p>当接收方感觉发送速率过快时，减小接收窗口，并将新的窗口值发送给发送方。</p>
<p>零窗口时（接收窗口降为0时），发送方启动一个计时器，每隔一段时间发送一个探测报文，去获得当前最新的窗口值；防止接收方发出的窗口值更新报文滞留在网络中。</p>
<h3 id="tcp拥塞控制">TCP拥塞控制</h3>
<p>拥塞控制的目的是防止大量的报文进入网络中，把负载控制在网络可承受的范围内。</p>
<p><strong>拥塞窗口</strong>，发送方根据网络状态自己计算出的一个窗口；可以理解为发送窗口=min（拥塞窗口cwnd，接收窗口rwnd）</p>
<p><strong>有四种拥塞控制算法，分别是慢开始，拥塞避免，快重传和快恢复</strong>，这四种算法通过调整拥塞窗口的大小来控制网络的拥塞。</p>
<ul>
<li><strong>慢开始</strong>：
<ul>
<li>发送方逐渐增加拥塞窗口，而不是一下子增大拥塞窗口。</li>
<li>发送方将拥塞窗口cwnd设置为1，即1个报文段的大小（MSS），每收到一个确认，就把拥塞窗口增大1个报文段的大小（MSS），直到达到一个门限值ssthresh。注意，<strong>拥塞窗口实际是按乘法增加的（每次翻倍）</strong>，因为拥塞窗口增加后，发送方能发出更多的报文，能收到更多的确认，拥塞窗口会增加速度会越来越快。</li>
</ul>
</li>
<li><strong>拥塞避免</strong>：
<ul>
<li>慢开始和拥塞避免这两个过程之间有一个<strong>门限值ssthresh</strong>，拥塞窗口过了这个门限值以后切换为拥塞避免算法。</li>
<li>拥塞避免算法把拥塞窗口的<strong>乘法增大改为加法增大</strong>，不再按收到的ack回复增大，而是每隔一个往返时间RTT就增大一个报文段的大小（MSS）</li>
<li><strong>发生超时后，把门限值设为当前拥塞窗口的一半，cwnd重置为1，从慢开始算法重新开始</strong>。</li>
</ul>
</li>
<li><strong>快重传</strong>
<ul>
<li>快重传是为了避免发送方误以为网络发生了拥塞从而降低传输效率；，</li>
<li>当接收方收到一个失序的数据包（即收到了后续的数据，但中间某个数据包丢失）时，会对最后一个按序收到的数据包的确认号进行重复确认，发送方一旦收到连续三个重复确认，就知道有数据丢失了，马上重传数据，而不进入超时等待；</li>
</ul>
</li>
<li><strong>快恢复</strong>
<ul>
<li>发送方现在知道了只是<strong>丢失了个别数据</strong>，因此重传的时候不执行慢开始，<strong>把发送窗口增大到门限值后直接进入拥塞避免</strong>算法；</li>
</ul>
</li>
</ul>
<h3 id="unix套接字">unix套接字</h3>
<ul>
<li>概念
<ul>
<li>进程，是一个通信实体</li>
<li>ip:port，是一种通信地址资源</li>
<li>unix套接字，是对一个通信端点的抽象</li>
<li>套接字类型（可以看作是对传输特性的描述）
<ul>
<li>SOCK_DGRAM，固定长度、无连接、不可靠的报文传输</li>
<li>SOCK_STREAM，面向连接、有序、可靠的字节流传输</li>
<li>SOCK_RAW，IP协议的数据报接口</li>
<li>SOCK_SEQPACKET，固定长度、面向连接、有序、可靠的报文传输</li>
</ul>
</li>
<li>域类型
<ul>
<li>AF_INET，IPv4域</li>
<li>AF_INET6，IPv6域</li>
<li>AF_UNIX，unix域</li>
<li>AF_UNSPEC，未指定</li>
</ul>
</li>
<li><strong>套接字和域的组合决定了协议</strong>，一个组合可以对应多个协议，在IPv4域中，SOCK_STREAM默认对应TCP协议，SOCK_DGRAM默认对应UDP协议</li>
</ul>
</li>
<li>操作
<ul>
<li>socket，创建一个套接字</li>
<li>bind，绑定一个ip:port</li>
<li>服务端
<ul>
<li>listen，监听请求，监听请求的套接字称为原始套接字</li>
<li>accept，获得一个连接请求并建立连接，每个连接对应一个新套接字，它们的地址和原始套接字相同</li>
</ul>
</li>
<li>客户端
<ul>
<li>connect，和服务端建立连接</li>
</ul>
</li>
<li>close，关闭套接字</li>
</ul>
</li>
<li><strong>一个ip:port可以建立多个tcp连接吗？</strong>
<ul>
<li>连接是通过套接字建立的，<strong>一般情况下，一个ip:port只能绑定到一个套接字上</strong>，如果ip:port被占用，又试图去用另外一个套接字用这个地址通信，就会出现端口冲突。</li>
<li>对于服务端，原始套接字负责监听，每建立一个连接，就创建一个新套接字负责数据传输，原始套接字和新套接字共用一个地址。因此，<strong>对于服务端，一个ip:port可以通过原始套接字建立多个tcp连接</strong>。或者说，只能有一个套接字监听一个ip:port，但是可以和多个客户端建立连接。</li>
<li>对于客户端，没有原始套接字的概念，一个套接字只能建立一个tcp连接，因而，<strong>对于客户端，一个ip:port只能建立一个tcp连接</strong>。</li>
</ul>
</li>
</ul>
<h2 id="mysql">mysql</h2>
<h3 id="索引">索引</h3>
<ul>
<li>什么是索引
<ul>
<li>索引是一种能实现对表中某一列或多列的值快速查找的数据结构，常见的是 B+树</li>
<li>B+树是一种多叉搜索树，叶节点是数据节点，存放着指向行数据的指针，叶节点之间顺序链接</li>
<li>没有索引的时候，数据的物理存储是按插入顺序存储的，查找数据时要逐行查找</li>
</ul>
</li>
<li>索引的优缺点
<ul>
<li>优点：
<ul>
<li>加快查询速度</li>
<li>缩小锁的范围（比如 gap lock 和 next key lock）</li>
</ul>
</li>
<li>缺点：维护索引要耗费时间和空间，会降低写入速度</li>
</ul>
</li>
<li>mysql 索引分类
<ul>
<li>普通索引、唯一索引、主键索引
<ul>
<li>普通索引允许重复值和空值</li>
<li>唯一索引不允许重复值，但允许空值</li>
<li>主键索引既不允许重复值，又不允许空值</li>
</ul>
</li>
<li>单列索引和组合索引
<ul>
<li>组合索引是在多列上构建的索引，查询条件必须满足两个条件：（1）符合组合索引的最左前缀原则（2）用 and 连接时才会触发组合索引</li>
<li>什么是最左前缀原则呢？就是查询时，必须按创建索引时字段的顺序去用and连接，比如对三个字段创建了一个组合索引，<code>Index index1 (name,age,city)</code>，查询的时候只能以<code>name=&quot;swj&quot; and age=30</code> 或者 <code>name=&quot;swj&quot; and age=30 and city='tianjin'</code>这两种方式去查询，不能跳过age，直接以name和city去查询，相当于创建了两个索引<code>(name,age)</code>和<code>(name,age,city)</code></li>
</ul>
</li>
<li>全文索引
<ul>
<li>可以在列上进行全文搜索</li>
</ul>
</li>
</ul>
</li>
<li>怎么判断要不要加索引
<ul>
<li>加
<ul>
<li>在频繁进行条件判断、分组、排序的列上创建索引</li>
<li>多读少写或者对读操作耗时要求高时加索引</li>
</ul>
</li>
<li>不加
<ul>
<li>写多读少时不要加所索引</li>
<li>不做条件判断的列不要加索引</li>
<li>数据大量重复时也不应该加索引</li>
</ul>
</li>
</ul>
</li>
<li>索引命中和失效
<ul>
<li>不符合左前缀原则会导致组合索引失效</li>
<li>where 条件不用 and 连接会导致组合索引失效</li>
<li>在索引列上做计算、函数调用、不等于比较会导致索引失效</li>
<li>可以用 explain 语句查看是否命中索引，explain 语句是用来查看 sql 执行计划的</li>
</ul>
</li>
<li>索引实现上分为聚集索引和非聚集索引
<ul>
<li>一个表只能有一个聚集索引，之所以叫聚集索引，是因为数据的物理存储顺序就是按聚集索引的排序存储的，也是因为这个原因，一个表只能有一个聚集索引。InnoDB 的聚集索引叶节点存储完整的数据记录。</li>
<li>其他索引都属于非聚集索引，非聚集索引也叫二级索引或者辅助索引，非聚集索引有两种情况
<ol>
<li>数据节点不是直接指向数据记录，而是保存一个聚集索引的 key，每次对非聚集索引的查找都要到聚集索引上查一次数据，这叫“<strong>回表</strong>”。（mysql 的 InnoDB 引擎）</li>
<li>叶节点直接指向对应的数据块。（mysql 的 MyISAM）</li>
</ol>
</li>
<li>mysql InnoDB 引擎一定会构建一个聚集索引，默认会将主键索引作为聚集索引，如果没有主键索引，会将第一个没有空值的唯一索引作为聚集索引，否则会在一个隐藏的 ROWID 上构建聚集索引，ROWID 是行的唯一标识</li>
<li>组合索引是以多个列的组合作为 key，例如&quot;(2,3)&quot;</li>
</ul>
</li>
</ul>
<h3 id="2kw-是数据量上限这个说法从何而来">2kw 是数据量上限这个说法从何而来</h3>
<ul>
<li>我们通常认为 B+树超过三层性能会下降</li>
<li>mysql innodb 一个 B+树节点 16KB，可用空间 15KB</li>
<li>假设 key 是 bigint 类型（8B），key 加指针（4B）一共 12B</li>
<li>因此第二层有 1280 个节点，第三层有 1280*1280 个节点</li>
<li>假设单行数据 1KB，那三层 B+树支持的数据量是 1280*1280*15KB/1KB=24576000，也就是 2kw+</li>
<li>2kw 只是个参考值，单行数据量如果不是 1KB，数据量上限就不是 2kw 了。机器的硬件配置也会影响 mysql 的性能，比如用 ssd 代替机械硬盘、使用大内存都会提高 mysql 的性能。</li>
</ul>
<h3 id="事务">事务</h3>
<p>事务（transaction）的目的是要保证一连串数据操作的原子性，并能够支持操作回滚</p>
<ul>
<li>ACID 特性（原子性、一致性、隔离性、持久性）
<ul>
<li>原子性：一连串操作要么全完成，要么全不完成</li>
<li>一致性：事务执行前后，数据处于一致的状态，数据不会被破坏</li>
<li>隔离性：并发执行的事务之间互不干扰</li>
<li>持久性：一旦事务提交，数据就会被永久保存到数据库中</li>
</ul>
</li>
<li>InnoDB 如何实现事务的 ACID 特性
<ul>
<li>原子性，通过 undo log （回滚日志）回滚，事务执行前会记录操作前的数据到 undo 日志，若事务失败或回滚，可以利用 undo 日志恢复到原始状态。</li>
<li>一致性</li>
<li>隔离性
<ul>
<li>通过锁保证隔离性，事务在修改数据之前先对数据上锁。锁按照粒度分为表锁和行锁。</li>
<li>使用 MVCC（多版本并发控制）保证隔离性</li>
<li>mysql支持四种隔离级别</li>
</ul>
</li>
<li>持久性，数据落盘之前先要放到 buffer pool，buffer pool 的数据会定期刷到磁盘上去，写入 buffer pool 之前先写到 redo log 中，保证数据不会因宕机丢失</li>
</ul>
</li>
</ul>
<h3 id="事务的并发问题">事务的并发问题</h3>
<ol>
<li>脏读：当前事务可以读取到其他事务未提交的数据</li>
<li>不可重复读：当前事务前后两次使用相同的查询语句查到了不同的数据，原因是在事务执行过程中，有其他事务对这批数据做了<strong>增删改</strong>操作。<strong>如果当前事务的两次读操作分别发生在其他事务开始前和提交后，读到的数据不一致，这就不算脏读，属于不可重复读问题</strong>。</li>
<li>幻读：事务进行读操作发现数据不存在，试图插入数据，但是插入失败，或者事务发现数据存在，试图更新数据，但更新失败，原因是事务读数据后，有其他事务对数据做了<strong>增删</strong>操作。<strong>即使数据库能够保证不发生脏读和不可重复读,仍有可能发生幻读，现象是每次读数据结果都是不存在，但就是不能插入数据，或者是每次读数据结果都是存在，但就是更新不了。</strong></li>
</ol>
<p>不可重复读和幻读是类似的问题，都是由于事务执行过程中其他事务把数据改了造成的。</p>
<h3 id="innodb-的锁">InnoDB 的锁</h3>
<ul>
<li>InnoDB 的锁按粒度分为
<ul>
<li>行锁和表锁</li>
<li>意向锁和非意向锁</li>
</ul>
</li>
<li>按并发控制分为共享锁和排他锁
<ul>
<li>共享锁：可以对数据上多个共享锁，但不能同时上共享锁和排他锁（有点像并发编程的读锁）</li>
<li>排他锁：只能对数据上一个排他锁（有点像并发编程的写锁）</li>
</ul>
</li>
<li>意向锁只能是表级，非意向锁可以是表级的也可以是行级的，因此一共有 6 种组合
<ul>
<li>表级的排他锁</li>
<li>表级的共享锁</li>
<li>行级的排他锁</li>
<li>行级的共享锁</li>
<li>表级的排他意向锁</li>
<li>表级的共享意向锁</li>
</ul>
</li>
<li><strong>申请行级锁之前要先申请表级的意向锁</strong>（意向锁相当于是行锁在表这个级别的代表）</li>
<li>表级锁互斥性（X-排他锁，S-共享锁，I-意向锁）
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>IX</td>
<td>×</td>
<td>√</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>S</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>IS</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
</li>
<li>行锁有三种
<ul>
<li>record lock，单行锁</li>
<li>gap lock，锁住两个索引值之间的空隙（空隙是指还没有插入值），目的是为了防止幻读，注意，如果没有命中索引，gap 锁会锁全表。</li>
<li>next-key lock，以上两种锁的结合，也是为了防止幻读。</li>
</ul>
</li>
</ul>
<h3 id="悲观锁和乐观锁">悲观锁和乐观锁</h3>
<p>悲观锁和乐观锁是广泛存在的概念，是两种解决并发冲突问题的策略，不只在数据库领域中存在</p>
<p>悲观锁是指对数据并发持悲观态度，认为一定会冲突，悲观锁是在操作数据之前对数据上锁</p>
<p>乐观锁是指对数据并发持乐观态度，认为不一定会冲突，不会提前对数据上锁，乐观锁一般会在更新数据前做一个校验，校验通过了才会更新，否则重试，乐观锁一般会使用版本号机制或 CAS （Compare And Swap）算法实现，<strong>乐观锁适合读多写少的场景，如果写多的话，会导致大量的重试，反而更浪费资源</strong></p>
<p><strong>版本号机制</strong></p>
<p>定义一个版本号字段，修改数据前，先查询版本号，更新数据之前检查版本号变没变，如果没变才能更新，如果变了，说明被其他并发任务改了，需要重试。<strong>关键点在于，更新+更新前检查必须是原子操作</strong>，可以使用<code>update xxx where xxx</code>来实现这一操作，这个语句会自动对数据行上排他锁</p>
<p><strong>CAS</strong></p>
<p>Compare And Swap，是一种依赖硬件的乐观锁实现，CAS需要三个值参与：</p>
<ol>
<li>变量的内存地址</li>
<li>变量的预期值</li>
<li>要更新的新值</li>
</ol>
<p>CAS会先判断变量内存地址中的值和预期值是否一致，如果变量的值等于预期值，则将变量的值更新为新值，并返回 true</p>
<p>CAS通过硬件的原子操作来保证更新的原子性，CAS操作是非阻塞的，会避免线程阻塞和上下文切换的开销</p>
<p>C++中的CAS机制：<code>atomic</code>的两个CAS操作，<code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>，atomic不保证跨进程原子性</p>
<p>windows的CAS机制：<code>InterlockedCompareExchange</code>，这个可以跨进程使用</p>
<h3 id="如何加锁">如何加锁</h3>
<p>在 mysql 中，有些SQL语句会自动加锁，有些锁需要手动指定</p>
<ol>
<li>修改表会自动加锁</li>
<li>可以手动为表级操作加表锁，表锁分为读写锁，
<ul>
<li>读锁（共享锁）：<code>LOCK TABLES table_name READ</code>，<code>UNLOCK TABLES</code></li>
<li>写锁（排他锁）：<code>LOCK TABLES table_name WRITE</code>，<code>UNLOCK TABLES</code></li>
</ul>
</li>
<li>写入数据的操作（Insert，Update，Delete）会自动加排他锁</li>
<li>普通的select语句不会加锁</li>
<li><code>SELECT ... FOR UPDATE</code> 会加排他锁</li>
<li><code>SELECT ... LOCK IN SHARE MODE</code> 会加共享锁</li>
<li>在事务中使用锁，锁定时间会持续到事务结束</li>
</ol>
<h3 id="innodb-mvcc">InnoDB MVCC</h3>
<p>MVCC 的全称是多版本并发控制，目的是提高数据库的并发性能，实现读-写冲突不加锁</p>
<p>数据库并发场景</p>
<ul>
<li>读-读：不需要并发控制</li>
<li>读-写：存在脏读、不可重复读、幻读问题</li>
<li>写-写：存在写入脏数据问题</li>
</ul>
<p><strong>版本链</strong></p>
<p>MySQL 为每一行数据维护一个版本链，其中包含了该行数据的多个版本。每个版本都有一个创建时间和一个删除时间</p>
<p>当一个事务对某行数据进行修改时，数据库系统会创建一个新的版本，并将其插入到版本链中，并记录事务的 ID 和修改时间。</p>
<p><strong>事务可见性判断</strong></p>
<p>当一个事务读取某行数据时，数据库系统会根据该事务的开始时间和版本链中的版本信息，确定该事务能够看到的版本</p>
<p><strong>一致性视图</strong></p>
<p>在 <code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code> 隔离级别下，InnoDB 会为每个事务创建一个一致性读视图，确保事务执行期间，多次读操作看到的数据是一致的。</p>
<h3 id="mysql的隔离级别">MySQL的隔离级别</h3>
<ol>
<li>读未提交（Read Uncommitted）：最低级别，不做任何保证，会出现脏读、不可重复读和幻读问题</li>
<li>读已提交（Read Committed）：解决脏读问题</li>
<li>可重复读（Repeatable Read）：<strong>默认级别</strong>，通过一致性读视图解决不可重复读问题，但还是会幻读</li>
<li>串行化（Serializable）：最高级别，通过加锁的方式来保证事务的串行执行，避免了所有的并发问题，但会严重影响数据库的性能。</li>
</ol>
<h3 id="优化">优化</h3>
<ul>
<li>表优化
<ul>
<li>建索引、去掉不该有的索引</li>
<li>拆分表，拆出频率低的字段，冗余多的字段</li>
<li>分表分库</li>
<li>优化字段类型
<ul>
<li>用整型代替字符串类型</li>
</ul>
</li>
</ul>
</li>
<li>SQL 优化
<ul>
<li>不用 select *，减少“回表”，减少网络传输</li>
<li>修改不命中索引的写法
<ul>
<li>explain 命令查看 sql 的执行计划，可以看到是否命中索引</li>
<li>不等于比较，字段上进行函数调用，对字段做计算，使用like匹配字符串</li>
<li>组合索引不符合最左前缀原则，使用or连接条件</li>
</ul>
</li>
<li>用联结查询代替子查询</li>
<li>用命中索引的范围查询代替偏移量非常大的limit语句</li>
<li>利用慢查询日志查看执行的比较慢的语句</li>
</ul>
</li>
</ul>
<h3 id="log">log</h3>
<ul>
<li>bin log，记录所有对数据的修改操作</li>
<li>redo log，用于数据的持久化，防止数据因宕机丢失</li>
<li>undo log，用于回滚数据</li>
</ul>
<h3 id="其他">其他</h3>
<p>mysql 的主从同步，利用主服务的 binlog 和从服务的 relay log 实现</p>
<h2 id="分布式">分布式</h2>
<h3 id="分布式概念">分布式概念</h3>
<p><strong>CAP原理</strong></p>
<p>一致性、可用性、分区容错性三者不可兼得</p>
<ul>
<li>一致性（Consistency），是指数据一致性，任何时刻，所有节点的数据都是一致的</li>
<li>可用性（Availability），是指系统能在有限时间内响应每个请求</li>
<li>分区容错性（Partition Tolerance），是指系统能在网络分区的情况下，继续提供服务（网络分区是指某些节点之间的网络连接中断，导致系统的网络分成好几个子分区）</li>
</ul>
<p><strong>BASE原理</strong></p>
<p>BASE原理，是在满足分区容错性的前提下，在一致性和可用性之间做的权衡，是指分布式系统可以同时满足基本可用性、软状态和最终一致性。</p>
<ul>
<li>基本可用性（Basically Available），系统在出现故障时，允许损失部分可用性（如响应时间延长、部分功能降级），但整体服务仍可用。</li>
<li>软状态（Soft State），系统中的数据状态可以有一段时间的不一致，允许存在中间状态，数据同步和一致性可以延后。</li>
<li>最终一致性（Eventual Consistency），系统在经过一段时间后，所有节点的数据会达到一致状态。</li>
</ul>
<p><strong>脑裂问题</strong></p>
<p>分布式系统发生分区错误后，各分区选举出各自新的master导致分布式系统中存在多个master的情况</p>
<h3 id="分布式锁">分布式锁</h3>
<ul>
<li>分布式锁要解决以下问题
<ol>
<li>锁失效的问题，包括集群脑裂、锁到期、锁丢失（master节点挂掉而数据同步还没完成）</li>
<li>非阻塞问题，获取不到锁要能返回失败</li>
<li>可重入问题，同一个实例，要能反复获取同一个锁</li>
</ol>
</li>
<li>基于redis实现分布式锁</li>
<li>基于zookeeper实现分布式锁</li>
<li>基于数据库实现分布式锁</li>
</ul>
<h3 id="分布式id">分布式id</h3>
<ul>
<li>为一个资源生成一个全局的唯一id</li>
<li>方法
<ul>
<li>UUID、hash（不推荐）
<ul>
<li>优点，可以本地生成，无网络消耗</li>
<li>缺点，无序，无法建立索引</li>
</ul>
</li>
<li>利用数据库自增id
<ul>
<li>缺点，存在数据库单点问题，数据库访问压力大</li>
</ul>
</li>
<li>从数据库批量获取自增id</li>
<li>利用redis的incr命令实现id的原子性自增
<ul>
<li>优点是快，缺点是贵</li>
</ul>
</li>
<li>雪花算法（snowflake）
<ul>
<li>优点，可以本地生成，不需要一个中心化的分布式id服务</li>
<li>原理其实就是通过一些特定标识的拼接，让生成的id不重复的同时还能做到有序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="redis">redis</h2>
<h3 id="redis的功能">redis的功能</h3>
<ul>
<li>redis 是什么
<ul>
<li>redis 是一种内存型 kv 数据库，性能高，它的高性能来源于内存存储和 kv 型存储，数据结构简单</li>
<li>通常用来做缓存</li>
</ul>
</li>
<li>redis 的 5 种主要数据类型
<ul>
<li>string，<code>set key value</code>, <code>get key</code>,<code>mget</code>, <code>mset</code></li>
<li>hash，key对应一个value映射表，适合存储对象，<code>hset hashkey field value</code>,<code>hget hashkey field</code>, <code>hmset</code>, <code>hmget</code>, <code>hgetall</code></li>
<li>list，支持队列和栈操作，<code>lpush key element1 element2</code>，插入到列表头部</li>
<li>set，无序集合，支持集合运算（交、并、差），查找时间O(1)</li>
<li>zset，有序集合，查找时间O(1)，每个元素关联一个分数，靠分数排序</li>
</ul>
</li>
<li>redis的单线程模型
<ul>
<li>redis的命令执行是单线程的，不存在并发问题</li>
<li>redis6.0对网络io引入了多线程，但是核心的命令执行仍然是单线程的</li>
<li>redis利用队列把网络连接和数据处理做了解耦</li>
</ul>
</li>
<li>redis为什么高性能
<ul>
<li>高性能来自内存存储和key-value数据结构</li>
<li>高并发来自基于epoll的I/O多路复用</li>
</ul>
</li>
<li><strong>redis中的原子性</strong>
<ul>
<li>redis中经常会提到“原子性”这个词，redis中的原子性是指两条命令之间不会插入其他命令，可以保证严格的前后相邻顺序，但是并不保证全部执行成功，也不会回滚，会出现指令全部执行完毕后，一部分执行成功，另一部分失败</li>
<li>哪些功能能保证原子性
<ul>
<li>单条命令</li>
<li>事务</li>
<li>lua脚本</li>
</ul>
</li>
<li>哪些保证不了
<ul>
<li>pipeline，pipeline是客户端的行为，对redis是透明的</li>
</ul>
</li>
</ul>
</li>
<li>redis的事务
<ul>
<li>redis的事务实际上就是一组顺序执行的命令集合。</li>
<li>redis保证事务执行的原子性。</li>
<li>由于redis的单线程模型，redis不存在命令的并发，也不存在隔离级别。</li>
</ul>
</li>
<li>redis的watch命令
<ul>
<li>和事务配合使用</li>
<li>watch命令用来监控一个或多个指定的key，如果在事务执行之前，被监控的key被修改，则事务取消执行。</li>
<li>类似一种乐观锁机制，防止多个客户端之间出现并发冲突。</li>
</ul>
</li>
<li>redis的setnx命令
<ul>
<li>key不存在时才会写入，写入成功返回0，写入失败返回1</li>
</ul>
</li>
</ul>
<h3 id="redis缓存击穿穿透雪崩">redis缓存击穿、穿透、雪崩</h3>
<ol>
<li>缓存击穿问题，高并发场景下，缓存过期的一瞬间，大量请求直接落到数据库的问题
<ul>
<li>限流，例如，对于一个值，只允许一个请求访问数据库，可以为这个key设置分布式锁，其他获取数据的请求等待锁释放</li>
<li>设置热点key的缓存时间为一个较长的时间</li>
</ul>
</li>
<li>缓存穿透问题，高并发场景下，大量请求查询一个在数据库和缓存中都不存在的值，导致大量请求不停地落到数据库的问题
<ul>
<li>允许存储null值</li>
</ul>
</li>
<li>缓存雪崩问题，高并发下场景下，缓存中很多值在同一时间过期，导致大量请求直接落到数据库的问题
<ul>
<li>设置随机过期时间</li>
</ul>
</li>
</ol>
<h3 id="利用redis实现分布式锁">利用redis实现分布式锁</h3>
<p><strong>方案1</strong></p>
<p>往redis里存一个key，key的值是锁的标识，并设置过期时间，当key不存在时，表示可以获取锁，获取锁后设置key的值为锁的标识，并设置过期时间。</p>
<p>设置key value的两种方法</p>
<ul>
<li>setnx + expire + lua/事务，lua/事务保证setnx+expire成为原子操作（老办法）</li>
<li><code>set key value nx ex ...</code>，set命令自带nx和ex，单条命令实现setnx + expire的功能（新办法）</li>
</ul>
<p>如何解决分布式锁失效问题，例如：</p>
<ul>
<li>锁到期释放导致误删他人锁的问题，例如，实例A上锁，实例A执行期间锁超时被释放了，实例B趁机获得了锁，A执行完毕后把B的锁给释放了。</li>
<li>主从同步延迟导致锁丢失，例如，实例A上锁，master节点挂了，锁还没同步到slave节点上，B实例趁机获得了锁，A执行完毕后把B的锁给释放了。</li>
</ul>
<p>解决办法：</p>
<ul>
<li>value设置为A的标识，释放锁时先查标识，标识对上才能释放</li>
<li>先查再删需要保证原子性，解决办法，使用lua/事务</li>
</ul>
<p><strong>方案2</strong></p>
<p>redlock算法，redis官方提出的分布式锁算法，在redis集群部署的情况下可以保证高稳定性。</p>
<p>假设redis有n个节点，该算法认为，只要超过一半的节点加锁成功，就认为加锁成功，如果加锁的时间超过了超时时间，认为加锁失败。解锁时对全部节点解锁。</p>
<h3 id="redis的缓存淘汰策略">redis的缓存淘汰策略</h3>
<ul>
<li>redis中分为两个数据字典，一个字典存所有的key-value，一个字典存key和对应的expire（称为expire字典，只有配置了过期时间的key才会在这里面）</li>
<li>redis的缓存淘汰策略
<ol>
<li>不淘汰任何键，直接返回错误</li>
<li>在所有key中随机删除</li>
<li>在所有key中使用LRU算法删除（最近最少使用）</li>
<li>在所有key中使用LFU算法删除（使用频率最低）</li>
<li>在expire字典中随机删除key</li>
<li>在expire字典中删除马上快过期的</li>
<li>在expire字典中使用LRU算法删除</li>
<li>在expire字典中使用LFU算法删除</li>
</ol>
</li>
<li>redis的key过期策略
<ul>
<li>惰性删除，当客户访问key的时候判断key是否过期，过期就删除</li>
<li>定期删除，在expire字典中随机采样，取20个key，删掉里面过期的key，如果过期key占比超过1/4，就重复这个过程</li>
</ul>
</li>
</ul>
<h3 id="如何保证缓存和数据库的一致性">如何保证缓存和数据库的一致性</h3>
<ul>
<li>分布式系统要保证分区容错性和可用性，就没办法保证数据的强一致性，最多保证最终一致性，甚至是弱一致性。</li>
<li>方案1：写入命中缓存时，既更新数据库，又更新缓存。
<ul>
<li>问题1：其中一个操作失败导致数据不一致</li>
<li>问题2：不管是先写缓存还是后写缓存，都会存在写并发问题，例如“A写缓存X=1，B写缓存X=2，B写数据库X=2，A写数据库X=1”，造成了数据不一致。</li>
</ul>
</li>
<li>方案2：写入时删除缓存，写数据库。由读请求写缓存。
<ul>
<li>问题1：其中一个操作失败导致数据不一致</li>
<li>问题2：不存在写并发问题，但存在读写并发问题。</li>
</ul>
</li>
<li>方案1和方案2都会遇到操作失败和并发问题，解决方案
<ul>
<li>对于并发问题，使用分布式锁</li>
<li>对于操作失败问题
<ol>
<li>重试，缺陷是会占用更多资源，并且即使是无限重试也不一定100%成功</li>
<li>异步重试，利用消息队列重试，缺陷是会提高系统复杂度，要解决消息队列的失败问题。</li>
<li>利用数据库的变更日志更新缓存（例如mysql的binlog）</li>
</ol>
</li>
</ul>
</li>
<li>从整体复杂度来讲，方案2更好一些，对于方案2，还可以采用写DB后延迟一段时间删除缓存的策略，尽量让缓存不会被写回旧数据</li>
<li>此外，数据不一致还可能由redis和数据库内部数据不同步导致。</li>
<li>总之，实现数据的强一致性是不可能的，最终一致性也不能百分百保证，因此，最后，引入手动补偿机制，手动修复极端情况下的不一致数据</li>
</ul>
<h2 id="mq">MQ</h2>
<h3 id="mq的用途">MQ的用途</h3>
<ul>
<li>削峰</li>
<li>解耦</li>
<li>异步</li>
</ul>
<h3 id="kafka的特点">kafka的特点</h3>
<ul>
<li>高吞吐量</li>
<li>消息可持久性存储</li>
<li>分布式，支持横向扩展</li>
<li>稳定性低，容易丢数据，容易出现数据重复</li>
</ul>
<h3 id="kafka原理">kafka原理</h3>
<ul>
<li>kafka是pull模型，不是push模型，消费者要主动拉取数据。</li>
<li>kafka分为queue模式和topic模式
<ul>
<li>queue模式，消息是按顺序消费的，消费者主动拉取消息，每个消息只能被一个消费者消费，并且只能消费一次。</li>
<li>topic模式，发布订阅模式，一个topic分多个partition，消费者组成消费者组，topic由消费者组订阅。
<ul>
<li>同一个topic中，同一个partition内的消息是有序的，不同paitition之间的消息是无序的。</li>
<li>无论消不消费，消息都不会被删除，直到过期。</li>
<li>一个消费者组订阅一个topic，消息被均衡地送给每个消费者，分配给各消费者的partition互不相同（不存在两个消费者消费同一个partition的情况）。消费者数量大于partition数量时，会有消费者空闲。</li>
<li>生产者和消费者都可以指定固定的订阅分区</li>
<li>rebalance，重平衡，消费者组内消费者数量发生变化时，分区会重新分配，这叫rebalance，消费者定期向partition发送心跳来证明自己存活。</li>
<li>一个topic可以由多个消费者组订阅，并且这些消费者组消费到的消息是完全相同的。如果想让不同的消费者消费同一个partition，就要把它们分到不同的组中。为了支持同一个消息能被多个消费者消费，kafka会记录partition中不同消费者各自的消费位置。</li>
<li>每个partition又有多个副本，其中一个是leader副本，其余的是follower副本，leader负责收发消息，follower是备份，leader和follower分布在不同的节点上。</li>
<li>kafka的节点称为broker</li>
</ul>
</li>
</ul>
</li>
<li>生产者同步发送和异步发送模式
<ul>
<li><code>producer.type</code>参数指定了生产者是同步发送还是异步发送，值为asnyc时为异步发送，值为sync时为同步发送。用户调用<code>send()</code>方法时，kafka会根据producer.type参数决定消息的发送方式，如果是同步发送，就会直接发送消息，如果是异步发送，会先把消息放入一个本地缓存，然后启动一个发送线程，当缓存中的消息满足一定条件时，发送线程批量发送消息。</li>
<li><strong>不管同步还是异步模式，消息都是按序发送的，只有发送失败时，才可能破坏发送消息的顺序。</strong></li>
<li>send函数本身的调用方式是异步调用，也就是说，不管发送模式是同步还是异步，send都会立即返回。</li>
<li><code>send().get()</code>只是将函数的调用方式从异步改成同步，并不会改变producer的发送模式。</li>
</ul>
</li>
<li>kafka如何实现三种消息传递语义
<ul>
<li>at most once，最多一次，消息不会重复，但有可能丢
<ul>
<li>ack=0就是at most once</li>
</ul>
</li>
<li>at least once，至少一次，消息不会丢，但有可能重复
<ul>
<li>ack=1或者ack=all，配合retries</li>
</ul>
</li>
<li>exaclty once，不多不少正好一次
<ul>
<li>ack=all配合retries，保证不丢数据</li>
<li>启用kafka的幂等配置，<code>enable.idempotence</code>，保证重试不会导致消息重复</li>
<li>消费者处理完消息之后再手动提交offset，保证消费</li>
</ul>
</li>
</ul>
</li>
<li>消费者自动、同步、异步提交
<ul>
<li>消费者可以配置自动提交offset（<code>auto.commit.enable</code>参数），自动提交和消费消息是异步的，消费者会定期向kafka提交offset。自动提交可能会造成消息丢失，即提交成功但是消费失败</li>
<li>手动同步提交，除了会阻塞，没什么问题</li>
<li>手动异步提交，异步提交不会发生阻塞，但是kafka没给异步提交提供重试机制（防止重试导致旧的提交覆盖新的提交）。（但是提交失败本身也会导致重复消费）</li>
</ul>
</li>
<li>kafka事务
<ul>
<li>事务场景
<ul>
<li>发送多条消息到一个topic</li>
<li>发送到多个topic、多个partition（典型的分布式事务）</li>
<li>消费-处理-发送</li>
</ul>
</li>
<li>保证多个消息、多个操作的原子性，即同时成功，同时失败，失败会回滚。</li>
</ul>
</li>
</ul>
<h3 id="kafka如何保证顺序消费">kafka如何保证顺序消费</h3>
<ul>
<li>topic端，让生产者和消费者指定同一个partition，并且保证分区有足够多的副本，防止partition挂掉。</li>
<li>生产端，单线程发送消息
<ul>
<li>消息丢失会破坏消息顺序，所以要配置ack=1或ack=all并配置重试</li>
<li>同时发出多次消息时可能会破坏消息的顺序性（异步发送的一批数据算一次），因此，要将<code>max.in.flight.requests.per.connection</code>参数设置为1（这个参数规定了生产者能同时发送多少条未经确认的消息），还要配置ack=1或ack=all能让broker确认消息。</li>
</ul>
</li>
<li>消费端，单线程消费消息</li>
</ul>
<h3 id="kafka如何防止消息丢失">kafka如何防止消息丢失</h3>
<ul>
<li>生产者丢消息
<ul>
<li>kafka客户端支持异步发送消息，生产者丢失消息会发生在这个过程中，可能会由于网络原因或者数据太大等原因发送失败</li>
<li>解决方法
<ol>
<li>配置retries，消息发送失败就重试</li>
<li>给发送方法加回调函数，消息发送失败时进行特殊处理（例如重试、记录日志并根据日志异步重试）</li>
</ol>
</li>
</ul>
</li>
<li>broker丢消息
<ul>
<li>leader分区每收到一条消息都要同步到follower，如果数据还没落盘或者没等同步完leader就挂了，某一个follower成为了新的leader，就会导致消息丢失。</li>
<li>解决办法，利用ack机制解决
<ul>
<li>ack机制是指kafka接收到消息后会向生产者发送确认，<strong>ack参数影响了kafka的消息持久性</strong>，ack参数有三种（<code>request.required.acks</code>参数）
<ul>
<li>ack = 0， 生产者不会等待broker发送ack，这种情况无法保证不丢数据。（生产者的retries参数这时也是失效的）</li>
<li>ack = 1，leader分区接收到数据后，向生产者返回ack，如果消息没有同步到follower中，就会导致数据丢失。（kafka默认的是ack=1）</li>
<li>ack = all，等leader向所有follower同步完数据，才会返回ack。</li>
</ul>
</li>
<li>可以利用ack=all配合retries参数让生产者失败重试，保证数据不丢失。（<code>message.send.max.retries</code>参数用来设置发送端重试次数）</li>
</ul>
</li>
</ul>
</li>
<li>消费者丢消息
<ul>
<li>消费者可以配置自动提交offset（<code>auto.commit.enable</code>参数），自动提交和消费消息是异步的，消费者会定期向kafka提交offset，如果offset已经提交，而消息消费失败，就会丢失消息</li>
<li>解决办法，将自动提交offset改为手动提交，消息消费完成后再提交offset</li>
</ul>
</li>
</ul>
<h3 id="kafka如何防止消息重复">kafka如何防止消息重复</h3>
<ul>
<li>消息重复的情况
<ul>
<li>生产者失败重试导致的消息重复</li>
<li>消费者未提交offset导致的消息重复
<ul>
<li>消息处理完成，消费者突然挂了，未能成功提交offset</li>
<li>消息正在处理，partition发生了重平衡</li>
</ul>
</li>
<li>上游业务发送了重复的消息</li>
</ul>
</li>
<li>解决办法
<ul>
<li>对于第一种情况，启用kafka幂等配置，重试不会导致消息重复</li>
<li>对于后两种情况，需要在业务层面实现接口的幂等性</li>
</ul>
</li>
</ul>
<h2 id="docker和k8s">docker和k8s</h2>
<ul>
<li>docker是一种容器技术，容器是一种轻量的虚拟化技术，其最大的好处是能让程序在不同平台上有一致的执行环境。</li>
<li>docker可以用来创建一个容器。容器是根据配置文件将程序依赖的库等各种环境打包在一起，形成一个独立的运行环境。</li>
<li>docker基于 Linux 内核的 cgroup，namespace，以及 Union FS 技术实现了容器之间的隔离</li>
<li>docker的三个概念，镜像、容器、仓库
<ul>
<li>镜像是基于UnionFS实现的个特殊的文件系统，里面包含了程序所需要的所有环境。</li>
<li>容器是镜像运行的实体（这个有点像进程和程序的关系），容器的本质就是进程，他有自己的namespace，只能访问自己的命名空间里的文件，靠这个实现了文件系统之间的隔离</li>
<li>仓库是一个用来分发镜像的系统。</li>
</ul>
</li>
<li>k8s
<ul>
<li>容器编排服务</li>
<li>通常称作k8s集群，主要是管理容器生命周期，对服务做扩缩容</li>
</ul>
</li>
</ul>
<h2 id="系统设计">系统设计</h2>
<h3 id="高并发高性能高可用">高并发、高性能、高可用</h3>
<ul>
<li>数据库一主多从，读写分离
<ul>
<li>降低单台数据库负载</li>
<li>避免写请求阻塞</li>
</ul>
</li>
<li>提高系统稳定性（高可用）
<ul>
<li>冗余（分布式部署，做集群，读写分离）</li>
<li>超时+重试</li>
<li>异步</li>
<li>缓存</li>
<li>限流</li>
<li>降级/熔断</li>
</ul>
</li>
<li>qps，每秒请求数</li>
<li>并发和qps换算
<ul>
<li>qps&gt;1s时，并发数 = qps*平均响应时间</li>
<li>qps&lt;1s时，并发数 = qps/平均响应时间</li>
</ul>
</li>
</ul>
<h3 id="restful-api">restful api</h3>
<ul>
<li>把接口视为资源</li>
<li>用HTTP方法表示操作，GET、POST、PUT、DELETE，读取、新增、修改、删除</li>
<li>用URL表示资源，而不是通过参数表示资源</li>
<li>接口命名（命名中只包含资源，不能包含操作）</li>
</ul>
<h3 id="设计模式">设计模式</h3>
<ul>
<li>单例模式，静态全局变量，私有构造函数，静态方法获取全局变量
<ul>
<li>懒汉式，获取时初始化单例（存在线程安全问题）</li>
<li>饿汉式，直接初始化单例</li>
</ul>
</li>
<li>工厂模式
<ul>
<li>简单工厂，根据参数返回特性对象</li>
<li>抽象工厂，根据参数返回特定工厂</li>
</ul>
</li>
<li>模板模式</li>
</ul>
<h3 id="如何实现接口的幂等性">如何实现接口的幂等性</h3>
<ul>
<li>接口的幂等性是指多次请求同一个资源和只请求一次产生同样的效果</li>
<li>接口需要满足幂等的原因是很多操作我们只希望发生一次，比如付款、创建订单等等</li>
<li>读操作天然具备幂等性</li>
<li>如何实现写幂等性
<ul>
<li>插入和删除
<ul>
<li>在数据库层面，使用唯一key标识一个资源，避免重复插入同一个key</li>
</ul>
</li>
<li>更新
<ul>
<li>为每个资源记录一个状态，根据状态判断是否能执行操作</li>
<li>使用乐观锁或者悲观锁防止操作时出现的幻读问题</li>
</ul>
</li>
<li>高并发下可以使用分布式锁防止请求直接落到数据库上</li>
</ul>
</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2025-07-05&nbsp;<a class="git-hash" href="https://github.com/openjz/asteria/commit/105c13dbdee67ce52df42658df5bcc76019bcfd1" target="_blank" title="commit by shiwj(swj6086085@163.com) 105c13dbdee67ce52df42658df5bcc76019bcfd1: add post 16.z1">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>105c13d</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/16.z1.interview-bagu-general/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/16.interview-bagu-golang/" class="prev" rel="prev" title="面试八股-golang"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>面试八股-golang</a>
            <a href="/17.html-mdn-tutorial/" class="next" rel="next" title="html入门笔记">html入门笔记<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/openjz" target="_blank">shiwj</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp">津ICP备2020010292号-1</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
