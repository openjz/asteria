# golang入门笔记


参考《Go程序设计语言》

看本文前最好先看google的[a tour of go](https://golang.google.cn/tour/welcome/1)

## 一、程序结构

1. go程序使用驼峰式命名风格
2. 零值，变量的初始值。数字是0，字符串是""，布尔值是false，接口（interface）和引用类型（slice、指针、map、通道、函数）是nil，数组和结构体的零值是其所有元素或成员的零值
3. 短变量声明，`a,b := f()`，a和b中至少有一个得是新变量，不能全是已经声明的变量
    - 一个例外，如果a,b是在外层作用域声明的，`:=`会将它们声明为新变量
4. 指针。函数返回局部变量的地址是安全的（见 6.变量的生命周期）
5. new函数，new函数创建一个新值并返回其地址
6. 变量的生命周期通过其是否可达确定（变量可以在其初次声明的作用域之外存活），**编译器根据变量生命周期确定变量在栈上还是堆上分配，而不是根据声明变量的时候使用的是var还是new**
7. 多重赋值，例如`a,b := 1,"xxx"`或`x,y = y,x`，后者用来交换变量的值
8. 类型转换，`var a T = T(b)`，每个类型都会提供`T(x)`将x的值转换为T（前提是允许这种转换）
9. 导出的标识符才能在包外被访问到，导出的标识符以大写字母开头
10. 包变量初始化，从初始化包级别变量开始，优先按照依赖顺序初始化变量，然后按照声明顺序初始化变量
11. init函数，可以有任意个，在程序启动时按照声明顺序自动执行
12. 包的初始化按导入顺序进行，依赖顺序优先（类似包级别变量初始化）

## 二、基本数据

### 2.1 整型

1. int8、int16、int32、int64、uint8、uint16、uint32、uint64
2. int和uint，在不同平台上大小不同（通常是32位或64位）
3. rune，等价于int32，表示一个unicode码点
4. byte，等价于uint8，表示一个原始的字节
5. uintptr，可以存放一个指针，用于底层编程
6. golang中%运算结果的正负号总是和被除数一致（取余，不是取模）
7. 位运算。`&`是与运算（AND），`|`是或运算（OR），`^`是异或运算和非运算（XOR，NOT），`&^`是与非运算（AND NOT），`<<`是左移，`>>`是右移
    - 1和a做异或等价于对a取反，即1^a = ^a（这里的1和a是单独的一位）
    - 与非运算的作用是按右操作数的位分布清空左操作数中的对应位
    - 右移操作`>>`
        - 有符号数左移是逻辑移位，符号位参与移位，低位补0
        - 有符号数右移是算术移位按符号位填补空位（因为移的是补码，补码补1就等于原码补0）
        - 无符号数都是逻辑移位
        - 右移操作`x>>n`等价于`x/2^n`，向下取整（朝负无穷方向取整，例如-5>>1结果为-3）

### 2.2 浮点型

1. 两种浮点型，float32和float64
2. math包给出了浮点型的极限值，例如`math.MaxFloat32` 
3. 特殊值：正无穷、负无穷、无意义（+Inf、-Inf、NaN）。超出极限值的数和除以零的商归为正负无穷，0/0或sqrt(-1)为无意义

### 2.3 复数

1. 两种复数，complex64，complex128
2. 写法：`3.14i`、`1+2i`
3. 可以使用`==`和`!=`判断是否等值

### 2.4 布尔

1. 逻辑运算的短路行为，如果运算符左边的操作数能直接确定最终结果，则右边的操作数不会计算在内
2. `&&`比`||`优先级高，助记技巧：`&&`是逻辑乘法，`||`是逻辑加法

### 2.5 字符串

1. len函数返回的是字节数，不是字符数
2. 生成子串操作`s[i:j]`取的是字节，不是字符。
3. 下标访问操作`s[i]`访问的也是第i个字节，不是字符
4. range循环`i,r := range "xxx"`中的i表示字节序号，r是字符（rune）
5. 字符串可以通过`==`或`<`比较，**比较运算按字节进行**，结果服从其字典序排序
6. **字符串值无法改变**（字符串值所包含的字节序列永不可变），只能将一个新字符串赋值给字符串变量（例如，`s+="xxx"`只是将`+=`运算新生成的字符串赋值给了s，并没有改变s原有的字符串值）。这么设计的好处是：
    - 两个字符串变量能够安全地共用同一段底层内存
    - 字符串拷贝的开销小
7. 字符串字面量
    - 转义。除了常见的`'\n'`等转义字符以外，`'\xhh'`用16进制数`hh`表示这个字节，`'\ooo'`用八进制数`ooo`表示这个字节，这两者都表示单字节
    - 原生字符串字面量用反引号`` `...` ``书写。原生字符串中转义不起作用，可以包含换行，字符串内容和书写内容完全一致。
8. utf-8
    - utf-8是go的默认编码
    - unicode字符有两种表示形式，`\uhhhh`表示16位码点，`\Uhhhhhhhh`表示32位码点，区别是小写的u和大写的U
    - 以下字符串是等价的，注意：直接用16进制转义（\x）书写的字符串是"世界"经utf-8编码后的实际字节，而\u和\U后面跟的是unicode码点，并不是实际的utf-8字节
        ```go
        "世界"
        "\xe4\xb8\x96\xe7\x95\x8c"
        "\u4e16\u754c"
        "\U00004e16\U0000754c"
        ```
    - utf-8编码规则（只有"xxx"部分才是unicode码点信息）
        ```
        0xxxxxxx
        110xxxxx 10xxxxxx
        1110xxxx 10xxxxxx 10xxxxxx
        11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        ```
    - 使用函数`utf8.RuneCountInString(s)`计算字符串中的字符数量
    - utf-8解码器在遇到一个不合理的字节时，会用一个专门的unicode符号`\uFFFD`作为替换
9. byte和rune的区别，rune保存的是unicode码点，并不是utf-8编码后的字节，因此，字符串转换为`[]rune`之后，使用`fmt.Printf("%x",s)`输出的结果并不一样
10. `string`、`[]byte`、`[]rune`之间可以相互转换，`byte`、`rune`可以转换为string
11. 字面量`'A'`是rune类型
12. 四个标准包：strings、bytes、strconv、unicode
    - strings包提供了字符串操作函数
    - bytes包提供了字节slice操作函数、可变字符串类型bytes.Buffer
    - strconv包主要用于string和其他类型的转换
    - unicode包用于判别文字符号值

### 2.6 常量

1. 常量是在编译阶段确定值的数据类型，因此常量可以出现在涉及到类型声明的地方（例如数组长度）
2. 常量生成器iota，用于创建一系列连续的常量值，从0开始取值，逐项加1。iota可以用在表达式里。
3. 无类型常量，无类型常量可以有比基本类型更高的精度，至少256位（可以超过基本类型的最值）

## 三、复合数据类型

数组、slice、map、结构体

### 3.1 数组

1. `var a [3]int = [3]int{1,2,3}`，也可以`a := [...]int{1,2,3}`
2. 使用`len(a)`获取数组长度
3. 初始化时可以同时指定索引，例如`a := [...]string{2:"hello",3:"world"}`
4. 如果数组元素类型可比较，则数组也是可比较的，只能用`==`和`!=`
5. 传数组参数时不是传引用，而是值传递，拷贝一份副本
6. 数组长度不可变

### 3.2 slice

1. slice是一种可变长度的序列。slice是一种轻量的数据结构，底层是个数组。
2. slice有三个属性，指针、长度和容量，长度是指slice的元素个数，长度小于等于容量。容量是从起始元素到底层数组的最后一个元素见元素的个数。使用`len`和`cap`获取长度和容量。
3. 一个底层数组可以对应多个slice，slice的范围可以相互重叠。
4. slice之间无法比较，可以用bytes.Equal比较两个字节slice
5. slice值为nil时，长度和容量都为0，也有不为nil但是长度和容量都是0的slice，例如`[]int{}`、`make([]int,3)[3:]`
6. `make([]T,len)`、`make([]T,len,cap)`
7. append可以用来追加元素。append可能会引起底层数据扩容，也可能不会，因此每次调用append都必须更新slice。
8. 小知识，`func(y ...int)`，`...`代表y接受一个可变长度的参数列表

### 3.3 map

1. `a := map[string]int{"hello":1,"world":5,}`
2. 创建空map：`make(map[K]V)`、`map[K]V{}`
3. 通过下标的方式插入和访问，使用delete移除元素。即使key不存在，这些操作也是安全的，访问一个不存在的键时，其值为零值。
4. map中元素的迭代顺序不固定
5. 小知识，使用range迭代时可以使用空白标识符`_`忽略一个变量
6. 判断一个key是否存在，`age,ok := a[xxx]`
7. key的类型必须是能用`==`比较的类型，所以key不能是slice
    - 可以通过将slice映射成一个字符串来解决，例如`fmt.Sprintf("%q",[]int{1,2,3})`，谓词q是将一个值转换为对应的字符串形式的字面值
