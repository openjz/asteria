# 事业编计算机知识


## 考点

3. 组成原理
4. windows
5. office
6. 网络
7. 操作系统
8. 数据库
9. 软件工程
10. 编程语言(c、java)
11. 数据结构
12. 基础算法
13. 安全

## 简答题

### 1. 软件可维护性

**决定因素**：可理解性、可测试性、可修改性、可移植性、可重用性

**提高方法**：

1. 使用先进的软件开发工具（版本管理，测试工具，调试工具）
2. 明确软件的质量目标和优先级
3. 进行质量保证审查
4. 选择可维护的程序设计语言
5. 详细的设计文档、结构文档、代码文档、维护文档、接口文档（改善可理解性）
6. 良好的软件设计（模块化、高内聚、低耦合、可测试）

### 2. 网络接入方法

1.  拨号接入
    1. 普通电话线（普通 MODEM）拨号接入
    2. ISDN 线路拨号接入
    3. 宽带 ADSL 拨号接入
2.  专线接入
    1. Cable-MODEM（线缆调制解调器）是利用现成的有线电视（CATV）网接入
    2. 光纤接入
3.  局域网接入
4.  无线接入
5.  电力宽带上网

### 3. 网络攻击

网络攻击：DOS/DDOS 攻击、SQL 注入、XSS 攻击（JS 注入）、会话劫持、DNS 劫持、暴力破解密码、电子邮件攻击、恶意软件/病毒/木马攻击

防范网络攻击：系统升级，安全补丁，强密码，防火墙，杀毒软件，扫描下载程序，不点击可疑邮件

### 4. B/S 架构

浏览器/服务器架构：略

好处：容易运维，使用方便

存在的问题：数据安全问题，处理负载问题，耗时问题，灵活性问题

### 5. IPv6 技术介绍

IPv6 的全称是 Internet Protocol Version 6，译为“互联网协议版本 6”，是 IETF（互联网工程任务组）设计的用于替代现行 IP 协议（IPv4）的下一代 IP 协议

为何要提出 IPv6 技术（和 IPv4 相比的优势，解决了什么问题）:

1. IPv4 地址长度 32 位，IPv6 地址长度 128 位。解决了 IPv4 地址空间不足的问题，可以做到为每台设备分配一个唯一的 IP 地址。
2. IPv6 的路由表更小，提高了路由器转发数据包的速度
3. IPv6 更安全，IPv6 可以在网络层对数据加密和校验，在网络层就可以保证数据传输的安全性和完整性。
4. IPv6 允许对协议进行扩充
5. IPv6 增强了对组播的支持和对流的控制，对提升多媒体服务的质量有很大好处
6. IPv6 加入了对自动配置的支持（是对 DHCP 协议的改进和扩充），提高网络管理效率，降低网络管理成本

### 6. 计算机网络类别和特点

按覆盖范围分类，分为：WAN（广域网，覆盖范围几十到几千公里，是因特网的核心），MAN（城域网），LAN，PAN（覆盖范围只有几米），CAN，SAN 等

按使用对象分类，分为：公网，私网

### 7. 如何在计算机网络中实现资源共享

要点

- 条件，路由，交换机，DHCP 等等
- 局域网
  - 将某一台计算机的目录设置为局域网共享，获奖这台计算机连接的打印机设置为共享
  - 将网络打印机，网络硬盘组等设备作为独立的设备接入局域网，实现资源共享
  - 远程登陆
- 公网
  - 去中心化的对等网络 p2p
  - 中心化的资源共享服务，http 服务，ftp 服务等

### 8. 计算机软件系统的分类和功能

要点

- 分为系统软件和应用软件
  - 系统软件包括操作系统、语言处理系统（编译系统）、数据库管理系统
  - 应用软件是为了解决实际问题，面向某个具体的领域而设计的软件。应用软件分为通用软件和专用软件
    - 电子邮件、web 浏览器、办公软件、图像处理、音视频处理、科学计算软件，工业控制软件

### 9.简述 OSI 七层模型

- 物理层：建立、维护、断开物理连接，二进制数据的实际传输，有相关物理协议
- 数据链路层：逻辑连接，主机间通信、硬件地址寻址，数据差错校验，局域网通信协议，PPPoE、CSMA/CD
- 网络层：主机利用网络地址通信，以网络地址为标识（例如 IP 地址），网络地址寻址、路由、转发，维护路由表，有相关网络协议、IPv4、IPv6
- 传输层：进程级别的通信，连接，以“主机:端口号”（套接字）作为标识，有 TCP/UDP 协议
- 会话层：创建、管理、终止会话
- 表示层：数据格式化、加密、压缩
- 应用层：负责网络应用级别的通信，HTTP、HTTPS、SSH、FTP

### 10.星型网络优缺点

优点：

1. 结构简单、容易实现和维护
2. 节点易扩展
3. 可靠性高，坏一个节点不会导致全网瘫痪
4. 易扩展
5. 传输速度快

缺点：

1. 中央节点负载高，易成为瓶颈
2. 中心节点故障，整个网络故障
3. 线路利用率低

### 11.中间件

中间件（middleware），分布式系统基础软件，位于应用服务/软件和系统服务（操作系统、数据库）之间，主要解决分布式环境下数据传输、数据访问、应用调度、系统构建和系统集成、流程管理等问题，能够实现系统之间的互联互通，提高系统资源利用率

中间件可分为

- 基础中间件，交易中间件、消息中间件等，用于节点间、应用与服务之间互联互通。基础中间件是构建分布式应用的基础。
- 集成中间件，用于异构系统（不同的数据库系统、业务应用系统等）之间的互联互通、数据共享、业务流程协调统一等功能，并构建灵活可扩展的分布式企业应用
- 行业领域应用平台，为满足特定行业、企业需要，便于快速方便地构建应用，而在原有基础中间件、集成中间件的基础上开发的中间件。所提供的服务与特定行业相关

中间件有：

- 分布式存储、分布式计算
- 消息中间件
- 网络代理（负载均衡、数据接入、访问控制、数据转发和路由、安全认证）
- cdn
- 缓存
- 容器编排

### 12.数据库优化

数据库方面

- 建集群，多台机器多台服务同时 I/O
- 开启查询缓存

表优化

- 选择更好的存储引擎
- 对经常在条件、分组子句中出现的列建索引
- 按照数据范式优化表设计，合理拆分表，降低冗余
- 分区
- 分库分表（横向/纵向）
- 优化字段设计，尽量使用简单/小的数据类型，整形优于字符串，尽量使用定长类型，索引字段越小越好

SQL 语句优化

- 使用连接查询代替子查询
- 限制查询字段
- 限制查询条数
- 限制使用子查询、联表查询
- 尽量减少字符串匹配，尤其是正则表达式匹配和 like 匹配
- 配合慢查询日志优化

### 13. 什么是事务及事务的特性

事务是用户定义的一个操作序列，具有原子性，要么都完成，要么都不完成。事务可以是一条 SQL 语句，也可以是一组 SQL 语句

事务的 ACID 特性：原子性、一致性、隔离性、持久性

- 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。

### 14. 什么是视图

视图是一种虚拟的表，它只有表定义，而不包含具体的数据。

在 SQL 中，视图是基于 SQL 语句的结果集的可视化表，实际上是一条 select 语句，这个语句返回的结果集被视为一个表。

视图中的数据并不属于视图本身，而是属于基本的表。用户对视图进行操作时，系统根据视图的定义去操作与视图相关联的基本表

### 15. 分布式 CAP 定理

一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。

- 一致性：分布式系统中同一个数据的所有副本，在同一时刻完全相同
- 可用性：分布式系统对外提供的服务一直可用，即使某些节点发生了故障
- 分区容错性：（一个更好的翻译是分区容忍性）当分布式系统出现分区故障的时候，仍能对外提供服务
  - 分区：在分布式系统中，某些节点之间出现了网络不通的状态，导致整个系统被切分成若干个孤立的网络，而这些网络内部通信是正常的，这就是分区。

对于分布式系统来说，分区是无法避免的问题，分布式系统必须能够满足分区容错性，因此，分布式系统需要在一致性和可用性之间二选一

- 强一致性：对同一个数据的访问在任何时候都是一致的
- 弱一致性：只能尽量达到对数据的访问是一致的，不保证完全一致
- 最终一致性：保证能在一段时间以后，同一个数据能达到完全一致

### 16. 软件可行性分析的目的是什么

可行性分析的目的是用最小的代价在尽可能短的时间内确定该项目是否能够开发，是否值得开发，其本质是要进行一次简化的、压缩的需求分析和设计过程，要在较高层次上以较抽象的方式进行需求分析和设计

## 组成原理

多媒体信息：文本，图片，音频，视频，动画...

计算机内部通常是并行传输，通信线路上通常是串行传输

### 编码

码距：两个码不同的二进制位数

### RAID

- **raid0**：假设有 disk1、disk2、disk3、disk4 四块硬盘，数据被分为四份分别放在四块硬盘上
  - 优点：硬盘空间利用率高、处理大文件速度快
  - 缺点：一块硬盘损坏，所有数据均不可用
- **raid1**：至少要有两块硬盘，一块硬盘存储，一块硬盘做备份
  - 优点：提供数据冗余
  - 缺点：可使用容量减半
- raid2：在 raid0 基础上加入汉明码纠错
- raid3：在 raid0 基础上增加一块硬盘专门做奇偶校验
- raid4：不常见，略
- **raid5**：和 raid0 类似，一个数据分为多份，分别存储到不同的硬盘上去，但会有另外一块硬盘专门存放这个数据的校验码，各个数据的存储是独立的，所有硬盘都可以作为存储盘和校验盘
  - 优点：兼顾存储性能、数据安全、存储成本
  - 缺点：有两块或两块以上硬盘损坏，数据就无法恢复、数据重建慢
- raid6：在 raid5 的基础上加入双重校验
- raid10/raid01：raid1 和 raid0 的结合
- **raid7**：最优化的异步高 I/O 速率和高数据传输率，RAID7 不仅仅是一种技术，还是一种存储计算机，可完全独立于主机运行，不占用主机 CPU 资源

### 图灵和冯诺依曼

图灵，计算机科学之父，人工智能之父，计算机科学的奠基人

冯·诺依曼，现代计算机之父，博弈论之父，提出冯诺依曼结构

### 字符编码方案

输入码是指输入字符时的编码，例如五笔码、全拼码等

交换码是指逻辑上的编码标准，例如 unicode 就是一种交换码

内码是指字符在计算机内部实际的编码方案，例如 utf-8 就是一种内码

### 接口

- SCSI  
  并行接口，支持热插拔
- IEEE 1394  
  串行接口，传输速度快。最早由苹果公司为了取代 SCSI 提出。USB 和 IEEE 1394 是现今比较流行的两种外部总线标准
- rs232：两排，共 9 针（一排 4 针，一排 5 针），全双工，距离短，速度慢
- rs485：无固定接口，半双工，距离长，速度快
- DVI 接口：三排 15 针

### 周期

- 指令周期：计算机执行一条指令需要的时间
- CPU 周期/机器周期：一条指令的执行分为若干阶段，每个阶段的执行周期称为 CPU 周期或机器周期。（通常用一次方访存时间来衡量）
- 时钟周期：振荡周期，一个时钟滴答

### 内存-缓存映射

- 直接映射：一个内存块映射到固定的缓存块
- 半相联映射：一组内存块映射到固定的缓存块，块内部是任意映射
- 全相联映射：任意一个内存块映射到任意一个缓存块

### 总线

PCI 总线

- 以桥连接实现的 PCI 总线允许多条总线并行工作
- 系统中允许有多条 PCI 总线
- 基本传输机制是猝发式传输
- 同步时序协议和集中式仲裁策略

## windows 系统

windows 通配符：“\*”用于匹配多个字符，“?”用于匹配单个字符

windows 中不能作为文件名的是：/\<>?\*

fat 分区最大 2TB，最大文件 4GB

### windows 快捷键

1. win7 开机时进入安全模式按 f8
2. 切换语言，shift+alt
3. 切换输入法，shift+ctrl
4. 切换输入法的语言，shift 或 ctrl+空格
5. 全半角状态转换，shift+空格
6. 打开开始菜单，ctrl+esc 或 win

## 数据库

### 数据库的特征

0. 持久存储（不属于基本特点，选择题不选）
1. 数据结构化，有组织，按一定数据模型组织、描述和存储（数据冗余度低）
2. 数据可共享
3. 数据独立性高，易扩展。数据独立性分为逻辑独立性和物理独立性

### 数据库管理系统（DBMS）

位于操作系统之上，管理数据库，提供数据定义、数据操纵、数据控制、数据查询四种功能，并对应有以下语言供用户使用

- DDL，数据定义语言（建库、建表等）
- DML，数据操纵语言（增、删、改）
- DCL，数据控制语言
- DQL，数据查询语言

此外还负责网络通信，保障数据安全性和完整性，事务控制，并发控制等

### 数据库系统结构

三级模式：外模式、模式和内模式

二级映射：外模式-模式映射、模式-内模式映射

**外模式，又称子模式或用户模式**，对应用户级，用户使用外模式描述语言来定义用户的数据记录，或者使用 DML 对数据记录做描述。

**模式，又称概念模式或逻辑模式**，对应于概念级，是所有用户的公共数据视图，使用 DDL 来描述。

**内模式，又称存储模式**，对应于物理级，描述了数据在存储介质上的物理结构。

### 数据模型

**数据模型分为概念数据模型、逻辑数据模型、物理数据模型**

**概念数据模型**是从用户视角描述数据，反映客观世界的联系和规则

E-R 图（实体-联系图）是一种概念模型，用实体、属性和联系来描述客观世界，联系也称关系，分为一对一、一对多、多对多。实体用矩形表示，属性用椭圆形表示，关系用菱形表示。

**逻辑数据模型**由数据结构、数据操作和完整性约束构成

数据库支持的逻辑数据模型有层次模型、网状模型、关系模型和面向对象模型。

### 关系型数据库

关系数据模型，是一种用二维表结构来表示实体和实体间关系的模型

### 关系规范化理论

关系规范化理论是一种用来指导如何设计关系型数据库的理论，规范化用形式更简洁、结构更规范的关系模式取代原有关系模式，其目的是为了解决不合理的关系模式设计导致的数据冗余、操作异常（增删改异常）等问题。

完整的关系模式是一个五元组 R(U,D,Dom,F)，R 是关系，U 是属性集，D 是属性的域，Dom 是属性到域的映射，F 为属性的数据依赖集

关系模型可以简化为一个三元组 R(U,F)

数据依赖是关系模式的重点，包括函数依赖、多值依赖和连接依赖

**函数依赖**

对于 R(U)，设 X 和 Y 是 U 的两个子集，如果对任意一个 X，有唯一的 Y 与之对应，则这个依赖是函数依赖，称为“X 函数确定 Y”或“Y 函数依赖 X”，记为`X->Y`，X 为决定因素，Y 为依赖因素。例如，确定了学号，就能确定姓名、性别等。

函数依赖有三种情形

1. 平凡函数依赖和非平凡函数依赖  
   如果 Y 是 X 的子集，Y 对 X 就是平凡函数依赖，否则是非平凡函数依赖。
2. 完全函数依赖和部分函数依赖  
   如果 X 的任何一个真子集都不能决定 Y，Y 对 X 就是完全函数依赖，否则是部分函数依赖。
3. 传递函数依赖  
   如果 X->Y，Y->Z，且不存在 Y->X，那么 Z 对 X 传递依赖。

**码/键**

- 码/键  
  表中的一个或几个属性，用来标识该表的每一行或与另一个表产生联系
- 超码/超键  
  去掉一个属性，还是码
- 候选码/候选键  
  最小的码（属性集完全函数依赖于该码）
- 主码/主键  
  从候选码中选一个
- 主属性  
  候选码中的属性是主属性

**规范化**

不同的规范化程度可用范式来衡量。目前有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、BC 范式（BCNF）、第四范式（4NF）和第五范式（5NF）。

- 第一范式，关系 R 的每个属性都不可分解，都是原子的
- 第二范式，关系 R 满足第一范式，且所有非主属性都完全函数依赖于任意候选码
- 第三范式，关系 R 满足第二范式，所有非主属性都不传递函数依赖于任何候选码
- BCNF 范式，基于满足第一范式的基础之上，是对第三范式的改进

> BCNF 范式，关系 R 满足第一范式，对任何非平凡依赖 X->Y（Y!->X），X 都包含码，这意味着  
>  （1）所有非主属性都完全函数依赖于每个候选码
> （2）所有主属性都完全函数依赖于每个不包含它的候选码
> （3）没有任何属性完全函数依赖于非码的任何一组属性

数据库设计普遍采用的是基于 3NF 的设计方法

### 事务

事务是用户定义的一个操作系列，具有原子性，要么都完成，要么都不完成。事务可以是一条 SQL 语句，也可以是一组 SQL 语句

事务的 ACID 特性：原子性、一致性、隔离性、持久性

## 网络

计算机网络要求误码率低于 10^-6，如果达不到这个指标，就必须进行差错校验

按网络覆盖范围分类

- WAN（wide area network），广域网
- MAN（metropolitan area network），城域网
- LAN（local area network），局域网，是一种点对点结构的网络
- WLAN（wireless local area network），无线局域网
- PAN（personal area network），个人区域网络（蓝牙、USB 等）
- CAN（campus area network），校园区域网络
- SAN（storage area network），存储区域网络

### 服务访问点 SAP

服务访问点 SAP 是指上下两层协议实体之间的逻辑接口（某一层的 SAP 是其对上层的访问接口），例如网络层的 SAP 是 IP 地址

### 物理层

物理层设备：

- 光纤，光纤只能单向传输，光纤抗干扰和传输距离都比同轴电缆强
- 中继器，集线器
- 双绞线
  - 既可以传输模拟信号，又可以传输数字信号
  - 不仅适用点到点连接，也适用多点连接

计算机中的传输设备包括：双绞线、同轴电缆、光纤、无线传输介质（无线电波、微波、红外线、激光）

物理协议

- 电气特性：电压范围
- 功能特性：电平代表的含义
- 规程特性：事件顺序
- 机械特性：接口外形、形状、大小、引脚数

### 数据链路层

数据链路层设备：

- 网桥
- 交换机
- 网卡，网卡工作在物理层和数据链路层的 MAC 子层

数据链路层有两个子层，逻辑链路控制层（LLC）和介质访问控制层（MAC），LLC 层位于 MAC 层之上。

CSMA/CD 协议，发送数据前先侦听总线的忙/闲状态，发送数据的同时要进行冲突检测

以太网拓扑结构有很多种，主要是**总线型**，加入交换机后，变为**星型**拓扑。其他结构还有：

- 环型
- 树型
- 网状型

### 交换机和集线器的区别

集线器工作在物理层，不涉及网络协议层面的工作，只能以广播模式转发数据

交换机工作在数据链路层，可以根据报文中的 MAC 地址对数据做针对性的转发

### 网络层

**虚电路和数据报**

虚电路和数据报是分组交换的两种方式（分组就是包，是网络层的概念），目前因特网用的就是数据报方式。

数据报方式为网络层提供无连接服务，每个分组都包含源地址和目的地址，每个分组独立路由和转发，不保证分组按顺序到达，不保证可靠传输。

虚电路方式为网络层提供面向连接的服务，建立连接后分组只包含一个虚电路号作为标识，同一条虚电路的分组按同一条路由转发，保证分组的有序到达，保证可靠传输。

### Internet、Intranet 和 Extranet

Internet 是英特网，Intranet 是企业内部网，Extranet 是外联网

### 安全

文件型病毒主要感染 com 和 exe 文件

## 操作系统

操作系统的发展：单道批处理系统，多道批处理系统，分时系统，实时系统，通用操作系统

### 死锁

死锁是指多个进程并发执行时因争夺资源造成的互相等待现象。

死锁发生有四个必要条件

1. 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到进程使用完成后释放该资源；
2. 请求保持条件：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，而且该进程不会释放自己已经占有的资源；
3. 不可剥夺条件：进程已获得的资源，只能自己释放，不可剥夺；
4. 环路等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

如何解决：

1. 把独占资源变为共享资源
2. 资源一次性分配，从而解决请求保持的问题
3. 资源可剥夺，当进程新的资源未得到满足时，释放已有的资源；
4. 资源有序分配，对所有资源编号，进程请求资源时按资源递增顺序请求，释放则相反，破坏了环路等待条件。
5. 一个著名死锁避免算法，银行家算法

## 软件工程

项目管理三角形：范围、时间、成本

### 软件生命周期

1. 软件计划、问题定义及可行性分析

- 可行性分析的目的是用最小的代价在尽可能短的时间内确定该项目是否能够开发，是否值得开发，其本质是要进行一次简化的、压缩的需求分析和设计过程，要在较高层次上以较抽象的方式进行需求分析和设计

2. 需求分析
3. 总体设计
4. 详细设计
5. 软件编码及测试
6. 软件运行与维护

**软件生命周期模型**

瀑布模型

- 各阶段具有顺序性和依赖性
- 每个阶段都必须完成规定的文档，并对文档进行评审，合格后才能进入下一个阶段

快速原型模型

- 需求分析阶段只进行初步的需求分析
- 快速设计开发出原型供用户测试评定，根据改进意见丰富细化软件，直至用户满意，最后再完整地实现软件

增量模型

- 每次发布一个增量，第一个增量是核心产品，用户对每个增量的反馈将成为下一个增量的新特性
- 将瀑布模型中的流程反复迭代

螺旋模型

- 项目流程：制定计划、风险分析、实施工程、客户评估，这个过程反复迭代
- 由风险驱动

### 软件开发方法

- 结构化开发方法  
  结构化开发方法(Structured Developing Method)是现有的软件开发方法中最成熟，应用最广泛的方法。结构化开发方法由结构化分析方法(SA 方法)、结构化设计方法(SD 方法)及结构化程序设计方法(SP 方法)构成。
  - 结构化分析方法（Structured Analysis，**SA**），是面向数据流的需求分析方法。
    - **数据流图**(Data Flow Diagram，**DFD**)是描述系统中数据流程的图形工具。数据流图的绘制分三步走：
      1. **确定系统的输入输出**；
      2. 由外向里画系统的顶层数据流图；
      3. 自顶向下逐层分解，绘出分层数据流图。
    - 数据流图分为两种典型结构，变换型结构和事务型结构。
      - 变换型结构由三部分组成：输入、数据加工(中心变换)和输出。
      - 事务型结构由三层组成：事务层、操作层和细节层
    - 结构化分析工具：
      - 结构化语言，三种结构，顺序、循环、判定。简单的控制流（顺序执行和循环执行的动作）用结构化语言描述。存在多个条件复杂组合的判断问题，用判定树和判定表描述
      - 判定树，又称决策树，易读
      - 判定表，严格，可以先用判定表做底稿，在此基础上产生判定树
- 面向对象方法
  - 基本概念：类、对象、实例、消息（一个函数调用）、方法...
  - 面向对象建模得到的模型包含系统的 3 个要素：静态结构（对象模型）、交互次序（动态模型）和数据变换（功能模型）。
    - 对象模型：描述数据结构（UML 图）
    - 动态模型：描述交互和次序（状态图）
    - 功能模型：功能模型作用在对象模型说明的数据上，同时还表示了对对象值的约束
  - 对象的特点：标识唯一性、分类性/抽象性、多态性、封装性
  - 面向对象的特点：封装、继承、多态
- Jackson 方法
  - Jackson 方法是一种面向数据结构的开发方法。
  - JSP(JacksonStructure Programming）方法以数据结构为驱动，适合小规模项目。JSP 方法首先描述问题的输入/输出数据结构，分析其对应性，然后推出相应的**程序结构**，从而给出问题的软件过程描述。
  - JSD 方法是 JSP 方法的扩展，是一个完整的系统开发方法。首先建立现实世界的模型，再确定系统的功能需求，对需求的描述特别强调操作之间的时序性。它是以事件作为驱动的，是一种基于进程的开发方法，所以适用于时序特别较强的系统，包括数据处理系统和一些实时控制系统。
  - Jackson 图，描述数据元素彼此之间的逻辑关系，只有顺序、选择和重复三类。

### 需求分析

略

### 软件设计

模块化，高内聚低耦合

### 软件编码

表驱动法（Table-Driven Methods）是一种编程模式，从表里面查找信息而不使用逻辑语句（if 和 case） ，它的好处是消除代码里面到处出现的 if、else、swith 语句，让凌乱代码变得简明和清晰。逻辑越来越复杂，表驱动法就越有吸引力。

程序调试方法

- 简单调试，在程序中插入打印语句、运行程序、借助调试工具
- 归纳法，从特殊推断一般的方法，从线索出发，通过分析线索之间的关系找到问题
- 演绎法，从一般推特殊，设想可能的原因，用已有的数据排除不合理的假设
- 回溯法，确定发生错误的地方，沿着程序的控制流往回追溯

### 软件测试

测试阶段

- 单元测试：对最小最基本的软件设计模块进行验证，通常情况下是白盒的，主要针对程序设计、业务逻辑、代码风格进行测试，目的是尽早发现不易显现的错误
- 集成测试：将各模块按照程序结构图组合起来测试，目的是通过测试发现与模块接口有关的问题
  - 增量集成：逐步集成，分为自顶向下的集成和自底向上的集成，自顶向下是从主模块开始，按照深度优先或广度优先的策略集成，自底向上是从系统结构图的最底层模块开始集成
  - 非增量集成：一次将所有模块组合起来测试，一步到位
- 系统测试：基于系统整体需求的黑盒类测
- 回归测试：目的是判断代码修改有没有对软件已有功能引入新的问题
- 验收测试
  - alpha 测试：由用户在开发者的场所进行，内部测试，环境受控
  - beta 测试：由用户在用户场所进行，在开放环境测试，环境不受控，是软件发布前的最后测试

白盒测试，测试者完全了解程序的结构和处理过程，根据程序的内部逻辑设计测试用例，检查逻辑通路是否符合预期

- 逻辑覆盖测试的六个级别（发现错误的能力由弱到强）
  1. 语句覆盖，每条语句至少执行一次
  2. 判定覆盖（分支覆盖），覆盖每个判定分支
  3. 条件覆盖，覆盖判定条件的每个取值
  4. 判定/条件覆盖，同时满足判定覆盖和条件覆盖
  5. 条件组合覆盖，覆盖所有判定条件的所有取值组合
  6. 路径覆盖，覆盖每条可能的路径
- 控制结构测试
  1. 基本路径测试
  2. 条件测试
  3. 循环测试

黑盒测试，测试者不关心程序的内部结构，而是根据功能来设计测试用例，检查程序的功能是否符合要求

- 等价类划分法，将系统的输入域划分为若干部分，从每个部分选取少量代表性数据进行测试。可分为有效等价类和无效等价类。
- 边界值分析法，优先选择不同等价类的边界值进行测试，因此该方法要和等价类划分法结合使用。
- 正交实验设计法，从大量实验点中挑出适量有代表性的点进行测试
- 因果图法，通过因果图获得判定表
- 判定表驱动分析法，判定表可以把复杂的逻辑组合表达的非常明确
- 错误推测法；
- 异常分析法

### 软件质量

功能性、可靠性、可使用性、效率、可维护性、可移植性、重用性

### 软件可维护性

决定因素：可理解性、可测试性、可修改性、可移植性、可重用性

提高方法：

1. 使用先进的软件开发工具（版本管理，测试工具，调试工具）
2. 明确软件的质量目标和优先级
3. 进行质量保证审查
4. 选择可维护的程序设计语言
5. 详细的设计文档、结构文档、代码文档、维护文档、接口文档（改善可理解性）
6. 良好的软件设计（模块化、高内聚、低耦合、可测试）

## office

快捷键

- 保存、搜索（略）
- 打开文件：ctrl+o
- 新建文件：ctrl+n
- 打印：ctrl+p

退出操作

- 双击左上角
- 左/右键单击左上角，选关闭
- 右键单击标题栏中间，选关闭
- 单击右上角红叉
- 文件->关闭
- alt+f4

## word

1. 两种编辑方式，插入和改写（使用 insert 键调整）
2. 查找和替换，开始->编辑->替换，或者开始->编辑->查找->高级查找
3. 缩进方式，左缩进，右缩进，首行缩进，悬挂缩进
4. 标尺的作用，定位、对齐和缩进等。
   - 小三角用来调整缩进（左缩进，右缩进，首行缩进），小方块用来设置制表位的对齐方式。
   - 拖动标尺边界，可以设置页边距
5. 在快速选择区三击，可选择整篇文章

## excel

1. 一个 excel 文件最多有 255 个工作表
2. 工作簿是指大的 excel 文档，工作表是指里面的 sheet1、sheet2
3. 公式以等号开头
4. 每个单元格最多可以容纳约 32000 个字符

### 公式与函数

1. 单元格引用
   - 绝对引用和相对引用，列表或行标前面带`$`符时为绝对引用，不带时为相对引用
   - 引用一个单元格，A1
2. 引用运算符
   - 引用一个单元格区域，A1:B3
   - 引用多个单元格区域，(A1:B3,C1:D3)
   - 引用两个单元格的相交区域，(A1:B3 C1:D3)
3. 运算符优先级：- > % > ^ > (\*、/) > (+、-) > & > 比较

## powerpoint

播放快捷键：f5

### 模板

- 人们通常说的模板是指别人做好的 ppt 文件，我们拿到后可以在其基础上做修改
- ppt 提供了和模板相关的两种功能，**母版和主题**
  - 母版用来定义一些可复用的版式。（操作：视图->幻灯片母版）
  - 主题比母版高级，每个主题里面都包含一套母版，还另外做了统一的配色、字体、效果等。主题做好后会导出成 thmx 文件（操作：设计->主题）
- **官方提供的模板**，官方的模板是以 pot/potx 格式提供的，官方的模板可以直接在新建文件界面搜索和选择

## 程序设计

结构化程序三种基本结构：顺序、分支、循环，goto 语句属于无条件跳转语句，属于非结构化程序

## c 程序基本结构

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

#define mydef 0

struct mystruct {
  int a;
  char *b;
}

int main() {
  return 0;
}
// 标准输入输出
int a;
scanf("%d",&a);
printf("%d",a);
// 按行
char * in = char[100];
char * out = "123";
char * res = gets(in); //返回字符串或NULL
int res = puts(out); //返回长度或EOF
//按字符
int res = getchar(); //返回字符或EOF
int res = putchar(c);//返回字符或EOF

// 文件操作
// 打开关闭文件
FILE * f = fopen("/data/input","r") //r读，w写，a追加
int status = fclose(f)
// 读写字符
char * in = char[100];
char * out = "123";
char * res = fgets(in,10,f); //返回字符串或NULL
int res = fputs(out,); //返回长度或EOF
int res = fgetc(f);
int res = fputc(c,f);
// 读写块
char buffer[100];
char c[] = "This is w3schools";
int res = fread(buffer, strlen(c)+1,1,f) //参数：buffer，块大小，块个数，文件，返回读取长度
int res = fwrite(buffer, strlen(c)+1,1,f) //参数：buffer，块大小，块个数，文件，返回写入长度

//初始化结构体
struct mystruct mst = {1,NULL};
//数组
int a[5] = {2, 3, 4, 4, 7};
//指针
int *b = (int *)malloc(sizeof(int)*5);
b = (int *)realloc(b, sizeof(int)*10);
free(b)
//字符串/内存操作
char *s1 = "123";
char *s2 = "234";
char *res = strcat(s1,s2); //s2拼接到s1的末尾
char *res = strncat(s1,s2,n); //把s2的前n个字符拼接到s1的末尾
int res = strcmp(s1,s2);  //s1>s2，返回大于0，s1<s2，返回小于0，s1=s2，返回等于0，
int res = strncmp(s1,s2,n); //比较前n个字符
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
int memcmp(const void *str1, const void *str2, size_t n)
void *memcpy(void *dest, const void *src, size_t n)
void *memmove(void *dest, const void *src, size_t n)
void *memset(void *str, int c, size_t n)
// math，操作数都是double
b = exp(a)  //e^x
b = pow(x,y)  //x^y
b = sqrt(a) //平方根
b = log(a)  //自然对数，基数为e
b = log10(a)  //基数为10
b = fabs(a) //绝对值
b = ceil(a) //向上取整
b = floor(a)  //向下取整
b = sin/cos/tan(a)  //三角函数

```

## java 程序基本结构

```java

public class Hello{
  public static void main(String []args){
    System.out.println("Hello World");
  }
}

//import
import java.util.Scanner;
import java.lang.String;
import java.lang.Integer;
import java.lang.Double;
import java.io.*;
import java.io.FileWriter;
import java.io.IOException;

//标准输入输出
Scanner scan = new Scanner(System.in);
if(scan.hasNext()){     //按单词输入
  String str1 = scan.next();
}
Scanner scan = new Scanner(System.in);
if(scan.hasNextLine()){   //按行输入
    String str2 = scan.nextLine();
}
System.out.println("Hello World");

//类型转换
String.valueOf(xxx) //万物转String
//int和String互转
Integer.toString(xxx) //int、Integer转String
Integer a = Integer(5)
a.toString(xxx) //Integer转String
Integer.valueOf("...")  //String转Integer
Integer.valueOf("...").intValue()  //String转int
Integer.parseInt("...")  //String转int
//其他类型和String互转大同小异

//异常处理（捕获全部异常）
try{}catch(Exception e){
   System.out.println("Exception thrown  :" + e);
}
//序列化到文件
try{
    FileOutputStream fileOut = new FileOutputStream("data/out");
    ObjectOutputStream out = new ObjectOutputStream(fileOut);
    out.writeObject(e);
    out.close();
    fileOut.close();
}catch(IOException e){
    e.printStackTrace();
}
//从文件反序列化
Employee e = null;
try{
    FileInputStream fileIn = new FileInputStream("/tmp/employee.ser");
    ObjectInputStream in = new ObjectInputStream(fileIn);
    e = (Employee) in.readObject();
    in.close();
    fileIn.close();
}catch(IOException i){
    i.printStackTrace();
    return;
}catch(ClassNotFoundException c){
    c.printStackTrace();
    return;
}
//读写文件
//写（FileWriter）
try {
  FileWriter myWriter = new FileWriter("filename.txt");
  myWriter.write("Files in Java might be tricky, but it is fun enough!");
  myWriter.close();
} catch (IOException e) {
  e.printStackTrace();
}
//读（Scanner）
try {
  File myObj = new File("filename.txt");
  Scanner myReader = new Scanner(myObj);
  while (myReader.hasNextLine()) {
    String data = myReader.nextLine();
    System.out.println(data);
  }
  myReader.close();
} catch (FileNotFoundException e) {
  e.printStackTrace();
}
//arraylist
ArrayList<Integer> myNumbers = new ArrayList<Integer>();
myNumbers.add(33);
myNumbers.remove(0);  //按下标删
myNumbers.get(0); //按下标获取
myNumbers.size(); //获取大小
for(int i =0;i<myNumbers.size();++i){
  myNumbers.get(i);
}
//hashmap
HashMap<Integer,String> mymap = new HashMap<Integer,String>();
mymap.put(3,"11")
mymap.get(3)
mymap.remove(3)
mymap.size()
for (Map.Entry<String, String> entry : map.entrySet()) {
    String mapKey = entry.getKey();
    String mapValue = entry.getValue();
    System.out.println(mapKey + "：" + mapValue);
}
for (String key : map.keySet()) {
  System.out.println(key);
}
for (String value : map.values()) {
  System.out.println(value);
}
//String操作
String s2  = "Hello".substring(1, 4); // 开始和结束索引
String[] parts = str.split(",");  //切分
String res = String.join(",",parts);  //拼接
s2.length();  //获取字符串长度
//math
Math.abs(a)
Math.max(a,b)
Math.min(a,b)
Math.ceil(a,b)
Math.exp(a)
Math.pow(a,b)
Math.sqrt(a)
Math.log(a)
Math.log10(a)
Math.sin/cos/tan(a)
```

