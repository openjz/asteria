<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>面试八股-通用 - 星</title><meta name="Description" content=""><meta property="og:title" content="面试八股-通用" />
<meta property="og:description" content="系统 基础 什么是协程 协程是一种运行在用户态的并发机制，类似于一种轻量级的用户态线程，协程一般运行在内核态线程之上（例如，可以按照n:m模型调度" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.shiwj.top/52.interview-bagu-general/" /><meta property="og:image" content="http://blog.shiwj.top/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-07T18:41:33+08:00" />
<meta property="article:modified_time" content="2025-07-14T01:34:31+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://blog.shiwj.top/logo.png"/>

<meta name="twitter:title" content="面试八股-通用"/>
<meta name="twitter:description" content="系统 基础 什么是协程 协程是一种运行在用户态的并发机制，类似于一种轻量级的用户态线程，协程一般运行在内核态线程之上（例如，可以按照n:m模型调度"/>
<meta name="application-name" content="星">
<meta name="apple-mobile-web-app-title" content="星"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://blog.shiwj.top/52.interview-bagu-general/" /><link rel="prev" href="http://blog.shiwj.top/16.interview-bagu-golang/" /><link rel="next" href="http://blog.shiwj.top/17.html-mdn-tutorial/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "面试八股-通用",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/blog.shiwj.top\/52.interview-bagu-general\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "http:\/\/blog.shiwj.top\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048 
                        }],"genre": "posts","keywords": "面试","wordcount":  15749 ,
        "url": "http:\/\/blog.shiwj.top\/52.interview-bagu-general\/","datePublished": "2022-10-07T18:41:33+08:00","dateModified": "2025-07-14T01:34:31+08:00","publisher": {
            "@type": "Organization",
            "name": "shiwj","logo": {
                    "@type": "ImageObject",
                    "url": "http:\/\/blog.shiwj.top\/images\/avatar.png",
                    "width":  690 ,
                    "height":  690 
                }},"author": {
                "@type": "Person",
                "name": "shiwj"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 全部 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i>  </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">全部</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">面试八股-通用</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/openjz" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>shiwj</a>
</span>&nbsp;<span class="post-category">included in <a href="/categories/%E7%BC%96%E7%A8%8B/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>编程</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-10-07">2022-10-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;15749 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;32 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#系统">系统</a>
      <ul>
        <li><a href="#基础">基础</a></li>
        <li><a href="#程序内存布局">程序内存布局</a></li>
        <li><a href="#内存管理">内存管理</a></li>
        <li><a href="#linux使用">linux使用</a></li>
        <li><a href="#linux的五种io模型">linux的五种I/O模型</a></li>
        <li><a href="#linux-io多路复用">linux I/O多路复用</a></li>
        <li><a href="#linux进程">linux进程</a></li>
        <li><a href="#linux进程间通信ipc">linux进程间通信（IPC）</a></li>
        <li><a href="#linux线程同步">linux线程同步</a></li>
        <li><a href="#linux内核">linux内核</a></li>
        <li><a href="#kmalloc">kmalloc</a></li>
        <li><a href="#vmalloc">vmalloc</a></li>
      </ul>
    </li>
    <li><a href="#网络">网络</a>
      <ul>
        <li><a href="#基础-1">基础</a></li>
        <li><a href="#tcp报文结构">TCP报文结构</a></li>
        <li><a href="#tcp三次握手四次挥手">TCP三次握手四次挥手</a></li>
        <li><a href="#tcp如何保证可靠传输">TCP如何保证可靠传输</a></li>
        <li><a href="#tcp流量控制">TCP流量控制</a></li>
        <li><a href="#tcp拥塞控制">TCP拥塞控制</a></li>
        <li><a href="#unix套接字">unix套接字</a></li>
      </ul>
    </li>
    <li><a href="#系统设计">系统设计</a>
      <ul>
        <li><a href="#restful-api">restful api</a></li>
        <li><a href="#设计模式">设计模式</a></li>
      </ul>
    </li>
    <li><a href="#性能分析">性能分析</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="系统">系统</h2>
<h3 id="基础">基础</h3>
<p><strong>什么是协程</strong></p>
<p>协程是一种运行在用户态的并发机制，类似于一种轻量级的用户态线程，协程一般运行在内核态线程之上（例如，可以按照n:m模型调度，即n个用户态协程运行在m个内核态线程上）。</p>
<p>协程分为有栈和无栈协程，有栈协程是指协程有自己栈空间，类似线程一样，无栈协程是指协程没有自己的栈空间，所有协程共享一个栈空间。golang的goroutine是典型的有栈协程，C++的coroutine是无栈协程。</p>
<p><strong>进程和线程的区别</strong></p>
<ul>
<li>进程是资源分配的基本单位，线程是调度的基本单位</li>
<li>进程间相互隔离，不共享资源，一个挂了不影响其他的，线程共享进程资源，一个线程挂了整个进程全挂</li>
<li>线程运行在进程内部，一个进程包含多个线程</li>
<li>进程存在父子关系，线程不存在</li>
<li>进程上下文切换开销比线程大</li>
<li>进程间通信方式和线程不同</li>
</ul>
<p><strong>死锁的四个条件</strong></p>
<ol>
<li>互斥，资源具有排他性，一个资源只能被一个进程/线程占用</li>
<li>不可剥夺，资源只能由持有方主动释放，不能强行剥夺</li>
<li>持有且等待，一个进程/线程持有资源的同时又请求其他资源</li>
<li>循环等待，资源等待链够形成环形</li>
</ol>
<p><strong>进程/线程调度</strong></p>
<p>抢占式调度，操作系统可以强制暂停正在运行的进程/线程，将CPU让出，现代通用操作系统基本都是抢占式调度（例如Windows、Linux等），通常基于时间片实现，抢占式调度由软中断和硬中断配合实现。</p>
<p>非抢占式调度，CPU资源只能由进程主动让出</p>
<p><strong>调度算法</strong></p>
<ol>
<li>先来先服务，对长作业有利，但是对短作业不利</li>
<li>最短作业优先，会发生饥饿现象</li>
<li>高响应比优先，综合考虑执行时间和等待时间，响应比=（等待时间+执行时间）/执行时间，照顾到了长进程</li>
<li>最高优先级调度，每次选择优先级最高的进程调度执行，优先级可以是静态的和动态的</li>
<li>多级反馈队列调度
<ol>
<li>系统设置多个就绪队列，每个队列有不同的优先级和时间片长度。高优先级队列时间片短，低优先级队列时间片长。</li>
<li>新到达的进程通常先进入最高优先级队列，获得较高的响应速度。</li>
<li>如果进程在高优先级队列的时间片内没有完成，会被降到下一级队列。反之，如果低优先级队列的进程长时间未被调度，也可以提升其优先级，防止饥饿。</li>
<li>总是优先调度高优先级队列中的进程，只有高优先级队列空闲时才调度低优先级队列。</li>
</ol>
</li>
<li>时间片轮转</li>
</ol>
<p><strong>页面置换策略</strong></p>
<p>页面置换策略，也就是缓存淘汰策略</p>
<ol>
<li>先进先出</li>
<li>最近最久未使用（LRU），通常用一个双向链表维护缓存页面信息，每当由页面被访问时，将其移动到链表头部，这样，链表尾部的页面就是最近最久未使用的页面，每次淘汰时选择链表尾部的页面。</li>
<li>最不常用（LFU），为每个页面维护一个访问计数器，每次淘汰访问次数最小的页面。</li>
<li>时钟页面置换，对每个内存页加个访问位，被访问到置位1，新页面为0，页面置换时扫描，将访问位为0时换出，访问位为1的重置为0。</li>
<li>最佳页面置换，最理想的页面置换，是一个概念，不是某个具体的算法。</li>
</ol>
<p><strong>系统调用的执行过程</strong></p>
<ol>
<li>应用程序在用户态通过库函数（如read、write、open等）发起系统调用请求。</li>
<li>系统调用会触发一次软中断（如x86上的int 0x80或syscall指令），CPU从用户态切换到内核态，进入操作系统内核。</li>
<li>系统调用id和参数通过寄存器或栈传递给内核，内核根据系统调用id找到对应的内核服务例程。</li>
<li>内核根据请求执行相应的操作（如文件读写、进程管理、内存分配等），访问硬件或内核资源。</li>
<li>内核将执行结果返回给用户程序，CPU从内核态切换回用户态，应用程序继续运行。</li>
</ol>
<p>软中断是中断的软件实现，和硬中断相对，软中断可以让cpu从用户态切换到内核态，主要用于实现系统调用和内核任务调度等。</p>
<p>进程控制块（PCB, Process Control Block）和线程控制块（TCB, Thread Control Block）是操作系统用来管理进程和线程的核心数据结构。它们分别保存如下内容：</p>
<p><strong>进程控制块（PCB）主要内容：</strong></p>
<ul>
<li>进程标识信息：进程ID（PID）、父进程ID、用户ID等</li>
<li>进程状态：就绪、运行、阻塞等</li>
<li>程序计数器（PC）：指向下一条将要执行的指令地址</li>
<li>CPU寄存器内容：上下文切换时保存/恢复</li>
<li>其它内容</li>
</ul>
<p><strong>线程控制块（TCB）主要内容：</strong></p>
<ul>
<li>线程标识信息：线程ID、所属进程ID</li>
<li>线程状态：就绪、运行、阻塞等</li>
<li>程序计数器（PC）：线程当前执行位置</li>
<li>CPU寄存器内容：线程上下文</li>
<li>栈指针和栈空间信息：每个线程有独立的栈</li>
<li>线程调度信息：优先级、调度队列指针等</li>
<li>线程局部存储（TLS）信息</li>
<li>其他：如信号掩码、线程私有数据等</li>
</ul>
<h3 id="程序内存布局">程序内存布局</h3>
<p>进程的内存布局大概分为以下5种内存区域</p>
<ul>
<li>代码区</li>
<li>Data区，已初始化的全局变量区</li>
<li>BSS区，未初始化的全局变量区，会在程序启动后自动清零。</li>
<li>堆区</li>
<li>栈区</li>
</ul>
<p>data区存放的数据是初始化过的全局变量，即编译期可以确定值的变量</p>
<p>bss区存放的是未初始化的全局变量，程序启动时会将这块内存区域清0</p>
<p>程序的内存布局是编译期决定的，编译完成后，内存布局信息就会写入到编出来的二进制文件中</p>
<p>可以通过一些工具查看可执行文件（exe，dll，so等）的内存布局，windows平台下可以用vs自带的dumpbin或者PE explorer和PE explorer v2查看，linux下可以用readelf查看</p>
<p>windows和linux的二进制文件格式不一样，windows是pe格式，linux是elf格式</p>
<p>实际的二进制文件中会有很多内存区域，上面提到的其实是理论上的5类内存区域</p>
<h3 id="内存管理">内存管理</h3>
<p><strong>虚拟内存和物理内存</strong></p>
<p>虚拟内存是操作系统为每个进程提供的、看起来连续且独立的内存空间，又称逻辑内存空间。每个进程都认为自己拥有完整的、独立的内存，不会与其他进程冲突。虚拟内存的大小通常大于实际物理内存，依赖于磁盘空间（如交换分区或页面文件）进行扩展。</p>
<p>物理内存指的是计算机实际安装的内存条（RAM），是所有进程和操作系统共享的真实硬件资源。</p>
<p>虚拟内存和物理内存的映射由操作系统和硬件（MMU，内存管理单元）共同完成。操作系统将虚拟地址空间划分为页（Page），通过页表（Page Table）记录虚拟页与物理页的对应关系。当进程访问虚拟地址时，MMU 会根据页表将虚拟地址转换为物理地址，实现虚拟内存到物理内存的映射。如果访问的虚拟页不在物理内存中，会触发缺页中断，操作系统将所需数据从磁盘调入物理内存。</p>
<p>总结：</p>
<p>虚拟内存：进程看到的逻辑内存空间
物理内存：实际的硬件内存
映射方式：通过页表和MMU将虚拟地址映射到物理地址</p>
<p><strong>内存碎片</strong></p>
<p>内存碎片是指在内存分配和释放过程中，内存空间被分割成许多零散的小块，导致无法有效利用，无法分配大块连续内存</p>
<p><strong>如何处理内存碎片</strong></p>
<p>通过内存分配算法优化内存分配，尽量减少内存碎片产生，例如最佳适应算法（Best Fit），查找最小的满足请求的空闲块，可能导致内存碎片更小，但速度慢。</p>
<p>内存紧缩（Compaction），将内存中分散的小块空闲空间整理成大块连续空间（主要用于外部碎片，常见于早期操作系统）。</p>
<p>分页和分段机制，通过虚拟内存的分页（Page）和分段（Segment）技术，将物理内存分为固定大小的页或段，有效避免或减少外部碎片。</p>
<h3 id="linux使用">linux使用</h3>
<ul>
<li><code>ps</code>，查看进程状态
<ul>
<li>ps命令参数分三种风格，带“-”的是unix风格，不带的是bsd风格，“&ndash;”是GNU风格，最坑的是不同风格的输出不一样
<blockquote>
<p>比如，ps -aux 和 ps aux其实完全不一样，-aux是想打印用户x的所有进程，如果用户x不存在，ps会帮你把命令改写成ps aux</p>
</blockquote>
</li>
<li>查看所有进程
<ul>
<li>ps -e，ps -ef，ps -eF，ps -ely</li>
<li>ps aux，ps ax</li>
</ul>
</li>
<li>查看进程树，ps -ejH，ps axjf</li>
<li><code>ps aux</code>，<code>x</code>列出没有控制终端的进程，<code>u</code>列出更多信息（用户、CPU、内存等）、<code>a</code>列出所有用户的进程</li>
<li>ps aux字段含义
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">USER          进程所有者的用户名
</span></span><span class="line"><span class="cl">PID           进程ID（Process ID）
</span></span><span class="line"><span class="cl">START         进程激活时间
</span></span><span class="line"><span class="cl">%CPU          进程的cpu占用率
</span></span><span class="line"><span class="cl">%MEM          进程使用内存的百分比
</span></span><span class="line"><span class="cl">VSZ           进程使用的虚拟内存大小，以K为单位
</span></span><span class="line"><span class="cl">RSS           驻留空间的大小。显示当前常驻内存的程序的K字节数。
</span></span><span class="line"><span class="cl">TTY           与进程关联的终端（tty）
</span></span><span class="line"><span class="cl">STAT          进程状态，包括下面的状态： 
</span></span><span class="line"><span class="cl">      D    不可中断的sleep，通常在IO
</span></span><span class="line"><span class="cl">      R    正在运行，或在可运行队列中的进程
</span></span><span class="line"><span class="cl">      S    可中断的sleep状态，通常是在等待事件将其唤醒
</span></span><span class="line"><span class="cl">      T    暂停状态（ctrl+z），即进程挂起状态
</span></span><span class="line"><span class="cl">      t    由于调试器跟踪而暂停
</span></span><span class="line"><span class="cl">      Z    僵尸进程，进程已执行完毕，但父进程没有回收其退出状态，这时候进程会成为僵尸进程  
</span></span><span class="line"><span class="cl">           和孤儿进程不同，孤儿进程是指父进程已结束，由init进程接管的进程
</span></span><span class="line"><span class="cl">      W    进入内存交换（从内核2.6开始无效）
</span></span><span class="line"><span class="cl">      X    正在被销毁（非常短暂，几乎不可能被看到）
</span></span><span class="line"><span class="cl">  状态描述
</span></span><span class="line"><span class="cl">      &lt;    高优先级
</span></span><span class="line"><span class="cl">      N    低优先级
</span></span><span class="line"><span class="cl">      L    有些页被锁进内存
</span></span><span class="line"><span class="cl">      s    session leader（会话首进程）
</span></span><span class="line"><span class="cl">      +    在前台进程组中
</span></span><span class="line"><span class="cl">      l    多线程，克隆线程
</span></span><span class="line"><span class="cl">TIME          进程使用的总CPU时间
</span></span><span class="line"><span class="cl">COMMAND       被执行的命令行
</span></span><span class="line"><span class="cl">NI            进程的优先级值，较小的数字意味着占用较少的CPU时间
</span></span><span class="line"><span class="cl">PRI           进程优先级。
</span></span><span class="line"><span class="cl">PPID          父进程ID
</span></span><span class="line"><span class="cl">WCHAN         进程等待的内核事件名  
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>linux中的虚拟内存不是指swap，是指进程的逻辑地址空间，只有实际访问到的内存会被映射到物理内存，这部分物理内存叫常驻内存。</p>
</blockquote>
</li>
</ul>
</li>
<li><code>grep</code>，文本搜索，<code>-c</code>：仅显示找到的行数，<code>-n</code>：显示行号，<code>-i</code>：忽略大小写，<code>-v</code>：反向搜索（搜索不包含指定字符串的行）</li>
<li><code>crontab</code>，定时任务，格式，“分 时 日 月 星期 命令”</li>
<li><code>free</code>，查看内存，默认按KB查看，-b，按字节展示，-k，按KB展示，-m，按MB展示，-g，按GB展示，-h，按适当的单位展示，-s N，隔N秒输出一次
<ul>
<li>第一行是内存，第二行是swap</li>
<li>total是总内存，used是已使用的内存，free是未使用的内存，shared是共享使用的内存，buff/cache是buffer和cache使用的内存，available是应用程序可用的内存。</li>
<li>和free相比，available算入了page cache
<blockquote>
<p>buffer是指buffer cache，buffer cache是存储在内存中的文件块（一个文件块大小不能超过内存页大小）</p>
<p>cache是指page cache，一般翻译成页高速缓存，是用内存做磁盘缓存，包含对普通文件、块设备文件、内存映射文件的缓存。对块设备文件的缓存就是buffer cache。</p>
</blockquote>
</li>
<li>free命令来自<code>/proc/meminfo</code>文件，直接查看这个文件也行</li>
</ul>
</li>
<li><code>top</code>，实时查看当前系统中的进程状态
<ul>
<li>第一部分，系统总体状况
<ul>
<li>第一行，当前时间，运行时间（up 2 day），当前用户数量，系统在之前1分钟、5分钟、15分钟的平均负载</li>
<li>第二行（进程信息），系统中的进程总数，正在运行的进程数，睡眠的进程数，正在停止的进程数，僵尸进程数。</li>
<li>第三行（cpu占用），用户模式，系统模式&hellip;</li>
<li>第四、五行（内存信息，和free命令差不多）</li>
</ul>
</li>
<li>第二部分，各个进程的详细信息，以下是各字段含义
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">PID — 进程id
</span></span><span class="line"><span class="cl">USER — 进程所有者
</span></span><span class="line"><span class="cl">PR — 进程优先级，值越小优先级越高
</span></span><span class="line"><span class="cl">NI — nice值。静态优先级，值越小优先级越高
</span></span><span class="line"><span class="cl">VIRT — 进程使用的虚拟内存总量，单位kb。
</span></span><span class="line"><span class="cl">RES — 常驻内存大小，单位kb。
</span></span><span class="line"><span class="cl">SHR — 共享内存大小，单位kb
</span></span><span class="line"><span class="cl">S —进程状态。
</span></span><span class="line"><span class="cl">%CPU — cpu占用
</span></span><span class="line"><span class="cl">%MEM — 内存占用
</span></span><span class="line"><span class="cl">TIME+ — 进程使用的CPU时间总计，最小单位是秒
</span></span><span class="line"><span class="cl">COMMAND — 命令
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><code>tar</code>，压缩和打包命令</li>
<li><code>netstat</code>，查看网络状态
<ul>
<li>按域查看，-4，-6，-A &lt;域&gt;，&ndash;域，具体的域有inet（ipv4）、inet6（ipv6）等等</li>
<li>按socket查看，-t，&ndash;tcp，-u，&ndash;udp，-x，&ndash;unix，-w，&ndash;raw等等</li>
<li>-a，查看所有socket（默认只显示建立连接的），-n，显示ip而不是域名，-p，显示pid（只有当前用户的进程号），-o，显示timers，-l，只显示监听，-e，显示用户和inode</li>
<li>-r，查看路由表，-i，查看网卡，-s，查看网络连接统计数据</li>
<li>-c，持续输出</li>
</ul>
</li>
<li><code>ping</code>，用于检测和目标主机的网络连接
<ul>
<li>利用icmp协议的echo信息检查目的主机的可达性、延迟、报文丢失情况
<blockquote>
<p>icmp协议（网络控制报文协议）是一种差错报告和信息查询协议，当数据传输出现错误时，利用icmp协议通知源主机数据传输出错，也可以利用icmp查询一些信息。</p>
<p>icmp报文放在ip报文的数据部分中，从报文结构上来看，icmp是ip的上层协议，但是icmp承担了ip层的任务，因此我们将icmp视为ip层协议</p>
</blockquote>
</li>
</ul>
</li>
<li><code>traceroute</code>，用于查看到目的主机的路由路径
<ul>
<li>traceroute有三种实现，icmp、udp、tcp</li>
<li>udp，<code>traceroute xxx</code>或<code>traceroute -T xxx</code>，traceroute默认使用udp。向目的主机发送很多不同TTL的UDP报文，并访问一个大于30000的端口号，如果在传输到某个路由器时TTL的值减为0，则路由器回送一个超时的ICMP报文，如果报文到达了目的主机，则目的主机会回送一个端口不可达的ICMP报文。</li>
<li>icmp，<code>traceroute -I xxx</code>。利用icmp echo实现，向目的主机发送很多不同TTL的ICMP echo请求报文，如果在传输到某个路由器时TTL的值减为0，则路由器回送一个超时的ICMP报文，如果报文到达了目的主机，则目的主机会回送一个ICMP echo响应报文。
<blockquote>
<p>TTL通常是指“报文最大生存时间”，但是在icmp里，TTL就是指路由器的跳数</p>
</blockquote>
</li>
<li>tcp，<code>traceroute -T xxx</code></li>
<li>问题
<ul>
<li>使用时看不到目的主机，使用udp协议时可能会出现这种情况，原因是目的主机没开放udp服务，回送不了“端口不可达”icmp报文</li>
<li>使用时看不到中间路由器，可能是因为中间路由器不支持回送超时icmp报文</li>
</ul>
</li>
<li>windows下的tracert使用icmp实现</li>
</ul>
</li>
<li><code>kill</code>，按进程id发信号
<ul>
<li>kill -l 可以查看所有信号的编号</li>
<li>kill默认发送的是TERM信号（编号15），会要求进程退出，进程在退出前可以做一些善后工作</li>
<li>kill -9 发送的是KILL信号，让进程强制退出，不给进程善后的机会</li>
</ul>
</li>
<li><code>killall</code>，按进程名字发信号</li>
<li><code>pkill</code>，筛选进程并发信号</li>
<li><code>pgrep</code>，筛选进程</li>
<li>linux的硬连接和软连接
<ul>
<li>一个linux文件元信息分为两部分，一部分是文件名，另一部分是inode，inode存放了文件的属性、数据块指针等</li>
<li>软连接，软连接类似于windows中的快捷方式，软连接不会对inode有真正的引用</li>
<li>硬连接是对inode的真正引用，只有把硬连接全部删除，文件才会被删掉</li>
</ul>
</li>
</ul>
<h3 id="linux的五种io模型">linux的五种I/O模型</h3>
<ul>
<li>阻塞式I/O
<ul>
<li>普通的IO操作都是阻塞式I/O</li>
<li>阻塞式I/O可能会被永久阻塞，比如网络连接一直没有数据过来</li>
</ul>
</li>
<li>非阻塞式I/O
<ul>
<li>如果I/O操作因为不满足条件而无法完成，调用会立即出错返回</li>
<li><strong>误区1</strong>，阻塞式I/O和异步I/O混为一谈
<ul>
<li>非阻塞是强调不会进入阻塞状态，调用一旦返回，这次调用就已经完成了。</li>
<li>异步I/O强调的是I/O操作和调用方并行，异步调用发起后立即返回的不是最终结果，而是告诉调用者一个“已收到”信息，最终执行完成后通过某种手段通知调用方执行结果。</li>
</ul>
</li>
<li><strong>误区2</strong>，非阻塞式I/O会造成进程或线程一直占用CPU
<ul>
<li>占用CPU的不是非阻塞式I/O，而是程序员轮询非阻塞式I/O造成的（比如写个死循环不停地调用非阻塞式I/O，直到成功为止）</li>
</ul>
</li>
</ul>
</li>
<li>信号驱动I/O
<ul>
<li>内核用SIGIO这个信号通知进程有事件到达，是一种异步通知机制</li>
<li>一般是UDP通信会使用这个I/O模型，原因是系统统一使用SIGIO这一个信号表示I/O事件，UDP只有两个事件会发出这个信号（数据到达和发生错误），比较容易判断和处理，而TCP有一堆事件会发出这个信号，而且信号发出过于频繁，没法采用这个I/O模型</li>
</ul>
</li>
<li>I/O多路复用
<ul>
<li>同时从多个文件描述符里读数据，可以在同一个线程内一个循环搞定，降低程序复杂度</li>
<li>通过 I/O 复用函数向内核注册一组文件描述符，当某个文件描述符准备好数据时，I/O 复用函数把其中就绪的文件描述符返回给用户程序，用户程序只需要轮询I/O复用函数即可，I/O复用函数是阻塞式的，因此轮询并不会占用cpu资源</li>
</ul>
</li>
<li>异步I/O
<ul>
<li>以上四种I/O模型，最多只能实现异步形式的通知，而最重要的数据传输都是同步的，即数据传输都要由用户线程或进程亲自完成。</li>
<li>异步I/O数据传输由内核接管，用户进程只需要发起I/O请求和等待完成通知即可</li>
</ul>
</li>
</ul>
<h3 id="linux-io多路复用">linux I/O多路复用</h3>
<ul>
<li>linux的IO多路复用，多路是指多个文件描述符，复用是指单线程或单进程可以同时监听多个文件描述符</li>
<li>I/O多路复用是linux的五种I/O模型中的一种，是为了解决在同一个用户进程内同时读写多个文件描述符的问题</li>
<li>三种，select/pselect、poll、epoll</li>
<li>通过 I/O 复用函数向内核注册一组文件描述符，当某个文件描述符准备好数据时，I/O 复用函数把其中就绪的文件描述符返回给用户程序，用户程序只需要轮询I/O复用函数即可。I/O复用函数是阻塞式的，因此循环调用并不会占用cpu资源。</li>
<li>I/O复用函数实际上是把文件描述符的状态检查交给内核去接管，用户进程只需要读写数据。</li>
<li>I/O多路复用通过超时时间来控制文件描述符的阻塞时间</li>
<li>select
<ul>
<li>传给内核的文件描述符集用一个位图来表示，同时要传入一个最大文件描述符+1这个一个值，告诉内核传入的描述符数，内核常量FD_SETSIZE表示这个值的最大值（1024）。</li>
<li>select返回准备好的描述符数，并且会根据准备好的描述符集覆写用户传入的位图。等于说是select返回以后，用户还得自己去遍历传入的位图，下一次调用select的时候再重新设置位图。</li>
<li>按事件类型将文件描述符集分为可读、可写和异常三个文件描述符集，可以根据需要传入一个或多个文件描述符集。</li>
<li>select的变体pselect，调用的时候可以额外指定一个信号屏蔽字</li>
</ul>
</li>
<li>poll
<ul>
<li>poll不像select一样为每个条件分别构造一个描述符集，而是采用一个数组，每个元素都是一个结构体，指定了文件描述符和事件类型。事件类型有两个，一个由用户写入，作为参数，一个由内核写入，作为返回。</li>
<li>poll突破了文件描述符1024上限的限制</li>
</ul>
</li>
<li>epoll
<ul>
<li>epoll由linux 2.6版本引入</li>
<li>epoll有三个函数
<ul>
<li>epoll_create，创建epoll句柄（也是一个文件描述符）</li>
<li>epoll_ctl，注册文件描述符和事件</li>
<li>epoll_wait，等待事件发生</li>
</ul>
</li>
<li>相比select和poll，epoll解决了什么问题
<ol>
<li>解决了select文件描述符上限是1024这个问题</li>
<li>对于select和poll，内核通过轮询来检查文件描述符的状态，文件描述符越多，效率越低</li>
<li>select和poll的每次调用是不相关的，每次调用都要重新构造参数，每次调用都会发生从用户态到内核态的内存拷贝</li>
</ol>
</li>
<li>epoll的原理
<ul>
<li>epoll背后有一套数据结构在做支撑，因此不需要每次调用epoll_wait之前都重新注册文件描述符，减少了内存拷贝</li>
<li>epoll不是通过轮询来检查文件描述符的状态，而是给每个文件描述符注册一个回调函数，一旦有注册事件发生，就会调用回调函数把文件描述符加入一个就绪列表，epoll_wait函数只是把这个就绪列表返回给用户，效率大大提升。</li>
<li>epoll有两种工作模式LT（level-trigger, 水平触发，默认）和ET（edge-trigger, 边缘触发）
<ul>
<li>LT是如果一个文件描述符处于就绪状态，内核就会通知你操作，即使你每次都不做操作，内核还是每次都会通知你。LT同时支持阻塞式I/O和非阻塞式I/O</li>
<li>ET是内核只有在文件描述符发生变化的时候才会通知你，如果文件描述符就绪了，你没有做任何操作或者数据没读完，下次内核就不会继续通知你了，因为文件描述符的状态没有变。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="linux进程">linux进程</h3>
<ul>
<li>fork是一种copy-on-write机制</li>
<li><strong>孤儿进程</strong>，父进程结束的进程，由init进程接管，父进程变为init进程</li>
<li><strong>僵尸进程</strong>，进程结束执行后，其进程控制块（task_struct）一直没被父进程回收，处于这个状态的进程叫做僵尸进程。
<ul>
<li>进程控制块通常是由父进程调用wait函数来回收，以获取子进程的返回码，运行状态等信息。</li>
<li>解决办法，kill掉其父进程，僵尸进程会被init进程接管并回收。</li>
</ul>
</li>
<li>进程组
<ul>
<li>每个进程都属于一个进程组</li>
<li>每个进程组有一个组长进程，组长进程的进程id和进程组一致</li>
<li>fork的子进程默认加入父进程的进程组</li>
</ul>
</li>
<li><strong>会话（session）</strong>
<ul>
<li>会话和一个控制终端相关联，一个会话包含多个进程组，其中有一个是前台进程组，其他的是后台进程组</li>
<li>会话首进程是控制进程，没有终端，会话首进程成为一个新进程组的组长</li>
<li>用户在shell中启动的一个进程组称为一个作业</li>
<li>只有前台作业能接受终端输入</li>
</ul>
</li>
<li>孤儿进程组
<ul>
<li>如果一个组的某个进程的父进程是同一会话中的另一个组的进程，那么这个组就不是孤儿进程组，否则它是孤儿进程组</li>
<li>换个说法，一个组的所有进程的父进程要么是组内的一个进程，要么是会话外的一个进程。</li>
<li>对于孤儿进程组，操作系统会给它们中的停止进程发送SIGHUP（挂断）信号。</li>
</ul>
</li>
<li><strong>守护进程</strong>
<ul>
<li>守护进程是一种长期在系统后台运行的进程</li>
<li>内核守护进程
<ul>
<li>ps命令输出的方括号中的进程是内核守护进程</li>
<li>所有的内核进程由2号进程kthreadd创建，kthreadd也是一个内核进程。</li>
<li>比如kswapd，负责内存换页</li>
</ul>
</li>
<li>用户守护进程
<ul>
<li>由1号进程init创建，init是用户态进程(init进程是传统的linux初始化进程，systemd是较新的Linux初始化进程，pid也是1)</li>
<li>比如inetd服务，负责侦听系统网络端口</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="linux进程间通信ipc">linux进程间通信（IPC）</h3>
<ul>
<li><strong>信号</strong>，信号是一种软中断机制
<ul>
<li>进程可以给一个信号注册一个处理函数，一旦接收到信号，就执行这个处理函数</li>
<li>如何发信号
<ul>
<li>用户按下某些终端按键，如ctrl+c</li>
<li>用户使用某些特殊命令，如kill</li>
<li>函数调用，如kill、raise、alarm</li>
</ul>
</li>
<li>作业控制信号
<ul>
<li>SIGINT，中断信号（ctrl+c），值为2，允许程序在退出前清理资源</li>
<li>SIGABRT，异常终止信号</li>
<li>SIGQUIT，退出（ctrl+\）</li>
<li>SIGTSTP，暂停（ctrl+z），可以忽视</li>
<li>SIGSTOP，暂停，不能忽视</li>
<li>SIGCONT，继续执行信号</li>
<li>SIGHUP信号，挂断会话</li>
</ul>
</li>
<li>其他信号
<ul>
<li>SIGTERM，请求退出</li>
<li>SIGKILL，强制退出，值为9，程序会立即被终止，无法进行任何清理或资源释放</li>
<li>SIGIO，IO事件</li>
</ul>
</li>
</ul>
</li>
<li><strong>管道</strong>
<ul>
<li>只能在有公共祖先的进程间通信，比如父子进程</li>
<li>调用pipe函数创建管道，返回两个文件描述符，对应管道的两端</li>
<li>通常的做法是在父进程创建管道，然后fork子进程，这样子进程也拥有了这个管道。进程把自己不用的那端关掉。</li>
<li>协同进程，现在有一个程序P，它从标准输入读，写到标准输出，如果有一个进程A，利用管道写P的标准输入，读P的标准输出，那么执行P的进程就是A的协同进程。
<ul>
<li>具体实现，A fork 进程B，创建两个管道p1和p2，p1的方向是从A到B，p2的方向相反，然后在进程B中执行程序P，并将P的标准输入改为p1的读端，将P的标准输出改为p2的写端，这样就实现了A输出到P的标准输入，A从P的标准输入读，此时，B是A的协同进程。</li>
</ul>
</li>
</ul>
</li>
<li><strong>FIFO</strong>，又称命名管道
<ul>
<li>和管道不同，FIFO可以在两个不相关的进程之间使用</li>
<li>FIFO创建在文件系统中，有路径名</li>
</ul>
</li>
<li>三种XSI IPC（XSI是POSIX.1中的X/Open系统接口的简写，属于一种Unix规范）
<ul>
<li><strong>消息队列</strong>
<ul>
<li>是内核中的一个链表，由消息队列标识符标识</li>
<li>消息队列可以实现全双工通信</li>
<li>消息队列最初的设计目的是提供全双工的高速通信，但随着后来很多新的IPC机制的提出，消息队列的性能优势已经不复存在，并且由于它存在的一些问题，新的程序里已经不推荐使用消息队列了。</li>
<li>缺陷，没有引用计数</li>
</ul>
</li>
<li><strong>信号量</strong>，是一个计数器，用来控制对临界资源的访问
<ul>
<li>缺陷，信号量不是一个单个非负值，而是一个信号量值的集合；信号量的定义和初始化不是原子的；无端增加程序的复杂性</li>
</ul>
</li>
<li><strong>共享内存</strong>
<ul>
<li>共享内存允许多个进程共享一段内存空间，数据不需要来回拷贝，所以共享内存是一种最快的IPC</li>
<li>共享内存段要先申请，然后连接到进程自己的内存地址空间</li>
</ul>
</li>
<li>XSI IPC的统一缺陷
<ul>
<li>它们在内核中是全局的，没有引用计数，不会自动回收，必须手动释放</li>
<li>XSI IPC的资源不是文件描述符的形式，而是各自专用的标识符</li>
</ul>
</li>
</ul>
</li>
<li><strong>posix信号量</strong>
<ul>
<li>解决了XSI信号量的不少问题，性能更高，没有信号量集的设定，不需要手动管理</li>
<li>推荐用这个</li>
</ul>
</li>
<li><strong>内存映射/存储映射</strong>（memory-mapped I/O mmap）
<ul>
<li>把一个文件直接映射为一段内存地址，读写这段内存地址就相当于对这个文件I/O</li>
<li>利用mmap实现</li>
</ul>
</li>
<li><strong>socket</strong>
<ul>
<li>tcp、udp、unix域</li>
</ul>
</li>
<li><strong>记录锁</strong>
<ul>
<li>对文件上锁，可以只对文件的一部分上锁</li>
<li>三种操作：共享读、独占写、解锁</li>
<li>记录锁只能用于多进程，不能用于多线程</li>
</ul>
</li>
</ul>
<h3 id="linux线程同步">linux线程同步</h3>
<ul>
<li>线程基本操作
<ul>
<li>创建，pthread_create</li>
<li>终止，pthread_exit</li>
<li>等待其他线程执行完毕，pthread_join</li>
<li>请求取消另外一个线程，pthread_cancel，取消是一种非正常退出</li>
<li>分离，pthread_detach，join操作不能等待分离线程</li>
</ul>
</li>
<li>线程其他操作
<ul>
<li>获取线程id</li>
<li>注册线程清理函数</li>
</ul>
</li>
<li>线程同步
<ul>
<li>所有锁都可以设置阻塞时间</li>
<li><strong>互斥量mutex</strong></li>
<li><strong>读写锁</strong></li>
<li><strong>条件变量</strong>
<ul>
<li>和互斥量配合使用</li>
<li>使用步骤
<ol>
<li>用户设定一个条件</li>
<li>一个线程因等待条件成立而阻塞，<code>pthread_cond_wait()</code></li>
<li>另外一个线程使条件成立，<code>pthread_cond_broadcast()</code>或<code>pthread_cond_signal()</code></li>
</ol>
</li>
<li>条件变量分为两部分: 条件和变量。条件本身是由互斥量保护的，线程在改变条件状态前先要锁住互斥量。具体过程是这样的：线程进入wait前，由用户加锁mutex，线程进入wait后释放mutex，保证wait过程是原子操作；唤醒也一样，唤醒前先加锁，唤醒后解锁；</li>
<li>条件变量类似于一个信号，线程本质上等待的是信号状态的改变</li>
</ul>
</li>
<li><strong>自旋锁</strong>，不会让线程进入阻塞状态，而是进入忙等待状态，一直占用cpu资源</li>
<li><strong>屏障</strong>，各个线程在各自的某个位置设置一个屏障，先执行到屏障的线程停下来等待，等足够多的线程执行到屏障位置，大家再一起往下执行。pthread_join就是一种屏障，只不过只有一个线程在等待。</li>
</ul>
</li>
</ul>
<h3 id="linux内核">linux内核</h3>
<ul>
<li>linux内核主要负责
<ul>
<li>内存管理</li>
<li>进程和线程管理</li>
<li>设备驱动</li>
</ul>
</li>
<li>内核态和用户态
<ul>
<li>内核态是内核程序运行的空间</li>
<li>用户态是用户程序运行的空间</li>
</ul>
</li>
<li>系统调用，内核态对用户态提供的访问接口</li>
<li>内存管理
<ul>
<li>存储层次，CPU、缓存、内存、外存</li>
<li>段页式内存管理
<ul>
<li>把内存划分为大的段，在段内部分页</li>
<li>一个地址的高位是段地址，地位是页地址</li>
<li>段表相当于是页表的索引</li>
</ul>
</li>
<li>快表（TLB）和页表，块表是页表的缓存</li>
<li>numa，现代多核cpu通常是numa结构，每个核心都有自己的cache，可访问内存区域等，构成了每个核心的内存访问子系统</li>
</ul>
</li>
</ul>
<p>Linux内核的两种内存分配函数kmalloc 和 vmalloc，但只适用于内核模块和驱动模块，不能再用户态程序中使用：</p>
<h3 id="kmalloc">kmalloc</h3>
<ul>
<li>分配<strong>物理上连续</strong>的内存区域，虚拟地址和物理地址一一对应。</li>
<li>分配速度快，适合分配小块内存（通常小于几百 KB）。</li>
<li>常用于需要 DMA（直接内存访问）等对物理连续性有要求的场景，如驱动开发、内核模块中缓存、队列等。</li>
</ul>
<h3 id="vmalloc">vmalloc</h3>
<ul>
<li>分配<strong>虚拟地址连续</strong>但物理地址不一定连续的内存区域。</li>
<li>适合分配大块内存（大于 kmalloc 能分配的最大块），如几百 KB 甚至 MB 级别。</li>
<li>适用于对物理连续性无要求，但需要较大内存的内核模块。</li>
</ul>
<h2 id="网络">网络</h2>
<h3 id="基础-1">基础</h3>
<ul>
<li>网络体系结构
<ul>
<li>OSI七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层
<ul>
<li>会话层想要解决两个应用程序之间的会话管理问题</li>
<li>表示层想要解决的是两个应用程序之间通信的语法语义问题，数据转换问题（编码解码，压缩和解压缩）</li>
</ul>
</li>
<li>五层：物理层，数据链路层，网络层，传输层，应用层</li>
<li>TCP/IP四层：网络接口层，网络层，传输层，应用层</li>
</ul>
</li>
<li>数据链路层协议，CSMA/CD、PPP、PPPoE</li>
<li>网络层协议，IP、ARP、RARP、OSPF、RIP、BGP
<ul>
<li>路由协议，OSPF、RIP、BGP，内部网关协议IGP是一类协议</li>
<li>OSPF，是一种内部网关协议，开放最短路径优先协议，基于IP</li>
<li>RIP，是一种内部网关协议，距离矢量，基于UDP</li>
<li>BGP，边界网关协议，距离矢量，基于TCP</li>
</ul>
</li>
<li>传输层协议，TCP、UDP</li>
<li>哪些基于UDP，RIP、DNS、DHCP</li>
<li>http状态码
<ul>
<li>1开头，信息性状态码，接受的请求正在处理</li>
<li>2开头，成功</li>
<li>3开头，重定向</li>
<li>4开头，客户端错误</li>
<li>5开头，服务端错误</li>
</ul>
</li>
<li>HTTP 1.0 为短连接，HTTP 1.1 支持长连接</li>
</ul>
<h3 id="tcp报文结构">TCP报文结构</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">TCP报文结构（20字节定长首部 + 可选首部 + 数据部分）
</span></span><span class="line"><span class="cl">下面是20字节定长首部的结构示意图：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  0      4       8      12      16      20      24      28      32
</span></span><span class="line"><span class="cl">  +-------+-------+-------+-------+-------+-------+-------+-------+
</span></span><span class="line"><span class="cl">  |        源端口（16位）         |      目的端口（16位）         |
</span></span><span class="line"><span class="cl">  +-------------------------------+-------------------------------+
</span></span><span class="line"><span class="cl">  |                        序号（32位）                          |
</span></span><span class="line"><span class="cl">  +---------------------------------------------------------------+
</span></span><span class="line"><span class="cl">  |                     确认号（32位）                           |
</span></span><span class="line"><span class="cl">  +---------------------------------------------------------------+
</span></span><span class="line"><span class="cl">  | 数据偏移 | 保留 | 控制位 |        窗口（16位）                |
</span></span><span class="line"><span class="cl">  |  (4位)  | (6位)| (6位)  |                                    |
</span></span><span class="line"><span class="cl">  +-------------------------------+-------------------------------+
</span></span><span class="line"><span class="cl">  |         校验和（16位）        |    紧急指针（16位）            |
</span></span><span class="line"><span class="cl">  +-------------------------------+-------------------------------+
</span></span><span class="line"><span class="cl">  |           选项（可变）        |           填充（可变）         |
</span></span><span class="line"><span class="cl">  +---------------------------------------------------------------+
</span></span><span class="line"><span class="cl">  |                        数据部分（可变）                       |
</span></span><span class="line"><span class="cl">  +---------------------------------------------------------------+
</span></span></code></pre></td></tr></table>
</div>
</div><p>说明：</p>
<ul>
<li>序号，4字节，报文序号</li>
<li>确认号，4字节，期望下次收到报文的序号</li>
<li>数据偏移：4位，TCP首部长度（以4字节为单位），因此TCP首部最长60字节</li>
<li>保留：6位，保留未用</li>
<li>控制位：6位（URG, ACK, PSH, RST, SYN, FIN）
<ul>
<li>紧急字段URG，当URG=1时，代表此报文段中有紧急数据，应尽快传送。</li>
<li><strong>确认字段ACK</strong>，当ACK=1时，表示确认，且确认号有效；当ACK=0时，确认号字段无效。</li>
<li>推送字段PSH，当PSH=1时，则报文段会被尽快地交付给目的方，不会对这样的报文段使用缓存策略。</li>
<li>复位字段RST，当RST为1时，表明TCP连接中出现了严重的差错，必须释放连接，然后再重新建立连接。</li>
<li><strong>同步字段SYN</strong>，当SYN=1时，表示发起一个连接请求。</li>
<li><strong>终止字段FIN</strong>，用来释放连接。当FIN=1时，表明此报文段的发送端的数据已发送完成，并要求释放连接。</li>
</ul>
</li>
<li>窗口：2字节，接收窗口大小</li>
<li>校验和：2字节，首部和数据的校验</li>
<li>紧急指针：2字节，紧急数据的偏移量</li>
<li>选项和填充：可选字段，首部长度大于20字节时存在</li>
<li>数据部分：实际传输的数据内容</li>
</ul>
<h3 id="tcp三次握手四次挥手">TCP三次握手四次挥手</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">================ TCP三次握手交互 ==================
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Client                                          Server
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            |                                |  CLOSED
</span></span><span class="line"><span class="cl">CLOSED      |                                |  LISTEN
</span></span><span class="line"><span class="cl">            | ---- SYN(seq=x) -------------&gt; |  
</span></span><span class="line"><span class="cl">SYN-SENT    |                                |  
</span></span><span class="line"><span class="cl">            | &lt;--- SYN(seq=y),ACK(ack=x+1) - |
</span></span><span class="line"><span class="cl">            |                                |  SYN-RCVD
</span></span><span class="line"><span class="cl">            | ---- ACK(ack=y+1) ------------&gt;|  
</span></span><span class="line"><span class="cl">ESTABLISHED |                                |  ESTABLISHED
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">================ TCP四次挥手交互 ==================
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Client                                         Server
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ESTABLISHED |                               |  ESTABLISHED
</span></span><span class="line"><span class="cl">            | ---- FIN(seq=u) -------------&gt;|  
</span></span><span class="line"><span class="cl">FIN-WAIT-1  |                               |  
</span></span><span class="line"><span class="cl">            | &lt;--- ACK(ack=u+1) ------------|  
</span></span><span class="line"><span class="cl">FIN-WAIT-2  |                               |  CLOSE-WAIT
</span></span><span class="line"><span class="cl">            | &lt;--- FIN(seq=v) --------------|  
</span></span><span class="line"><span class="cl">            |                               |  LAST-ACK
</span></span><span class="line"><span class="cl">            | ---- ACK(ack=v+1) -----------&gt;|  
</span></span><span class="line"><span class="cl">TIME-WAIT   |                               |  CLOSED
</span></span><span class="line"><span class="cl">CLOSED      |                               |
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>三次握手</strong></p>
<ul>
<li>客户端状态变迁：CLOSED,SYN-SENT,ESTABLISHED</li>
<li>服务端状态变迁：CLOSED,LISTEN,SYN-RCVD,ESTABLISHED</li>
<li>过程
<ol>
<li>服务端从CLOSED变为LISTEN</li>
<li>客户端发送 SYN,seq=x,从CLOSED变为SYN-SENT，x是客户端设定的初始序号</li>
<li>服务端发送 SYN,ACK,seq=y,ack=x+1，从LISTEN变为SYN-RCVD</li>
<li>客户端发送 ACK,seq=x+1,ack=y+1,从SYN-SENT变为ESTABLISHED</li>
<li>服务端进入ESTABLISHED</li>
</ol>
</li>
</ul>
<p><strong>为什么不能两次握手</strong></p>
<ul>
<li>两次握手的话，服务端只有两个状态，监听和建立连接，服务端很有可能因为一个延迟收到的连接请求单方面进入连接状态，浪费资源。比如客户端向服务端发起连接，客户端重试了一次，第二次成功建立了链接，等连接释放后，服务端才接收到第一次连接请求，当方面进入了连接状态，而客户端并没有进入连接，白白浪费了客户端资源。</li>
<li>而客户端没有这个问题，因为客户端是主动发起连接的一方，只要客户端不想进入连接，不管他接收到什么数据，都不会影响客户端。</li>
<li>加了第三次握手以后，重试的连接请求只能导致客户端进入SYN-RCVD状态，不会导致进入连接状态</li>
</ul>
<p><strong>四次挥手</strong></p>
<ul>
<li>一方主动断开
<ul>
<li>主动断开方A状态变化，ESTABLISHED,FIN-WAIT-1,FIN-WAIT-2,TIME-WAIT,CLOSED</li>
<li>被动断开方B状态变化，ESTABLISHED,CLOSE-WAIT,LAST-ACK,CLOSED</li>
<li>A发送 FIN,seq=x，A从ESTABLISHED变为FIN-WAIT-1</li>
<li>B发送 ACK,ack=x+1，B从ESTABLISHED变为CLOSED-WAIT</li>
<li>A从FIN-WAIT-1变为FIN-WAIT-2</li>
<li>B发送 FIN,ACK,seq=y,ack=x+1，B从CLOSED-WAIT变为LAST-ACK</li>
<li>A发送ACK,seq=x+1,ack=y+1,A从FIN-WAIT-2变为TIME-WAIT（等待2MSL），最后变为CLOSED</li>
<li>B从LAST-ACK变为CLOSED</li>
</ul>
</li>
<li>两方同时断开
<ul>
<li>双方同时向对方发送FIN，同时回复ACK，分别进行两次挥手，同时释放连接</li>
</ul>
</li>
</ul>
<p><strong>为什么要四次挥手</strong></p>
<p>让被动断开的一方把剩余数据传输完毕</p>
<p><strong>主动断开的一方为什么要等待2MSL</strong></p>
<p>MSL是报文在网络中的最大生存时间，2MSL正好是报文一次往返的时间，这是为了确保对方收到了最后的ACK，避免对方ACK丢失重发FIN时主动关闭方收不到，从而无法关闭连接。</p>
<p>同时也是为了防止新连接收到网络上遗留的上次连接的旧数据包。</p>
<h3 id="tcp如何保证可靠传输">TCP如何保证可靠传输</h3>
<ul>
<li>序列号和确认号<br>
每个TCP报文段都有一个序列号，用于标识数据的顺序；接收方通过确认号来告诉发送方自己已经收到的数据。
<ul>
<li>选择确认（SACK），场景：接收方收到了一些数据，但另一些数据没有收到（或未按序到达），接收方希望发送方有选择地重传，而不是重传整个窗口的数据。</li>
</ul>
</li>
<li>超时重传<br>
发送方在规定的时间内没有收到确认应答，会自动重传未被确认的数据包</li>
<li>有序传输<br>
接收方会根据序号将乱序到达的数据重新排序后交给应用层</li>
<li>校验和<br>
TCP报文段包含一个校验和字段，用于检测数据在传输过程中是否发生了错误。</li>
</ul>
<h3 id="tcp流量控制">TCP流量控制</h3>
<p>流量控制是指让发送方发送不要太快，让接收方来得及接收，主要利用滑动窗口来实现流量控制。</p>
<p><strong>什么是滑动窗口</strong></p>
<ul>
<li>发送窗口和接收窗口
<ul>
<li>发送窗口中是允许发送的字节，发送窗口之前是已发送并得到确认的字节，发送窗口之后是不允许发送的字节</li>
<li>接收窗口中是允许接收的字节，接收窗口之前是已经收到并确认过的字节，接收窗口之后是不允许接收的字节</li>
<li>发送窗口是发送方的发送缓存的一部分；接收窗口是接收方的接收缓存的一部分</li>
</ul>
</li>
<li>窗口中的每个字节都有序号<br>
发送窗口的序号是发送方的序号，接收窗口的序号是接收方的序号，相互独立，各是各的</li>
<li>发送方和接收方
<ul>
<li>每一方都有自己的发送窗口和接收窗口；因此A的发送窗口和B的接收窗口是一对，反之是另外一对</li>
</ul>
</li>
</ul>
<p><strong>如何利用滑动窗口控制流量</strong></p>
<p>B会在每个TCP报文里带上自己当前的接收窗口大小，将自己的接收窗口大小发送给A，A会根据接收窗口的大小确定自己发送窗口的大小，因此发送窗口一定不会大于接收窗口</p>
<p>当接收方感觉发送速率过快时，减小接收窗口，并将新的窗口值发送给发送方。</p>
<p>零窗口时（接收窗口降为0时），发送方启动一个计时器，每隔一段时间发送一个探测报文，去获得当前最新的窗口值；防止接收方发出的窗口值更新报文滞留在网络中。</p>
<h3 id="tcp拥塞控制">TCP拥塞控制</h3>
<p>拥塞控制的目的是防止大量的报文进入网络中，把负载控制在网络可承受的范围内。</p>
<p><strong>拥塞窗口</strong>，发送方根据网络状态自己计算出的一个窗口；可以理解为发送窗口=min（拥塞窗口cwnd，接收窗口rwnd）</p>
<p><strong>有四种拥塞控制算法，分别是慢开始，拥塞避免，快重传和快恢复</strong>，这四种算法通过调整拥塞窗口的大小来控制网络的拥塞。</p>
<ul>
<li><strong>慢开始</strong>：
<ul>
<li>发送方逐渐增加拥塞窗口，而不是一下子增大拥塞窗口。</li>
<li>发送方将拥塞窗口cwnd设置为1，即1个报文段的大小（MSS），每收到一个确认，就把拥塞窗口增大1个报文段的大小（MSS），直到达到一个门限值ssthresh。注意，<strong>拥塞窗口实际是按乘法增加的（每次翻倍）</strong>，因为拥塞窗口增加后，发送方能发出更多的报文，能收到更多的确认，拥塞窗口会增加速度会越来越快。</li>
</ul>
</li>
<li><strong>拥塞避免</strong>：
<ul>
<li>慢开始和拥塞避免这两个过程之间有一个<strong>门限值ssthresh</strong>，拥塞窗口过了这个门限值以后切换为拥塞避免算法。</li>
<li>拥塞避免算法把拥塞窗口的<strong>乘法增大改为加法增大</strong>，不再按收到的ack回复增大，而是每隔一个往返时间RTT就增大一个报文段的大小（MSS）</li>
<li><strong>发生超时后，把门限值设为当前拥塞窗口的一半，cwnd重置为1，从慢开始算法重新开始</strong>。</li>
</ul>
</li>
<li><strong>快重传</strong>
<ul>
<li>快重传是为了避免发送方误以为网络发生了拥塞从而降低传输效率；，</li>
<li>当接收方收到一个失序的数据包（即收到了后续的数据，但中间某个数据包丢失）时，会对最后一个按序收到的数据包的确认号进行重复确认，发送方一旦收到连续三个重复确认，就知道有数据丢失了，马上重传数据，而不进入超时等待；</li>
</ul>
</li>
<li><strong>快恢复</strong>
<ul>
<li>发送方现在知道了只是<strong>丢失了个别数据</strong>，因此重传的时候不执行慢开始，<strong>把发送窗口增大到门限值后直接进入拥塞避免</strong>算法；</li>
</ul>
</li>
</ul>
<h3 id="unix套接字">unix套接字</h3>
<ul>
<li>概念
<ul>
<li>进程，是一个通信实体</li>
<li>ip:port，是一种通信地址资源</li>
<li>unix套接字，是对一个通信端点的抽象</li>
<li>套接字类型（可以看作是对传输特性的描述）
<ul>
<li>SOCK_DGRAM，固定长度、无连接、不可靠的报文传输</li>
<li>SOCK_STREAM，面向连接、有序、可靠的字节流传输</li>
<li>SOCK_RAW，IP协议的数据报接口</li>
<li>SOCK_SEQPACKET，固定长度、面向连接、有序、可靠的报文传输</li>
</ul>
</li>
<li>域类型
<ul>
<li>AF_INET，IPv4域</li>
<li>AF_INET6，IPv6域</li>
<li>AF_UNIX，unix域</li>
<li>AF_UNSPEC，未指定</li>
</ul>
</li>
<li><strong>套接字和域的组合决定了协议</strong>，一个组合可以对应多个协议，在IPv4域中，SOCK_STREAM默认对应TCP协议，SOCK_DGRAM默认对应UDP协议</li>
</ul>
</li>
<li>操作
<ul>
<li>socket，创建一个套接字</li>
<li>bind，绑定一个ip:port</li>
<li>服务端
<ul>
<li>listen，监听请求，监听请求的套接字称为原始套接字</li>
<li>accept，获得一个连接请求并建立连接，每个连接对应一个新套接字，它们的地址和原始套接字相同</li>
</ul>
</li>
<li>客户端
<ul>
<li>connect，和服务端建立连接</li>
</ul>
</li>
<li>close，关闭套接字</li>
</ul>
</li>
<li><strong>一个ip:port可以建立多个tcp连接吗？</strong>
<ul>
<li>连接是通过套接字建立的，<strong>一般情况下，一个ip:port只能绑定到一个套接字上</strong>，如果ip:port被占用，又试图去用另外一个套接字用这个地址通信，就会出现端口冲突。</li>
<li>对于服务端，原始套接字负责监听，每建立一个连接，就创建一个新套接字负责数据传输，原始套接字和新套接字共用一个地址。因此，<strong>对于服务端，一个ip:port可以通过原始套接字建立多个tcp连接</strong>。或者说，只能有一个套接字监听一个ip:port，但是可以和多个客户端建立连接。</li>
<li>对于客户端，没有原始套接字的概念，一个套接字只能建立一个tcp连接，因而，<strong>对于客户端，一个ip:port只能建立一个tcp连接</strong>。</li>
</ul>
</li>
</ul>
<h2 id="系统设计">系统设计</h2>
<h3 id="restful-api">restful api</h3>
<ul>
<li>把接口视为资源</li>
<li>用HTTP方法表示操作，GET、POST、PUT、DELETE，读取、新增、修改、删除</li>
<li>用URL表示资源，而不是通过参数表示资源</li>
<li>接口命名（命名中只包含资源，不能包含操作）</li>
</ul>
<h3 id="设计模式">设计模式</h3>
<ul>
<li>单例模式，静态全局变量，私有构造函数，静态方法获取全局变量
<ul>
<li>懒汉式，获取时初始化单例（存在线程安全问题）</li>
<li>饿汉式，直接初始化单例</li>
</ul>
</li>
<li>工厂模式
<ul>
<li>简单工厂，根据参数返回特性对象</li>
<li>抽象工厂，根据参数返回特定工厂</li>
</ul>
</li>
<li>模板模式</li>
</ul>
<h2 id="性能分析">性能分析</h2>
<p><strong>监控和告警</strong></p>
<p>看哪些指标下降，包括机器和服务两种监控</p>
<p>机器监控主要看机器资源（cpu idle、memory idle，网络带宽情况），服务监控主要看服务状态（稳定性，耗时，流量）</p>
<p><strong>日志分析</strong></p>
<p>分析全链路线上日志，按照关注的日志项，使用grep、tail、wc等命令分析请求执行情况</p>
<p><strong>压力测试+性能分析工具</strong></p>
<p>gperf + brpc火焰图，分析热点函数</p>
<p><strong>代码审查</strong></p>
<p>根据程序架构，找到可能性较大的瓶颈点，分析执行耗时点，内存分配和释放问题</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2025-07-14&nbsp;<a class="git-hash" href="https://github.com/openjz/asteria/commit/fcda160d451c753f385965fc5a4e8380a81aaef6" target="_blank" title="commit by shiwj(swj6086085@163.com) fcda160d451c753f385965fc5a4e8380a81aaef6: update posts about interviews">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>fcda160</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/52.interview-bagu-general/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/16.interview-bagu-golang/" class="prev" rel="prev" title="面试八股-golang"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>面试八股-golang</a>
            <a href="/17.html-mdn-tutorial/" class="next" rel="next" title="html入门笔记">html入门笔记<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/openjz" target="_blank">shiwj</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp">津ICP备2020010292号-1</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
