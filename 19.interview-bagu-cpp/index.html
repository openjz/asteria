<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>面试八股-c&#43;&#43; - 星</title><meta name="Description" content=""><meta property="og:title" content="面试八股-c&#43;&#43;" />
<meta property="og:description" content="threadlocal volatile：当对象的值可能在程序的控制之外被改变时，将对象声明为volatile，比如程序内包含一个由系统时钟定时更新的变量时。vo" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.shiwj.top/19.interview-bagu-cpp/" /><meta property="og:image" content="http://blog.shiwj.top/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-25T15:46:32+08:00" />
<meta property="article:modified_time" content="2025-07-12T17:57:24+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://blog.shiwj.top/logo.png"/>

<meta name="twitter:title" content="面试八股-c&#43;&#43;"/>
<meta name="twitter:description" content="threadlocal volatile：当对象的值可能在程序的控制之外被改变时，将对象声明为volatile，比如程序内包含一个由系统时钟定时更新的变量时。vo"/>
<meta name="application-name" content="星">
<meta name="apple-mobile-web-app-title" content="星"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://blog.shiwj.top/19.interview-bagu-cpp/" /><link rel="prev" href="http://blog.shiwj.top/18.webpage-print/" /><link rel="next" href="http://blog.shiwj.top/20.cpp-stl-algorithm-overview/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "面试八股-c++",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/blog.shiwj.top\/19.interview-bagu-cpp\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "http:\/\/blog.shiwj.top\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048 
                        }],"genre": "posts","keywords": "面试, c\/c\u002b\u002b","wordcount":  7950 ,
        "url": "http:\/\/blog.shiwj.top\/19.interview-bagu-cpp\/","datePublished": "2022-10-25T15:46:32+08:00","dateModified": "2025-07-12T17:57:24+08:00","publisher": {
            "@type": "Organization",
            "name": "shiwj","logo": {
                    "@type": "ImageObject",
                    "url": "http:\/\/blog.shiwj.top\/images\/avatar.png",
                    "width":  690 ,
                    "height":  690 
                }},"author": {
                "@type": "Person",
                "name": "shiwj"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 全部 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i>  </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">全部</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">面试八股-c&#43;&#43;</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/openjz" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>shiwj</a>
</span>&nbsp;<span class="post-category">included in <a href="/categories/%E7%BC%96%E7%A8%8B/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>编程</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-10-25">2022-10-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;7950 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;16 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#static关键字的作用">static关键字的作用</a></li>
    <li><a href="#c和c的区别">C++和C的区别</a></li>
    <li><a href="#c内存布局">C++内存布局</a></li>
    <li><a href="#各种指针">各种指针</a></li>
    <li><a href="#inline">inline</a></li>
    <li><a href="#const的作用">const的作用</a></li>
    <li><a href="#c在执行main函数之前都做什么">C++在执行main函数之前都做什么</a></li>
    <li><a href="#vector">vector</a></li>
    <li><a href="#c11中的新特性">c++11中的新特性</a>
      <ul>
        <li><a href="#重要的特性">重要的特性</a></li>
        <li><a href="#新语法">新语法</a></li>
        <li><a href="#其他特性">其他特性</a></li>
      </ul>
    </li>
    <li><a href="#类型转换">类型转换</a></li>
    <li><a href="#内存管理">内存管理</a>
      <ul>
        <li><a href="#智能指针">智能指针</a></li>
        <li><a href="#allocator">allocator</a></li>
      </ul>
    </li>
    <li><a href="#面向对象">面向对象</a></li>
    <li><a href="#泛型">泛型</a></li>
    <li><a href="#stl">stl</a></li>
    <li><a href="#隐式类型转换">隐式类型转换</a></li>
    <li><a href="#其他">其他</a></li>
    <li><a href="#c20">C++20</a></li>
    <li><a href="#socket开发">socket开发</a></li>
    <li><a href="#boost">boost</a></li>
    <li><a href="#grpc--brotobuf">grpc + brotobuf</a></li>
    <li><a href="#函数调用约定">函数调用约定</a></li>
    <li><a href="#函数是如何调用的">函数是如何调用的</a></li>
    <li><a href="#局部变量的入栈顺序">局部变量的入栈顺序</a></li>
    <li><a href="#为啥函数栈被写坏了函数返回时被崩溃">为啥函数栈被写坏了，函数返回时被崩溃</a></li>
    <li><a href="#顶层const和底层const的写法">顶层const和底层const的写法</a></li>
    <li><a href="#cc程序的编译过程">C/C++程序的编译过程</a></li>
    <li><a href="#gdb常用命令">gdb常用命令</a></li>
    <li><a href="#其他问题">其他问题</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><ul>
<li>threadlocal</li>
<li>volatile：当对象的值可能在程序的控制之外被改变时，将对象声明为volatile，比如程序内包含一个由系统时钟定时更新的变量时。volatile本质上是阻止编译器优化，让程序永远从内存读取这个对象，不会把他加载到寄存器中。（参考C++ Primer第5版）</li>
</ul>
<h2 id="static关键字的作用">static关键字的作用</h2>
<ul>
<li>全局静态变量
<ul>
<li>将全局变量声明为static可以使得全局变量只在当前文件内有效；</li>
<li>实际上，对于全局变量，static修改了标识符的链接属性，由默认的external变为internal</li>
<li>C++11的匿名命名空间代替了这个功能；</li>
<li><strong>静态存储区</strong></li>
<li>如果全局变量不加static，它也是静态的，只不过作用域是全局的，可以通过extern引入</li>
</ul>
</li>
<li>局部静态变量
<ul>
<li>在局部作用域中声明的static变量，例如函数中的static变量；</li>
<li>局部静态变量从第一次执行定义时生效；</li>
<li>即使函数结束执行，该变量也不会被销毁，只有程序结束后才销毁该变量；</li>
<li><strong>静态存储区</strong></li>
</ul>
</li>
<li>类的静态成员变量
<ul>
<li>属于类，不属于某个对象；</li>
<li>使用<code>class::static_member</code>的方式调用；</li>
<li>模板的静态成员属于每个模板实例；</li>
<li>派生类的对象能访问基类的静态成员；</li>
</ul>
</li>
<li>类的静态成员函数
<ul>
<li>静态成员函数只能操作类的静态成员变量；</li>
<li>不包含this指针，因此也不能声明为const；（静态成员函数不属于任何对象，因此也不包含this指针，没有this指针，自然也就不能指向const对象）；</li>
</ul>
</li>
<li>（静态函数）
<ul>
<li>对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用。</li>
</ul>
</li>
</ul>
<h2 id="c和c的区别">C++和C的区别</h2>
<ul>
<li>C++是面向对象的语言，而C是面向过程的结构化编程语言</li>
<li>C++具有封装、继承和多态三种特性</li>
<li>C++相比C，增加多许多类型安全的功能，比如强制类型转换</li>
<li>C++支持泛型编程，比如模板类、函数模板等</li>
</ul>
<h2 id="c内存布局">C++内存布局</h2>
<ul>
<li>代码区（文本区）</li>
<li>数据区：已初始化的全局变量、静态变量</li>
<li>BSS区：未初始化的全局变量区</li>
<li>堆区</li>
<li>栈区</li>
</ul>
<h2 id="各种指针">各种指针</h2>
<ul>
<li>悬垂指针/空悬指针<br>
指针指向的内存已经被释放了，指针本身还指向被释放的内存。</li>
<li>野指针<br>
未初始化的指针（没有被初始化为nullptr），随即指向一块内存。</li>
<li>空指针<br>
nullptr、NULL、0</li>
<li>内存泄漏<br>
内存还没释放，指针弄没了。</li>
</ul>
<h2 id="inline">inline</h2>
<ul>
<li>早期的作用：<strong>inline可以看作是给编译器的建议</strong>，（1）编译器会根据函数的规模等指标决定是否把函数在调用处展开，例如函数是否被调用很多次、函数内部是否有for、switch、while等复杂的控制逻辑、函数是否递归等。（2）即使不加inline，在o3编译时，编译器有时也会自动将小函数内联，因此，<strong>使用inline时首先考虑的并不应该是效率，而是其他东西</strong>。</li>
<li>现在的作用：能让一个函数定义在头文件里</li>
</ul>
<h2 id="const的作用">const的作用</h2>
<ul>
<li>(最基本地)将变量定义为const，用作常量。</li>
<li>函数参数定义成const引用，避免拷贝（const用来防止函数内部修改这个参数）。</li>
<li>类的const成员函数：这样类的const对象就能调用这个成员函数了，（原理是给this指针加上了底层const，否则的话，const对象的指针不能作为参数传递给隐含的this参数，因为this默认是没有底层const属性的，无法指向一个常量对象。）</li>
<li>关于<code>const_cast</code>，const_cast不是用来转换常量的，而是用来去掉本来不是常量的变量的底层const属性。</li>
<li>const更多是给人看的，不是给编译器看的。</li>
</ul>
<h2 id="c在执行main函数之前都做什么">C++在执行main函数之前都做什么</h2>
<ul>
<li>加载动态库</li>
<li>初始化全局变量和static变量（可以利用这个初始化的过程在构造函数中执行一些代码）</li>
</ul>
<h2 id="vector">vector</h2>
<ul>
<li>vector底层是什么数据结构<br>
连续的线性空间</li>
<li>vector的内存分配策略
<ul>
<li><strong>STL内存分配没有使用malloc/free，而是使用的是std::Allocator（实际上Allocator类就是对malloc和free做了一层封装），对象初始化使用&rsquo;placement new&rsquo;语法。</strong></li>
<li>预留空间，空间满了就扩为原来的两倍。</li>
<li>扩容时，是分配一块新的连续内存，原有的元素移动或拷贝到新的内存中，频繁扩容时会存在性能损失。</li>
</ul>
</li>
</ul>
<h2 id="c11中的新特性">c++11中的新特性</h2>
<p>我们通常把c++11之后的c++称为现代c++，以下是一些常见新特性</p>
<ul>
<li>语法
<ul>
<li>列表初始化
<ul>
<li>可以使用<code>initializer_list&lt;T&gt;</code>让一个类拥有列表初始化的能力</li>
</ul>
</li>
<li>范围for语句</li>
<li>using，新的类型别名声明，代替typedef</li>
<li>尾置返回类型，<code>auto func(int) -&gt; int(*)[10];</code></li>
</ul>
</li>
<li>类型、关键字
<ul>
<li>long long类型</li>
<li>nullptr常量</li>
<li>auto类型</li>
<li>constexpr
<ul>
<li>是一种在编译器求值的常量表达式（常量表达式，值为常量并且在编译过程就能得到计算结果）</li>
<li>可以定义constexpr变量，constexpr函数，字面值常量类（需要constexpr构造函数）</li>
</ul>
</li>
<li>decltype
<ul>
<li>作用是推断一个表达式的类型，并可以将返回值作为类型声明</li>
<li>和auto的区别是，当你不想要表达式的值，只想要表达式的类型时，可以使用decltype</li>
</ul>
</li>
</ul>
</li>
<li>类型转换
<ul>
<li>static_cast、dynamic_cast、reinterpret_cast</li>
</ul>
</li>
<li>面向对象
<ul>
<li>=default、=delete</li>
<li>explicit，防止隐式类型转换</li>
<li>虚函数的override</li>
<li>final阻止继承</li>
<li>move语义和右值引用</li>
<li>lambda表达式</li>
<li>bind，函数适配器</li>
</ul>
</li>
<li>内存管理
<ul>
<li>智能指针</li>
</ul>
</li>
<li>stl
<ul>
<li>unordered_map、unordered_set</li>
</ul>
</li>
</ul>
<h3 id="重要的特性">重要的特性</h3>
<ul>
<li>规范了初始化
<ul>
<li>直接初始化（祖传C特性）</li>
<li>值初始化<br>
类的值初始化和直接初始化是一样的；但是内置类型的值初始化和直接初始化是不同的，内置类型值初始化一定有一个值，但是内置类型的直接初始化还是老一套，全局的一定有值，非全局的必须得指定一个值才会直接初始化。</li>
<li>列表初始化<br>
涉及到标准库 <code>initializer_list</code>类型</li>
<li>类内初始化</li>
</ul>
</li>
<li>规范了类型转换（这个貌似不是C++11的新特性？）
<ul>
<li><code>static_cast</code>：通常意义上的类型转换</li>
<li><code>const_cast</code>：改变对象的底层const（例如一个const指针或const引用），<strong>不是用来将一个常量变成非常量</strong></li>
<li><code>dynamic_cast</code>：将一个基类的指针转换成其派生类的指针（派生类中必须有虚函数）<br>
这属于C++的运行时运行时类型识别的特性，例如有时我们想通过基类的指针去执行一个派生类的普通函数（不是虚函数）。</li>
<li><code>reinterpret_cast</code>：在位这一级别重新解释对象（其实就是把一个指针转换成另一个指针，但是非常灵活，甚至可以把一个整型值的地址拿出来转换成一个函数指针）。</li>
</ul>
</li>
<li><strong>右值引用、移动构造和移动赋值运算符</strong>
<ul>
<li>标准库<code>move</code>函数：强行获得一个非右值对象的右值引用。</li>
</ul>
</li>
<li>规范了对类的默认行为的控制
<ul>
<li><code>=default</code></li>
<li><code>=delete</code></li>
</ul>
</li>
<li><strong>智能指针</strong>：<code>shared_ptr</code>，<code>unique_ptr</code>，<code>weak_ptr</code></li>
<li><strong>可调用对象</strong>：
<ul>
<li>函数指针；</li>
<li>Lambda表达式；</li>
<li>函数对象（实现了函数调用运算符的对象）</li>
<li>标准库：
<ul>
<li>函数适配器<code>bind</code>：把一个可调用对象转换为另一个可调用对象</li>
<li><code>function</code>类型：给一个函数调用形式参数，接受相同调用形式的可调用对象。</li>
<li>标准库自定义的一系列可调用对象（算数、关系、逻辑）</li>
</ul>
</li>
</ul>
</li>
<li><strong>hash容器</strong>：<code>unordered_map</code>、<code>unordered_set</code></li>
<li><code>explicit</code>：强制显式类型转换
<ul>
<li>类的类型转换运算符：例如流对象通常能做条件表达式，就是因为流对象被转换成了<code>bool</code>类型。</li>
<li><code>explicit</code>有个例外就是如果表达式被用在条件里，隐式的转换还是会执行。</li>
</ul>
</li>
</ul>
<h3 id="新语法">新语法</h3>
<ul>
<li>Lambda表达式</li>
<li>列表初始化</li>
<li>范围for语句</li>
<li>auto</li>
<li>类型<code>using</code>声明：代替<code>typedef</code></li>
<li><code>explicit</code></li>
<li><code>override</code>、<code>final</code></li>
<li><code>thread_local</code>变量</li>
<li>函数的尾置返回类型：<code>auto func(int t) -&gt; int (*)[10];</code></li>
<li>类的委托构造函数：使用类内其他构造函数帮助完成自己的初始化过程</li>
</ul>
<h3 id="其他特性">其他特性</h3>
<ul>
<li><code>tuple</code>模板：类似<code>pair</code>，但是<code>tuple</code>的模板参数是可变的</li>
<li>C++11新的标准库：正则表达式库、随机数库、多线程库<code>std::thrad</code>以及<code>thread_local</code>变量。<code>thread_local</code>变量是线程内共享的变量。</li>
<li>两种新的顺序容器：<code>array</code>、<code>forward_list</code></li>
<li>容器的<code>emplace</code>成员函数：原地构造一个新对象，而不是把一个对象作为参数传递进去。</li>
<li><code>long long</code>类型</li>
<li><code>nullptr</code>常量</li>
<li><code>constexpr</code>变量和函数：编译器计算结果</li>
<li><code>auto</code>类型：编译期推断变量类型</li>
<li><code>decltype</code>类型：编译期推断decltype的参数的类型，并将<code>decltype</code>用于变量声明和定义</li>
<li>通过<code>cbegin()</code>和<code>cend()</code>获得常量迭代器</li>
<li>数组现在也可以使用<code>begin()</code>、<code>end()</code>系列函数获取指针了</li>
<li><code>allocator类</code>可以用来分配未初始化的内存（和<code>new</code>相对），还可以在未分配的内存上构造和析构对象，很灵活（但是这两个函数已经被C++20移除了，不知道出于什么原因）</li>
<li><code>sizeof</code>现在可以利用作用域运算符获取类成员大小了</li>
<li><code>namespace</code></li>
</ul>
<h2 id="类型转换">类型转换</h2>
<ul>
<li>static_cast，常规的类型转换</li>
<li>const_cast，改变对象的底层const</li>
<li>dynamic_cast，用于父子类指针和引用之间的转换，属于一种多态特性</li>
<li>reinterpret_cast，不会改变变量本身的值，而是在字节层面上把变量解释为另外一个类型</li>
</ul>
<h2 id="内存管理">内存管理</h2>
<ul>
<li>malloc、free</li>
<li>new、delete</li>
<li>operator new、operator delete</li>
<li>placement new</li>
</ul>
<h3 id="智能指针">智能指针</h3>
<ul>
<li>shared_ptr
<ul>
<li>make_shared，构造对象并创建智能指针，最安全</li>
<li>利用普通指针初始化shared_ptr，不安全
<ul>
<li>混用普通指针和shared_ptr会导致普通指针在用户不想释放的时候被shared_ptr释放</li>
<li>混用两个智能指针会导致两个智能指针单独计算引用计数，引发问题</li>
</ul>
</li>
<li>通过拷贝shared_ptr增加引用计数</li>
<li>reset，引用计数-1</li>
</ul>
</li>
<li>unique_ptr，不支持拷贝和赋值</li>
<li>weak_ptr，shared_ptr的弱引用，不会影响引用计数。不能直接访问数据，必须先使用lock方法获得shared_ptr，解决shared_ptr相互引用造成的资源不释放问题（属于一种内存泄漏）</li>
<li>RAII</li>
</ul>
<h3 id="allocator">allocator</h3>
<ul>
<li>stl中用来内存管理的类</li>
<li>stl容易一般都有一个模板参数Allocator，因为是个模板参数而不是函数参数，所以可以用自定义的allocator代替std::Allocator</li>
<li>allocator负责内存的分配和释放，对象的创建和销毁</li>
</ul>
<h2 id="面向对象">面向对象</h2>
<ul>
<li>拷贝控制
<ul>
<li>会默认生成的函数：默认构造、拷贝构造、拷贝赋值、析构函数</li>
</ul>
</li>
<li>初始化顺序
<ul>
<li>优先构造基类对象（按派生顺序构造）</li>
<li>然后构造成员对象（按声明顺序构造）</li>
</ul>
</li>
<li>成员能不能是引用类型？
<ul>
<li>能，但是
<ul>
<li>构造函数形参必须也是引用类型（否则永远只能获得一个局部变量的引用）</li>
<li>必须在构造函数的初始化列表里初始化</li>
</ul>
</li>
</ul>
</li>
<li>访问权限，public、private、protected
<ul>
<li>protected表示成员可以被派生类访问，但不公共可见</li>
<li><strong>private对派生类不可见</strong></li>
</ul>
</li>
<li>继承权限
<ul>
<li><strong>控制派生类的用户（包括派生类的派生类和类外部）对基类的访问权限，而不是控制派生类本身对基类的访问权限</strong></li>
<li>public，保留原来的权限</li>
<li>private，public和protected变为private</li>
<li>protected，public变为protected</li>
</ul>
</li>
<li>虚继承/虚基类
<ul>
<li>解决由多重继承引起的多基类实例问题</li>
<li>在继承类名前加上virtual</li>
</ul>
</li>
<li>多态性
<ul>
<li>虚函数
<ul>
<li>虚函数又叫动态多态</li>
<li>虚析构函数的必要性
<ul>
<li>使用基类指针指向派生类时，如果基类的析构函数不是虚函数，会导致无法调用派生类的析构函数</li>
<li>而虚构造会产生一个悖论，当对象没有实例化时，没有虚表指针，是无法调用虚构造函数的</li>
</ul>
</li>
<li>类A的对象a保存一个虚函数指针，虚函数指针指向类A的虚函数表，虚函数表保存了虚函数指针，指向的是实际调用函数地址，不同类的虚表中可能回复用同一个函数（类的继承导致的）</li>
<li>纯虚函数/抽象类
<ul>
<li>抽象类不能实例化</li>
<li>纯虚函数也不能实现，<code>virtual int func1() = 0;</code></li>
</ul>
</li>
<li>能否在构造函数和析构函数中调用虚函数？
<ul>
<li>可以，但是此时多态特性是失效的</li>
</ul>
</li>
</ul>
</li>
<li>重载
<ul>
<li>重载又叫静态多态，对调用函数的推断发生在编译器</li>
<li>重载实现原理，命名倾轧技术，在函数名上带上参数信息</li>
<li>普通函数重载、成员函数重载、重写、运算符重载、函数对象几种
<ul>
<li>仿函数（functor）是指函数对象</li>
</ul>
</li>
</ul>
</li>
<li>函数对象</li>
<li>lambda表达式，<code>[capture] (param) mutable noexcept/throw() -&gt; return type {};</code></li>
<li>bind函数适配器</li>
</ul>
</li>
<li>名字查找
<ul>
<li>作用域</li>
<li>命名空间</li>
<li>友元</li>
</ul>
</li>
</ul>
<h2 id="泛型">泛型</h2>
<ul>
<li>模板的实例化发生在编译期</li>
<li>模板实例化是指从函数模板/类模板生成一个真正的函数/类的过程
<ul>
<li>显式模板实参</li>
<li>模板实参推断</li>
</ul>
</li>
</ul>
<h2 id="stl">stl</h2>
<ul>
<li>stl中包括：容器、算法、迭代器、适配器、内存分配器allocator</li>
<li>vector</li>
<li>unordered_map、unordered_set</li>
<li>适配器
<ul>
<li>容器适配器，stack，queue</li>
<li>迭代器适配器，插入迭代器、移动迭代器、流迭代器、反向迭代器</li>
<li>函数适配器，bind</li>
</ul>
</li>
</ul>
<h2 id="隐式类型转换">隐式类型转换</h2>
<ul>
<li>内置类型的隐式类型转换</li>
<li>构造函数</li>
<li>类型转换运算符</li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li>extern &ldquo;C&rdquo;
<ul>
<li>导入c函数的关键字，它告诉编译器这段代码按c编译</li>
</ul>
</li>
<li>threadlocal
<ul>
<li>线程局部变量</li>
<li>要配合C++ thread标准库一起使用</li>
</ul>
</li>
<li>atomic
<ul>
<li>可以对基本类型封装原子操作</li>
</ul>
</li>
<li>mutable
<ul>
<li>可以把一个成员声明为可变的，操作成员的函数仍然能受到const保护</li>
</ul>
</li>
</ul>
<h2 id="c20">C++20</h2>
<ul>
<li>concept
<ul>
<li>和模板类型推断有关，可以用来约束模板实参的类型，<code>concept concept-name = expression</code></li>
</ul>
</li>
<li>modules</li>
<li>coroutine
<ul>
<li>无栈协程，无栈协程比有栈协程轻量</li>
<li>无栈协程本质上是一种可以暂停和恢复的函数</li>
<li>协程内部的三个关键字，co_await、co_yield、co_return
<ul>
<li>co_await和co_yield可以挂起协程</li>
<li>co_return返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="socket开发">socket开发</h2>
<ul>
<li>系统调用都是线程安全的，系统调用都是原子操作</li>
<li>socket，域 + socket类型 + 协议
<ul>
<li>IPv4域 + SOCK_STREAM 默认是tcp</li>
<li>IPv4域 + SOCK_DGRAM 默认是udp</li>
</ul>
</li>
<li>tcp
<ul>
<li>服务端，socket -&gt; bind -&gt; listen -&gt; accept</li>
<li>客户端，socket -&gt; bind -&gt; connect</li>
<li>数据传输，send，recv（read，write）</li>
<li>关闭socket，close</li>
<li>多线程读写需要给整个数据加锁，不能给单次发送加锁，单次发送可能会出现短读短写问题，因此多线程写socket还是会相互阻塞，没有意义</li>
</ul>
</li>
<li>udp
<ul>
<li>socket，bind</li>
<li>sendto，recvfrom</li>
<li>close</li>
<li>可以多线程同时读写同一个socket</li>
</ul>
</li>
</ul>
<h2 id="boost">boost</h2>
<p>boost库的定位是实验性质的库，里面的东西可能会在未来进入C++标准，但是在C++11之后，很多boost中的特性已经进入了C++，很多人开始禁止使用boost。</p>
<h2 id="grpc--brotobuf">grpc + brotobuf</h2>
<ul>
<li>grpc底层是tcp epoll模型</li>
<li>上层的通信协议是http + protobuf</li>
</ul>
<h2 id="函数调用约定">函数调用约定</h2>
<p>stdcall、cdecl、fastcall三者的区别</p>
<p>stdcall、cdecl、fastcall三种函数调用约定的区别如下：</p>
<ol>
<li>
<p><strong>cdecl（C Declaration）</strong></p>
<ul>
<li>参数从右到左入栈。</li>
<li>由<strong>调用者</strong>负责清理堆栈。</li>
<li>支持可变参数（如printf）。</li>
<li>是C默认的调用约定。</li>
</ul>
</li>
<li>
<p><strong>stdcall（Standard Call）</strong></p>
<ul>
<li>参数从右到左入栈。</li>
<li>由**被调用者（函数本身）**负责清理堆栈。</li>
<li>是C++标准调用约定。</li>
</ul>
</li>
<li>
<p><strong>fastcall</strong></p>
<ul>
<li>前两个参数通过寄存器（如ECX、EDX）传递，其余参数从右到左入栈。</li>
<li>由<strong>被调用者</strong>负责清理堆栈。</li>
<li>速度较快，减少了对栈的操作。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>cdecl：调用者清理栈，支持可变参数，默认约定。</li>
<li>stdcall：被调用者清理栈，不支持可变参数，常用于WinAPI。</li>
<li>fastcall：部分参数用寄存器传递，被调用者清理栈，效率</li>
</ul>
<h2 id="函数是如何调用的">函数是如何调用的</h2>
<p>单个函数调用操作所使用的栈部分被称为栈帧（stack frame）结构</p>
<p>存放所有函数调用链的内存区域称为“栈”，栈上的每个函数调用成为“帧”</p>
<p>栈的地址是从高地址向低地址增长的，栈顶的地址最低</p>
<p>这里涉及到两个指针，“栈指针”和“帧指针”，栈指针是栈上的一个全局指针，始终指向栈顶，帧指针是指向当前函数栈帧的指针</p>
<p>┌──────────────────────────────┐
│    &hellip;（上一个函数的栈帧）     │
├──────────────────────────────┤
│   参数n（最右边的参数）        │  ← esp（刚进入函数时）
│   &hellip;                        │
│   参数2                      │
│   参数1（最左边的参数）        │
├──────────────────────────────┤
│   返回地址（ret address）     │  ← call指令压入
├──────────────────────────────┤
│   上一个ebp（栈帧指针）        │  ← push ebp
├──────────────────────────────┤
│   局部变量                    │  ← sub esp, size
│   &hellip;                        │
└──────────────────────────────┘</p>
<p>函数调用和返回的过程主要依赖于栈（调用栈）来管理参数、返回地址和局部变量。以常见的 x86 平台为例，过程如下：</p>
<ol>
<li>
<p><strong>调用前准备</strong></p>
<ul>
<li>调用者将函数参数按调用约定（如从右到左）依次压入栈中。</li>
<li>调用者执行 <code>call</code> 指令，<code>call</code> 会将**下一条指令的地址（返回地址）**压入栈，然后跳转到被调用函数的入口。</li>
</ul>
</li>
<li>
<p><strong>进入函数</strong></p>
<ul>
<li>被调用函数通常会保存当前的栈帧指针（即上一个函数的帧指针），并为局部变量分配空间。</li>
<li>此时，栈上依次存放：参数、返回地址、上一个栈帧指针、局部变量。</li>
</ul>
</li>
<li>
<p><strong>函数执行</strong></p>
<ul>
<li>函数体内可以通过栈帧指针访问参数和局部变量。</li>
</ul>
</li>
<li>
<p><strong>函数返回</strong></p>
<ul>
<li>函数将返回值放到约定的寄存器。</li>
<li>恢复上一个栈帧指针。</li>
<li>执行 <code>ret</code> 指令，从栈顶弹出返回地址，跳转回调用者。</li>
</ul>
</li>
<li>
<p><strong>调用者收尾</strong></p>
<ul>
<li>调用者根据调用约定，自己或被调用者负责清理参数。</li>
<li>继续执行后续代码。</li>
</ul>
</li>
</ol>
<h2 id="局部变量的入栈顺序">局部变量的入栈顺序</h2>
<p>局部变量的入栈顺序是否和源码中的声明顺序一致，取决于是否有栈溢出保护机制，如果有栈溢出保护机制，局部变量在源码中的声明顺序和入栈顺序是相反的，即后声明的变量先入栈，这种情况下，先声明的变量位于栈上的低地址，后声明的变量位于栈上的高地址（栈地址是从高到低增长的）</p>
<h2 id="为啥函数栈被写坏了函数返回时被崩溃">为啥函数栈被写坏了，函数返回时被崩溃</h2>
<p>有一种场景是，函数栈写超了，由于写入时是往高地址写入的，而上一个函数的帧地址和返回地址恰好在函数局部数据内存区域的高地址处，函数栈写超了后会破坏掉上一个函数的帧地址和返回地址，导致函数返回时崩溃。</p>
<h2 id="顶层const和底层const的写法">顶层const和底层const的写法</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//底层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="k">const</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//顶层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//指针本身是常量，不能改变指向
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>注意，底层const写在<code>*</code>的左边，顶层const写在<code>*</code>的右边</strong>。</p>
<h2 id="cc程序的编译过程">C/C++程序的编译过程</h2>
<p>C/C++ 程序的编译过程一般分为四个主要阶段：<strong>预处理、编译、汇编、链接</strong>。</p>
<ol>
<li>
<p><strong>预处理（Preprocessing）</strong></p>
<ul>
<li>处理 <code>#include</code>、<code>#define</code>、<code>#ifdef</code> 等预处理指令，展开头文件、宏、条件编译，去除注释。</li>
<li>生成扩展名为 <code>.i</code> 的预处理文件。</li>
</ul>
</li>
<li>
<p><strong>编译（Compilation）</strong></p>
<ul>
<li>将预处理后的代码翻译为汇编代码，进行语法分析、语义分析和优化。</li>
<li>生成扩展名为 <code>.s</code> 的汇编文件。</li>
</ul>
</li>
<li>
<p><strong>汇编（Assembly）</strong></p>
<ul>
<li>将汇编代码翻译为机器指令，生成目标文件（object file），扩展名为 <code>.o</code> 或 <code>.obj</code>。</li>
<li>每个源文件对应一个目标文件。</li>
</ul>
</li>
<li>
<p><strong>链接（Linking）</strong></p>
<ul>
<li>将多个目标文件和库文件合并，解决符号引用，分配内存地址，生成可执行文件或库文件（如 <code>.exe</code>、<code>.so</code>、<code>.dll</code>）。</li>
<li>由链接器（如 <code>ld</code>）完成。</li>
</ul>
</li>
</ol>
<h2 id="gdb常用命令">gdb常用命令</h2>
<p>gcc编译的时候，要带上<code>-g</code>参数，表示编译时生成调试信息，这样才能在gdb中调试。</p>
<p>GDB（GNU Debugger）是Linux下常用的C/C++调试工具，常用命令如下：</p>
<ul>
<li><code>gdb ./a.out</code>  启动gdb并加载可执行文件</li>
<li><code>file [文件名]</code>  加载指定的可执行文件</li>
<li><code>kill</code>          终止当前调试的程序</li>
<li><code>run [参数]</code>    启动程序并传递参数</li>
<li><code>break [file:]位置</code>  设置断点（如<code>break main</code>、<code>break 23</code>）</li>
<li><code>info breakpoints</code>  查看所有断点</li>
<li><code>delete [编号]</code>    删除断点</li>
<li><code>disable/enable [编号]</code>  禁用/启用断点</li>
<li><code>next</code>/<code>n</code>        单步执行（不进入函数）</li>
<li><code>step</code>/<code>s</code>        单步执行（进入函数）</li>
<li><code>continue</code>/<code>c</code>    继续运行直到下一个断点</li>
<li><code>finish</code>          运行到当前函数返回</li>
<li><code>print [变量/表达式]</code>  打印变量或表达式的值</li>
<li><code>display [变量]</code>  每次停下时自动显示变量值</li>
<li><code>set var x=5</code>     修改变量值</li>
<li><code>backtrace</code>/<code>bt</code>  打印调用栈</li>
<li><code>info locals</code>     查看当前函数的所有局部变量</li>
<li><code>info args</code>       查看当前函数的参数</li>
<li><code>list [位置]</code>     查看源码</li>
<li><code>quit</code>/<code>q</code>        退出gdb</li>
</ul>
<h2 id="其他问题">其他问题</h2>
<p><strong>memset如何实现</strong></p>
<p>借助simd指令，并行执行</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2025-07-12&nbsp;<a class="git-hash" href="https://github.com/openjz/asteria/commit/7e7c16e56cfdc6ccb4dce9232c209fa9daee3f59" target="_blank" title="commit by shiwj(swj6086085@163.com) 7e7c16e56cfdc6ccb4dce9232c209fa9daee3f59: reorganize">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>7e7c16e</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/19.interview-bagu-cpp/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>,&nbsp;<a href="/tags/c/c&#43;&#43;/">c/c&#43;&#43;</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/18.webpage-print/" class="prev" rel="prev" title="打印html页面"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>打印html页面</a>
            <a href="/20.cpp-stl-algorithm-overview/" class="next" rel="next" title="c&#43;&#43;标准库算法概览">c&#43;&#43;标准库算法概览<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/openjz" target="_blank">shiwj</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp">津ICP备2020010292号-1</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
