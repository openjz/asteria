# 面试八股-c++


- threadlocal
- volatile

## static关键字的作用

- 全局静态变量  
  - 将全局变量声明为static可以使得全局变量只在当前文件内有效；
  - 实际上，对于全局变量，static修改了标识符的链接属性，由默认的external变为internal
  - C++11的匿名命名空间代替了这个功能；
  - **静态存储区**
  - 如果全局变量不加static，它也是静态的，只不过作用域是全局的，可以通过extern引入
- 局部静态变量
  - 在局部作用域中声明的static变量，例如函数中的static变量；
  - 局部静态变量从第一次执行定义时生效；
  - 即使函数结束执行，该变量也不会被销毁，只有程序结束后才销毁该变量；
  - **静态存储区**
- 类的静态成员变量
  - 属于类，不属于某个对象；
  - 使用`class::static_member`的方式调用；
  - 模板的静态成员属于每个模板实例；
  - 派生类的对象能访问基类的静态成员；
- 类的静态成员函数
  - 静态成员函数只能操作类的静态成员变量；
  - 不包含this指针，因此也不能声明为const；（静态成员函数不属于任何对象，因此也不包含this指针，没有this指针，自然也就不能指向const对象）；
- （静态函数）
  - 对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用。

## C++和C的区别

- C++是面向对象的语言，而C是面向过程的结构化编程语言
- C++具有封装、继承和多态三种特性
- C++相比C，增加多许多类型安全的功能，比如强制类型转换
- C++支持泛型编程，比如模板类、函数模板等

## C++内存布局

- 代码区（文本区）
- 数据区：已初始化的全局变量、静态变量
- BSS区：未初始化的全局变量区
- 堆区
- 栈区

## 各种指针

- 悬垂指针/空悬指针  
  指针指向的内存已经被释放了，指针本身还指向被释放的内存。
- 野指针  
  未初始化的指针（没有被初始化为nullptr），随即指向一块内存。
- 空指针  
  nullptr、NULL、0
- 内存泄漏  
  内存还没释放，指针弄没了。

## inline

- 早期的作用：**inline可以看作是给编译器的建议**，（1）编译器会根据函数的规模等指标决定是否把函数在调用处展开，例如函数是否被调用很多次、函数内部是否有for、switch、while等复杂的控制逻辑、函数是否递归等。（2）即使不加inline，在o3编译时，编译器有时也会自动将小函数内联，因此，**使用inline时首先考虑的并不应该是效率，而是其他东西**。
- 现在的作用：能让一个函数定义在头文件里

## const的作用

- (最基本地)将变量定义为const，用作常量。
- 函数参数定义成const引用，避免拷贝（const用来防止函数内部修改这个参数）。
- 类的const成员函数：这样类的const对象就能调用这个成员函数了，（原理是给this指针加上了底层const，否则的话，const对象的指针不能作为参数传递给隐含的this参数，因为this默认是没有底层const属性的，无法指向一个常量对象。）
- 关于`const_cast`，const_cast不是用来转换常量的，而是用来去掉本来不是常量的变量的底层const属性。
- const更多是给人看的，不是给编译器看的。

## C++在执行main函数之前都做什么

- 加载动态库
- 初始化全局变量和static变量（可以利用这个初始化的过程在构造函数中执行一些代码）

## vector

- vector底层是什么数据结构  
  连续的线性空间
- vector的内存分配策略  
  - 预留空间，空间满了就扩为原来的两倍。
  - **STL内存分配没有使用malloc/free，而是使用的是std::Allocator（实际上Allocator类就是对malloc和free做了一层封装），对象初始化使用'placement new'语法。**

## c++11中的新特性

我们通常把c++11之后的c++称为现代c++，以下是一些常见新特性

- 语法
    - 列表初始化
        - 可以使用`initializer_list<T>`让一个类拥有列表初始化的能力
    - 范围for语句
    - using，新的类型别名声明，代替typedef
    - 尾置返回类型，`auto func(int) -> int(*)[10];`
- 类型、关键字
    - long long类型
    - nullptr常量
    - auto类型
    - constexpr
        - 是一种在编译器求值的常量表达式（常量表达式，值为常量并且在编译过程就能得到计算结果）
        - 可以定义constexpr变量，constexpr函数，字面值常量类（需要constexpr构造函数）
    - decltype
        - 作用是推断一个表达式的类型，并可以将返回值作为类型声明
        - 和auto的区别是，当你不想要表达式的值，只想要表达式的类型时，可以使用decltype
- 类型转换
    - static_cast、dynamic_cast、reinterpret_cast
- 面向对象
    - =default、=delete
    - explicit，防止隐式类型转换
    - 虚函数的override
    - final阻止继承
    - move语义和右值引用
    - lambda表达式
    - bind，函数适配器
- 内存管理
    - 智能指针
- stl
    - unordered_map、unordered_set

### 重要的特性

- 规范了初始化
  - 直接初始化（祖传C特性）
  - 值初始化  
  类的值初始化和直接初始化是一样的；但是内置类型的值初始化和直接初始化是不同的，内置类型值初始化一定有一个值，但是内置类型的直接初始化还是老一套，全局的一定有值，非全局的必须得指定一个值才会直接初始化。
  - 列表初始化  
  涉及到标准库 `initializer_list`类型
  - 类内初始化
- 规范了类型转换（这个貌似不是C++11的新特性？）
  - `static_cast`：通常意义上的类型转换
  - `const_cast`：改变对象的底层const（例如一个const指针或const引用），**不是用来将一个常量变成非常量**
  - `dynamic_cast`：将一个基类的指针转换成其派生类的指针（派生类中必须有虚函数）  
  这属于C++的运行时运行时类型识别的特性，例如有时我们想通过基类的指针去执行一个派生类的普通函数（不是虚函数）。
  - `reinterpret_cast`：在位这一级别重新解释对象（其实就是把一个指针转换成另一个指针，但是非常灵活，甚至可以把一个整型值的地址拿出来转换成一个函数指针）。
- **右值引用、移动构造和移动赋值运算符**
  - 标准库`move`函数：强行获得一个非右值对象的右值引用。
- 规范了对类的默认行为的控制
  - `=default`
  - `=delete`
- **智能指针**：`shared_ptr`，`unique_ptr`，`weak_ptr`
- **可调用对象**：
  - 函数指针；
  - Lambda表达式；
  - 函数对象（实现了函数调用运算符的对象）
  - 标准库：
    - 函数适配器`bind`：把一个可调用对象转换为另一个可调用对象
    - `function`类型：给一个函数调用形式参数，接受相同调用形式的可调用对象。
    - 标准库自定义的一系列可调用对象（算数、关系、逻辑）
- **hash容器**：`unordered_map`、`unordered_set`
- `explicit`：强制显式类型转换
  - 类的类型转换运算符：例如流对象通常能做条件表达式，就是因为流对象被转换成了`bool`类型。
  - `explicit`有个例外就是如果表达式被用在条件里，隐式的转换还是会执行。

### 新语法

- Lambda表达式
- 列表初始化
- 范围for语句
- auto
- 类型`using`声明：代替`typedef`
- `explicit`
- `override`、`final`
- `thread_local`变量
- 函数的尾置返回类型：`auto func(int t) -> int (*)[10];`
- 类的委托构造函数：使用类内其他构造函数帮助完成自己的初始化过程

### 其他特性

- `tuple`模板：类似`pair`，但是`tuple`的模板参数是可变的
- C++11新的标准库：正则表达式库、随机数库、多线程库`std::thrad`以及`thread_local`变量。`thread_local`变量是线程内共享的变量。
- 两种新的顺序容器：`array`、`forward_list`
- 容器的`emplace`成员函数：原地构造一个新对象，而不是把一个对象作为参数传递进去。
- `long long`类型
- `nullptr`常量
- `constexpr`变量和函数：编译器计算结果
- `auto`类型：编译期推断变量类型
- `decltype`类型：编译期推断decltype的参数的类型，并将`decltype`用于变量声明和定义
- 通过`cbegin()`和`cend()`获得常量迭代器
- 数组现在也可以使用`begin()`、`end()`系列函数获取指针了
- `allocator类`可以用来分配未初始化的内存（和`new`相对），还可以在未分配的内存上构造和析构对象，很灵活（但是这两个函数已经被C++20移除了，不知道出于什么原因）
- `sizeof`现在可以利用作用域运算符获取类成员大小了
- `namespace`

## 类型转换

- static_cast，常规的类型转换
- const_cast，改变对象的底层const
- dynamic_cast，用于父子类指针和引用之间的转换，属于一种多态特性
- reinterpret_cast，不会改变变量本身的值，而是在字节层面上把变量解释为另外一个类型

## 内存管理

- malloc、free
- new、delete
- operator new、operator delete
- placement new

### 智能指针

- shared_ptr
    - make_shared，构造对象并创建智能指针，最安全
    - 利用普通指针初始化shared_ptr，不安全
        - 混用普通指针和shared_ptr会导致普通指针在用户不想释放的时候被shared_ptr释放
        - 混用两个智能指针会导致两个智能指针单独计算引用计数，引发问题
    - 通过拷贝shared_ptr增加引用计数
    - reset，引用计数-1
- unique_ptr，不支持拷贝和赋值
- weak_ptr，shared_ptr的弱引用，不会影响引用计数。不能直接访问数据，必须先使用lock方法获得shared_ptr，解决shared_ptr相互引用造成的资源不释放问题（属于一种内存泄漏）
- RAII

### allocator

- stl中用来内存管理的类
- stl容易一般都有一个模板参数Allocator，因为是个模板参数而不是函数参数，所以可以用自定义的allocator代替std::Allocator
- allocator负责内存的分配和释放，对象的创建和销毁

## 面向对象

- 拷贝控制
    - 会默认生成的函数：默认构造、拷贝构造、拷贝赋值、析构函数
- 初始化顺序
    - 优先构造基类对象（按派生顺序构造）
    - 然后构造成员对象（按声明顺序构造）
- 成员能不能是引用类型？
    - 能，但是
        - 构造函数形参必须也是引用类型（否则永远只能获得一个局部变量的引用）
        - 必须在构造函数的初始化列表里初始化
- 访问权限，public、private、protected
    - protected表示成员可以被派生类访问，但不公共可见
    - **private对派生类不可见**
- 继承权限
    - **控制派生类的用户（包括派生类的派生类和类外部）对基类的访问权限，而不是控制派生类本身对基类的访问权限**
    - public，保留原来的权限
    - private，public和protected变为private
    - protected，public变为protected
- 虚继承/虚基类
    - 解决由多重继承引起的多基类实例问题
    - 在继承类名前加上virtual
- 多态性
    - 虚函数
        - 虚函数又叫动态多态
        - 虚析构函数的必要性
            - 使用基类指针指向派生类时，如果基类的析构函数不是虚函数，会导致无法调用派生类的析构函数
            - 而虚构造会产生一个悖论，当对象没有实例化时，没有虚表指针，是无法调用虚构造函数的
        - 类A的对象a保存一个虚函数指针，虚函数指针指向类A的虚函数表，虚函数表保存了虚函数指针，指向的是实际调用函数地址，不同类的虚表中可能回复用同一个函数（类的继承导致的）
        - 纯虚函数/抽象类
            - 抽象类不能实例化
            - 纯虚函数也不能实现，`virtual int func1() = 0;`
        - 能否在构造函数和析构函数中调用虚函数？
            - 可以，但是此时多态特性是失效的
    - 重载
        - 重载又叫静态多态，对调用函数的推断发生在编译器
        - 重载实现原理，命名倾轧技术，在函数名上带上参数信息
        - 普通函数重载、成员函数重载、重写、运算符重载、函数对象几种
            - 仿函数（functor）是指函数对象
    - 函数对象
    - lambda表达式，`[capture] (param) mutable noexcept/throw() -> return type {};`
    - bind函数适配器
- 名字查找
    - 作用域
    - 命名空间
    - 友元

## 泛型

- 模板的实例化发生在编译期
- 模板实例化是指从函数模板/类模板生成一个真正的函数/类的过程
    - 显式模板实参
    - 模板实参推断

## stl

- stl中包括：容器、算法、迭代器、适配器、内存分配器allocator
- vector
- unordered_map、unordered_set
- 适配器
    - 容器适配器，stack，queue
    - 迭代器适配器，插入迭代器、移动迭代器、流迭代器、反向迭代器
    - 函数适配器，bind

## 隐式类型转换

- 内置类型的隐式类型转换
- 构造函数
- 类型转换运算符

## 其他

- extern "C"
    - 导入c函数的关键字，它告诉编译器这段代码按c编译
- threadlocal
    - 线程局部变量
    - 要配合C++ thread标准库一起使用
- atomic
    - 可以对基本类型封装原子操作
- mutable
    - 可以把一个成员声明为可变的，操作成员的函数仍然能受到const保护

## C++20

- concept
    - 和模板类型推断有关，可以用来约束模板实参的类型，`concept concept-name = expression`
- modules
- coroutine
    - 无栈协程，无栈协程比有栈协程轻量
    - 无栈协程本质上是一种可以暂停和恢复的函数
    - 协程内部的三个关键字，co_await、co_yield、co_return
        - co_await和co_yield可以挂起协程
        - co_return返回

## socket开发

- 系统调用都是线程安全的，系统调用都是原子操作
- socket，域 + socket类型 + 协议
    - IPv4域 + SOCK_STREAM 默认是tcp
    - IPv4域 + SOCK_DGRAM 默认是udp
- tcp
    - 服务端，socket -> bind -> listen -> accept
    - 客户端，socket -> bind -> connect
    - 数据传输，send，recv（read，write）
    - 关闭socket，close
    - 多线程读写需要给整个数据加锁，不能给单次发送加锁，单次发送可能会出现短读短写问题，因此多线程写socket还是会相互阻塞，没有意义
- udp
    - socket，bind
    - sendto，recvfrom
    - close
    - 可以多线程同时读写同一个socket

## boost

boost库的定位是实验性质的库，里面的东西可能会在未来进入C++标准，但是在C++11之后，很多boost中的特性已经进入了C++，很多人开始禁止使用boost。

## grpc + brotobuf

- grpc底层是tcp epoll模型
- 上层的通信协议是http + protobuf



