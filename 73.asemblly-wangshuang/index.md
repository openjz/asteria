# 《汇编语言第4版——王爽》阅读笔记


## 一、基础知识

汇编指令是机器指令便于记忆的书写格式

汇编语言有三类符号：

1. 汇编指令
2. 伪指令，没有对应的机器码，由编译器识别，在编译期计算
3. 符号

CPU和内存之间存在三类总线：地址线，数据线和控制线

**字（word）和字节（byte）**

一个字由两个字节组成，共16位，一个字分为高位字节和低位字节

## 二、寄存器

8086CPU有14个寄存器，这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW，这些寄存器分为：

1. 4个通用寄存器：AX、BX、CX、DX
2. 4个段寄存器：CS、DS、SS、ES
3. 指针寄存器：SP、BP、SI、DI

### 通用寄存器

8086 cpu的通用寄存器有4个，每个寄存器16位

一个通用寄存器可以分为两个8位寄存器来使用，高位部分用`H`后缀表示，低位部分用`L`后缀表示。例如，AX可以分为AH和AL

### 几条基本汇编指令

```asm
MOV AX, 18 ; 将18存入AX寄存器
ADD AX, 2  ; 将2加到AX寄存器

MOV BX, AX ; 将AX寄存器的值复制到BX寄存器
MOV AL, BL ; 将BX寄存器的低位字节复制到AX寄存器的低位字节
```

### 段的概念

段地址 + 偏移地址 = 物理地址

为什么需要两级地址？这跟8086 cpu的处理能力有关，8086 CPU的地址线有20根，但寄存器只有16位，不得不采用两级地址拼接的方式来访问内存。

### 段寄存器

段寄存器用于存储内存的段地址，8086 CPU有4个段寄存器：CS、DS、SS、ES

### CS和IP

CS（代码段寄存器）和**IP（指令指针寄存器）**合起来就是CPU当前执行的指令地址。

### 修改CS、IP的jmp指令

`jmp 段地址:偏移地址`

指令中给出的段地址修改CS寄存器的值，偏移地址修改IP寄存器的值

`jmp 某一寄存器`

仅修改IP寄存器的值

## 三、内存访问

数据的访问也遵循段地址+偏移地址的方式

DS寄存器存储数据的段地址

以下代码将内存地址10000H(1000:0)中的数据读取到寄存器al中

```asm
mov bx, 1000H
mov ds, bx
mov al, [0]
```

数据的段地址存放在ds寄存器中，往al中存放数据时只需要提供偏移地址`[0]`即可

`[address]`表示内存偏移地址

上面的例子只从内存中读取了一个字节，如果mov指令中给定的是16位寄存器，则会从内存中读取一个16位的字

sub指令用于减法，例如：

```asm
SUB AX, 1 ; 将AX寄存器的值减1
SUB BX, AX ; 用BX寄存器的值减去AX寄存器的值，结果存回BX
```

### CPU的栈机制

栈会占用一段内存地址

入栈出栈指令

```asm
push ax ; 将ax的数据入栈
pop ax; 将栈顶数据读入ax中
```

栈顶地址存储在段寄存器SS和**栈顶指针寄存器SP**中，也是段地址+偏移地址的形式

**栈底地址大，栈顶地址小，所以push会使SP变小，pop会使SP变大**

如何将某一部分内存指定为栈内存呢？很简单，将SS和SP设置为栈底地址即可

## 四、一个汇编程序

### 伪指令

伪指令由编译器分析执行，而不是由CPU执行

代码段定义

```asm
codesg segment; 代码段的名字位codesg
...
cosesg ends
```

汇编结束

```asm
... 
end
```

assume指令能够将段寄存器和某一个代码段关联起来

### 程序

汇编代码中真正被CPU执行的部分

### 标号

由程序员自定义的名字

### 程序返回

```asm
mov ax, 4c00h
int 21h
```

## 五、`[BX]`和loop指令

`[bx]`也表示内存单元，它的地址存放在bx寄存器中

loop代表循环，写法如下

```asm
mov cx, 循环次数
s:
    循环执行的程序段
    loop s ; 循环到s标号处
```

loop需要和寄存器cx配合，每次执行loop指令，cx寄存器的值会减1，当cx为0时，loop指令不再跳转

s是一个标号，loop指令会跳转到s处

什么时候会用到类似`[bx]`这种用法呢？如果要在loop中使用内存访问，而内存地址不断在变化的时候

`inc`是增加1的指令

访存时可以显式给出段地址和偏移地址，例如`ds:[0]`，其中`ds`叫段前缀

### 六、包含多个段的程序


