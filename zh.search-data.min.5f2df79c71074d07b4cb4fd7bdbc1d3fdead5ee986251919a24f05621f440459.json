[{"id":0,"href":"/posts/gopl/","title":"golang入门笔记","section":"Posts","content":"golang入门笔记 #  参考《Go程序设计语言》\n一、程序结构 #   go程序使用驼峰式命名风格 零值，变量的初始值。数字是0，字符串是\u0026quot;\u0026quot;，布尔值是false，接口（interface）和引用类型（slice、指针、map、通道、函数）是nil，数组和结构体的零值是其所有元素或成员的零值 短变量声明，a,b := f()，a和b中至少有一个得是新变量，不能全是已经声明的变量  一个例外，如果a,b是在外层作用域声明的，:=会将它们声明为新变量   指针。函数返回局部变量的地址是安全的（见 6.变量的生命周期） new函数，new函数创建一个新值并返回其地址 变量的生命周期通过其是否可达确定（变量可以在其初次声明的作用域之外存活），编译器根据变量生命周期确定变量在栈上还是堆上分配，而不是根据声明变量的时候使用的是var还是new 多重赋值，例如a,b := 1,\u0026quot;xxx\u0026quot;或x,y = y,x，后者用来交换变量的值 类型转换，var a T = T(b)，每个类型都会提供T(x)将x的值转换为T（前提是允许这种转换） 导出的标识符才能在包外被访问到，导出的标识符以大写字母开头 包初始化，从初始化包级别变量开始，优先按照依赖顺序初始化变量，然后按照声明顺序初始化变量 init函数，可以有任意个，在程序启动时按照声明顺序自动执行 包的初始化按导入顺序进行，依赖顺序优先（类似包级别变量初始化）  二、基本数据 #  2.1 整型 #   int8、int16、int32、int64、uint8、uint16、uint32、uint64 int和uint，在不同平台上大小不同（通常是32位或64位） rune，等价于int32，表示一个unicode码点 byte，等价于uint8，表示一个原始的字节 uintptr，可以存放一个指针，用于底层编程 golang中%运算结果的正负号总是和被除数一致 位运算。\u0026amp;是与运算（AND），|是或运算（OR），^是异或和非运算（XOR，NOT），\u0026amp;^是与非运算（AND NOT），\u0026lt;\u0026lt;是左移，\u0026gt;\u0026gt;是右移  1和a做异或等价于对a取反，即1^a = ^a（这里的1和a是单独的一位） 与非运算的作用是按右操作数的位分布清空左操作数中的对应位 右移操作\u0026gt;\u0026gt;  有符号数右移按符号位填补空位（因为移的是补码，补码补1就等于原码补0） 右移操作x\u0026gt;\u0026gt;n等价于x/2^n，向下取整（朝负无穷方向取整，例如-5\u0026raquo;1结果为-3）      "},{"id":1,"href":"/posts/db_transaction/","title":"数据库事务","section":"Posts","content":"数据库事务 #  事务（transaction）的目的是要保证一连串数据操作的原子性，并能够支持操作回滚\n事务的并发问题 #   脏读：当前事务可以读取到其他事务未提交的数据 不可重复读：当前事务前后两次使用相同的查询语句查到了不同的数据，原因是在事务执行过程中，有其他事务对这批数据做了增删改操作。如果当前事务的两次读操作分别发生在其他事务开始前和提交后，读到的数据不一致，这就不算脏读，属于不可重复读问题。 幻读：事务进行读操作发现数据不存在，试图插入数据，但是插入失败，或者事务发现数据存在，试图更新数据，但更新失败，原因是事务读数据后，有其他事务对数据做了增删操作。即使数据库能够保证不发生脏读和不可重复读,仍有可能发生幻读，现象是每次读数据结果都是不存在，但就是不能插入数据，或者是每次读数据结果都是存在，但就是更新不了。  "},{"id":2,"href":"/posts/cold_heat_sweat/","title":"冷热和出汗是怎么回事","section":"Posts","content":"冷热和出汗是怎么回事 #  本文参考各种网络内容\n人是如何感觉到冷热的 #  人体有两个温度，核心温度和体表温度。核心温度是指人体内的温度，作为恒温动物，人体的核心温度是相对恒定的，一般在37度左右。体表温度是指人体表面的温度，也是人体感知到的温度。人体皮肤神经纤维中，有许多外周温度感受器，分为冷觉感受器和热觉感受器。一般来说，体表温度在30-35摄氏度时，人体不会有冷热的感觉，当体表温度低于30摄氏度时（此时外界温度可能在20摄氏度以下），会产生冷觉，当体表温度高于35摄氏度时，会产生热觉。\n还有另外一种说法，人感觉到的不是温度，而是温度变化。但是这个说法禁不起推敲，假如一个人连续一个月都位于三十七八摄氏度的环境中，那么这个人一定是一直感觉到热的，难道他的体表温度连续一个月都在增加吗？所以这种说法是有问题的。\n出汗是怎么回事 #  出汗是人体的一种散热手段。\n医学上有一个“体温调定点”理论，这个理论认为，人体下丘脑的体温调节中枢有一个体温调定点，当核心温度小于体温调定点时，人体会发热，反之人体会散热。\n为什么发烧的时候会感觉到冷 #  有两种说法，一种说法认为发烧的时候人体为了提高核心温度，会收缩皮肤表层血管，导致体表温度降低，所以人体会感觉到冷。另外一种说法是，人体为了提高核心温度，会调高体温调定点，这时大脑就会让人感觉到冷。（所以到底那种说法是正确的？）\n"},{"id":3,"href":"/posts/mysql-note/","title":"mysql入门笔记","section":"Posts","content":"mysql入门笔记 #  参考《mysql必知必会》\n一、基本概念 #  模式（schema）：这个概念比较模糊，一个比较常见的定义是，schema是指数据库对象的集合，其中包括表、视图、存储过程、索引等。schema通常是指数据库或表的布局和结构等信息。\n主键（primary key）：主键定义在表的一列上，用来唯一地标识每一行，因此主键的值不能重复，每一行对应的主键值都是唯一的。\n 主键有几个使用习惯，（1）不更新主键，（2）一般把主键定义在自增id列上\n 外键（foreign key）：外键是表中的一个字段，对应另一个表的主键。\n 可伸缩性（scale），一个设计良好的数据库能够良好应对数据量的增加，我们把这种情况称为数据库的可伸缩性好，可伸缩性离不开外键的使用。\n  检索性能可能会受多种因素影响：检索操作（子查询、联表查询\u0026hellip;），数据量，是否有索引或键\n 子句（clause）：SQL由子句构成，例如from、order by等。\n完全限定列名：表名.列名，video.md5\n二、mysql工具 #  mysql安装包中自带一个命令行工具mysql，这是一个运行在命令行的mysql客户端。\n 命令用;或\\g结束，\\G可以使横向表格纵向输出 输入help或\\h查看帮助 输入quit或exit退出  mysql默认端口是3306\n三、使用mysql #  一些关于数据库和表的命令：\n 选择数据库：use xxx; 查看（show）  所有数据库：show databases; 所有表：show tables; 表的列：show columns from xxx;  和desc xxx;作用相同   服务器状态：show status; 权限：show grants; 数据库和表的创建语句：show create database/table xxx; 服务器错误和告警：show errors/warnings; help show    四、检索（select） #  简单select #  selectfield1fromtable_hello;selectfield1,field2,field3fromtable_hello;select*fromtable_hello;字段前面可以加上表名，例如\nselecttable_hello.field1fromtable_hello;distinct #  selectdistinctfieldfromtable_hello;selectdistinctfield1,field2fromtable_hello;功能：\n 只检索单个字段时，列出字段所有可能的取值 检索多个字段时，列出两个字段取值的笛卡尔积  limit #  返回前n行\nselectfieldfromtable_hellolimitn;返回m行，从第n行开始（行号从0开始）\nselectfieldfromtable_hellolimitn,m;-- 或 selectfieldfromtable_hellolimitmoffsetn;排序（order by子句） #  按单个列或多个列排序\nselectfield1fromtable_helloorderbyfield2;selectfield1fromtable_helloorderbyfield2limit5;selectfield1fromtable_helloorderbyfield1,field2; limit要放在order by后面（先排序、再选行） 按多个列排序时，先按前面的列排，值相同时，再按后面的列排 同时使用order by和limit时，order by在前，limit在后  排序方向（升序/降序）\n 升序（asc）：默认是升序 降序（desc）：order by field2 desc  desc只对一个列有效，对多个列排序时，必须在想降序排的列后面都加上desc，例如：\nselectfield1fromtable_helloorderbyfield1desc,field2;五、过滤条件（where） #  操作符：\n =、!=(也可以用\u0026lt;\u0026gt;表示不等于) \u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;= between，检索字段值位于一个范围内的数据 is null，检查字段值为null的数据 and、or，and优先级高于or，可以用括号调整优先级 in，后面跟着一个值列表，例如(1,3,5) not，对后面的所有条件取反 like，利用通配符匹配 regexp，利用正则表达式，匹配  between例子：\n-- 查找值为2~4的数据 select*fromtable_videowheremaudit_statusbetween2and4;-- 或 select*fromtable_videowheremaudit_timebetween\u0026#34;2022-01-02 00:00:00\u0026#34;and\u0026#34;2022-01-03 00:00:00\u0026#34;;not例子：\nselect*fromtable_videowheremaudit_statusnotin(2,3);-- 或 select*fromtable_videowheremaudit_timebetween\u0026#34;2022-01-02 00:00:00\u0026#34;and\u0026#34;2022-01-03 00:00:00\u0026#34;;通配符 #  通过like关键字使用通配符匹配\n%，匹配任意字符出现任意次数（包括0次）\n_，下划线，匹配一个任意字符（出现一次，不多不少）\n正则表达式 #  mysql仅支持正则表达式的一个很小的子集\n正则表达式是本身是字符串，因此使用转义字符时要先转义一次\\，所以最终使用转义字符的时候，总是要写\\\\\nmysql使用[[:\u0026lt;:]]和[[:\u0026gt;:]]匹配单词的开头和结尾，类似\\b\n六、计算字段（临时生成的字段） #  计算字段在select语句中创建（计算字段是指经过计算后得到的临时字段）\n1. 拼接字段 concat() #  很多dbms使用+或||拼接字段，mysql必须使用concat()函数\n例如，select concat(name, '(', status, ')') from table_user order by name limit 3; 将字段name和status拼接成name(status)的形式，会产生以下输出：\n+--------------------------------+ | concat(name, '(', status, ')') | +--------------------------------+ | 000007e(2) | | 00000b0(4) | | 0000253(2) | +--------------------------------+ 可以使用ltrim()、rtrim()、trim()删除数据左侧、右侧和两侧的空白符\n可以使用as关键字为新字段赋予别名，例如select concat(name, '(', status, ')') as new_name ...\n2. 算术计算 #  包括加减乘除和圆括号\nselect field1*field2 as new_name from ...\n七、数据处理 #  使用函数进行数据处理\n 文本处理函数：  去除空白符：trim、ltrim、rtrim 大小写转换：upper、lower 字符串长度：length 定位子串起始下标：locate 查找子串：substring 从左边或右边起获取子字符串：left、right 获取字符串的发音：soundex   日期和时间处理函数：  时间和日期计算（加减天数，或加减时分秒）：  adddate, date_add, subdate, date_sub addtime, subtime datediff   格式化：date_format(date,format)，参数date是合法的日期时间，format是日期/时间的输出格式, 例如： mysql\u0026gt;SELECTDATE_FORMAT(\u0026#39;1997-10-04 22:23:00\u0026#39;,\u0026#39;%H %k %I %r %T %S %w\u0026#39;);\u0026#39;22 22 10 10:23:00 PM 22:23:00 00 6\u0026#39; 获得当前日期/时间：now, curdate, curtime 返回一个日期时间的特定部分：date, day, dayofweek, hour, minute, month, second, time, year   数值处理  cos, sin, tan, pi abs, exp, sqrt, mod, rand    八、汇总数据（数据聚合，aggregate） #  上面的介绍的数据处理函数是对单条数据的处理。数据聚合是要对表中多条数据进行汇总，比如计算行数，求均值等。\n聚集函数运行在整个表上，返回单个值，常用聚集函数有：\n avg: 计算均值。select avg(price) as avg_price where id=1003 count: 计数。count(*)计算行数，无论行中是否有null值。count(column)对特定列有值的行计数，略过null值。 max、min: 返回指定列中的最大值和最小值 sum: 返回指定列的和。也可以对计算字段求和，例如select sum(price*quantity) as total_price  字段前面可以带参数，select avg(PARAM field) as tmp，参数要放在PARAM的位置，默认参数是all，另外一种参数是distinct，它们的区别是，all对全部行进行聚集，distinct对该列的每个取值只统计一次。\n可以在单条语句中执行多个聚集计算，select avg(f1) as tmp1, min(f2) as tmp2...\n1.对数据分组（group by） #  假设有表staff\nid name dept salary edlevel hiredate 1 张三 rd 2000 3 2009-10-11 2 李四 rd 2500 3 2009-10-01 3 王五 qa 2600 5 2010-10-02 4 王六 qa 2300 4 2010-10-03 5 马七 qa 2100 4 2010-10-06 6 赵八 pm 3000 5 2010-10-05 7 钱九 pm 3100 7 2010-10-07 8 孙十 pm 3500 7 2010-10-06 执行以下sql\nSELECTdept,edlevel,MAX(salary)ASmaxsalFROMstaffWHEREhiredate\u0026gt;\u0026#39;2010-01-01\u0026#39;GROUPBYdept,edlevelORDERBYdept,edlevel;结果\ndept edlevel maxsal qa 4 2300 qa 5 2600 pm 5 3000 pm 7 3500 group by用于对数据进行分组，规则如下：\n group by必须位于where和order by之间 group by后面可以跟多个列或表达式（但不能是聚集函数），结果按笛卡尔积展示 group by后面跟的每个列必须都写到select后面 如果select语句中同时有字段和聚集函数，则sql中必须使用group by  2.过滤分组（having） #  having类似where，where对行进行过滤，having对分组进行过滤，例如：\nselectcust_id,count(*)asordersfromproductsgroupbycust_idhavingcount(*)\u0026gt;=2;九、select子句顺序 #  select - from - where - group by - having - order by - limit\n十、子查询（select嵌套） #  涉及到多个表时可能会用到子查询。子查询嵌套太多会导致性能问题。\n例一：利用子查询进行过滤\nselectcust_idfromorderswhereorder_numin(selectorder_numfromorderitemswhereprod_id=\u0026#34;TNT2\u0026#34;);应该保证where中的列和子查询中select的列保持一致\n例二：将子查询作为字段\nselectcust_name,(selectcount(*)fromorderswhereorders.cust_id=customers.cust_id)asordersfromcustomers;该子查询对从customers表中检索出的每行一次（即，先检索customers表，对检索出的每一行，执行子查询）。这种子查询被称为相关子查询（correlated subquery）\n十一、联结表（联表，join） #   数据库设计中经常需要配合使用多张互相关联的业务表，目的是降低冗余和解耦\n联结是sql执行过程中建立的，表定义中并不存在联结\n 例一，使用where子句建立联结，如果没有联结条件，会返回笛卡尔积\nselectvend_name,prod_name,prod_pricefromvendors,productswherevendors.vend_id=products.vend_idorderbyvend_name,prod_name;例一这种联结也被称为内部联结，也可以写为\nselectvend_name,prod_name,prod_pricefromvendorsINNERJOINproductsONvendors.vend_id=products.vend_id;例二，联结多个表\nselectvend_name,prod_name,prod_price,quantityfromorderitems,vendors,productswherevendors.vend_id=products.vend_idandorderitems.prod_id=products.prod_idandorder_num=20005;1.内部联结（等值联结） #  见上例\n2.自联结 #  表别名：as关键字同样可以给表指定别名\n例子：根据某产品id找出生产该产品的厂家生产的其他产品\nselectp1.prod_id,p1.prod_namefromproductsasp1,productsasp2wherep1.vend_id=p2.vend_idandp2.prod_id=\u0026#39;DTNTR\u0026#39;;3.自然联结 #  自然联结是指检索结果中没有重复的列(不是行)，可以使用通配符让系统自动去掉重复的列，一般是对某个表使用通配符，然后手动指定其他表中的列，例如：\nselectc.*,o.order_num,o.order_dateoi.prod_id,oi.quantity,oi.item_pricefromcustomersasc,ordersaso,orderitemsasoiwherec.cust_id=o.cust_idandoi.order_num=o.order_numandprod_id=\u0026#39;FB\u0026#39;;4.外部联结 #  与内部联结不同，外部联结的执行结果中包含没有产生关联的行。例如，下面这个sql想按客户id（cust_id）建立关联，检索出客户和订单的关系，并要求结果中包含没有订单的客户。\nselectcustomers.cust_id,orders.order_numfromcustomersLEFTOUTERJOINordersONcustomers.cust_id,orders.cust_id关键字：\n left outer join：left要求结果中包含outer join左边表中的无关联行 right outer join：结果中包含右边表中的无关联行  5.联结中带聚集函数 #  selectcustomers.cust_name,customers.cust_id,count(orders.order_num)asnum_ordfromcustomersleftouterjoinordersoncustomers.cust_id=orders.cust_idgroupbycustomers.cust_id;以上sql的作用是：获得所有客户的订单数，包括哪些没有订单的客户\n十二、组合查询（union） #  同时执行多个select，并将结果作为单个查询结果集返回。例如\nselectvend_id,prod_id,prod_pricefromproductswhereprod_id\u0026lt;=5unionselectvend_id,prod_id,prod_pricefromproductswherevend_idin(1001,1002);union的规则：\n union中的每个查询必须包含相同的列、表达式或聚集函数 union会自动对返回的行去重，如果不想去重，要使用union all 只能有一个order by，必须放在最后一个select之后。  十三、全文本搜索 #   mysql通过建立全文索引（倒排索引）来支持全文搜索。\n 建表时指定全文检索：\ncreatetabledemo{...some_wordstextnull,...fulltext(some_words)}engine=MyISAM;使用函数 match 和 against 进行全文搜索，match 指定要匹配的列，against 指定要使用的搜索表达式。例如\nselectnode_textfromproductnodeswherematch(node_text)against(\u0026#39;rabbit\u0026#39;);搜索不区分大小写。搜索结果默认以匹配接近程度进行排序。\nmatch和against的计算结果实际上是一个匹配等级值，表示匹配的接近程度，例如\nselectnode_text,match(node_text)against(\u0026#39;rabbit\u0026#39;)asmatchrankfromproductnodes;查询扩展：放宽搜索范围，搜索结果中可能不包含指定的检索词，例如select node_text, match(node_text) against('rabbit' with query expansion) as matchrank from productnodes;\n布尔文本搜索：against('xxx' in boolean mode)，性能较差，可以不需要fulltext索引。可以指定要匹配的词，要排斥的词，匹配优先级等。\n十四、数据的插入、删除和更新（增删改） #  1.插入 #  简单写法：insert into customers values(null,'xxx','xxx',null);，各个列必须以它们在表定义中的顺序填充\n复杂写法：指定要插入的列\ninsertintocustomers(name,address,city)values(\u0026#39;123\u0026#39;,\u0026#39;asd\u0026#39;,null);可以给多组value，例如，values('xxx','xxx'),('222',NULL);\n插入检索出的数据，例如，insert into table1(xx,xx,xx) select xx,xx,xx from table2 where...;\n2.更新 #   更新操作一定要带上条件，否则就会更新全表\n updatetablenamesetcust_email=\u0026#39;xxxx\u0026#39;,cust_name=\u0026#39;sss\u0026#39;wherecust_id=2345;可以在update语句中使用子查询\nignore关键字：update默认的逻辑是只要有一行数据更新失败就失败，ignore可以跳过更新失败的行，继续更新其他行\n3.删除 #   删除操作一定要带上条件，否则就会删除表中的所有数据\n delete from customers where cust_id = 1234;\n删除全表：truncate table tablename，实际上是直接把表删除后再新建一个表\n十五、创建和操作表 #  1.创建表 #  查看数据库和表的创建语句：show create database/table xxx;\ncreate语句：\nCREATETABLEifnotexists`table_video`(`id`bigint(20)unsignedNOTNULLAUTO_INCREMENTCOMMENT\u0026#39;自增id\u0026#39;,`object_name`varchar(64)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;bos上存储的文件名字\u0026#39;,`convert_status`tinyint(4)NOTNULLDEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;转码状态\u0026#39;,`thumb_status`tinyint(4)NOTNULLDEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;封面状态\u0026#39;,`maudit_status`tinyint(4)unsignedNOTNULLDEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;status of machine audit\u0026#39;,`origin_bos_url`varchar(510)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;原始文件的bos_url\u0026#39;,`source_url`varchar(510)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;原始文件转码后的url\u0026#39;,`thumb_url`varchar(510)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;缩略图url\u0026#39;,`src_create_time`timestampNOTNULLDEFAULT\u0026#39;0000-00-00 00:00:00\u0026#39;COMMENT\u0026#39;创建任务时间 -- DSP推入时间\u0026#39;,`src_update_time`timestampNOTNULLDEFAULT\u0026#39;0000-00-00 00:00:00\u0026#39;COMMENT\u0026#39;更新任务时间 -- 仅仅标识DSP重新推入时间\u0026#39;,`convert_time`timestampNOTNULLDEFAULT\u0026#39;0000-00-00 00:00:00\u0026#39;COMMENT\u0026#39;转换完成时间 -- 转换完成时间\u0026#39;,`thumb_time`timestampNOTNULLDEFAULT\u0026#39;0000-00-00 00:00:00\u0026#39;COMMENT\u0026#39;封面状态修改时间\u0026#39;,`maudit_time`timestampNOTNULLDEFAULT\u0026#39;0000-00-00 00:00:00\u0026#39;COMMENT\u0026#39;timestamp of machine audit info update\u0026#39;,`maudit_result`varchar(4096)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;result of machine audit, json string\u0026#39;,`video_info`varchar(4096)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;video info, json string\u0026#39;,PRIMARYKEY(`id`),UNIQUEKEY`object_name`(`object_name`),KEY`idx_src_create_time`(`src_create_time`),KEY`idx_src_update_time`(`src_update_time`))ENGINE=InnoDBAUTO_INCREMENT=3425436DEFAULTCHARSET=utf8COMMENT=\u0026#39;视频表\u0026#39;;规则：\n 主键可以是多个列，例如，PRIMARY KEY (id1,id2) 每个表只允许一列auto_increment，并且该列必须能被索引（一般是把这列设置为主键） 不允许使用函数作为默认值，只能用常量 外键不允许跨引擎  2.修改表 #  altertablexxxaddphone_numchar(20);--增加列 altertablexxxdropcolumnphone_num;--删除列 altertablexxxaddconstraintxxx_fkforeignkey(vend_id)referencesvendors(id);--添加一个外键约束（在vend_id这一列上，添加一个名为xxx_fk的外键约束） ALTERTABLEstudentsDROPFOREIGNKEYfk_class_id;-- 删除外键约束 droptablexxx;--删除表 renametablexxxtoxxx2;--重命名表 十六、视图 #  视图是虚拟的表，它只是把查询封装了一下，里面并不包含数据，因此使用视图时要注意性能问题。可以利用视图简化复杂的联结查询\n视图操作：\n create view, drop view, create or replace view show create view xxx, 查看创建视图的语句  十七、存储过程 #  存储过程把一系列操作封装在一起。可以在存储过程中加入事务。\ncreateprocedurexxx()beginselectxxxfromxxx;end;如果是在mysql命令行客户端使用该语句，要对命令结束符做临时修改，例如:\ndelimiter//createprocedurexxx()beginselectxxxfromxxx;end//delimiter;执行存储过程：call xxx();\n删除存储过程：drop procedure (if exists) xxx;\n查看存储过程创建语句：show create procedure xxx;\n查看存储过程信息：show procedure status (like 'procedure_name');\n1.参数和变量 #  所有mysql变量都必须以@开头\n定义一个用户变量：set @num=1;或set @num:=1;\n定义存储过程时带参数：\n-- in/out/inout分别对应输入变量、输出变量和输入输出变量 createprocedurexxx(invalue1int,outvalue2decimal(8,2),inoutvalue3boolean)comment\u0026#39;This is a comment\u0026#39;beginselectxxxintovalue2from...;end;执行存储过程：\ncallxxx(20,@v2,@v3);获取存储过程的输出：\nselect@v2,@v3;可以在存储过程中写逻辑：\ndeclarexxxintdefault6;declarexxx2booleandefaultfalse;ifxxx2then...endif;2.游标 #  mysql游标只能用于存储过程和函数。游标可以用来从select返回的结果集中一行一行地取数据。\n3.触发器 #  触发器可以让mysql在某个表发生更改时自动执行某个动作。触发器可以响应delete、insert或update语句。\n十八、事务 #  一些概念：\n 事务（transaction）：是指一组sql语句 回滚（rollback）：只能在事务内部使用 提交（commit）：做最终的写入操作 保留点（savepoint）：事务处理中设置的临时占位符，可以回滚到保留点，而不是整个事务  starttransaction;...rollback;...savepointxx;...rollbacktoxx;...commit;十九、用户及权限管理 #  数据库mysql.user表中有所有的用户信息\ncreateuserxxxidentifiedby\u0026#39;password\u0026#39;;renameuserxxxtoxxx2;dropuserxxx;showgrantsforxxx;--显示用户权限 grantselectondb.*toxxx;--grant授予权限 revokeselectondb.*toxxx;--revoke撤销权限 setpasswordforxxx=Password(\u0026#39;123456\u0026#39;);--改密码 二十、数据库维护 #   数据备份  命令行工具：mysqldump、mysqlhotcopy 命令：backup table、select into outfile、restore table、flush tables   检查状态  analyse table、check table   日志  错误日志：data/hostname.err，命令行参数 查询日志：data/hostname.log，记录所有mysql活动 二进制日志：data/hostname-bin，记录数据更新语句 慢查询日志：data/hostname-slow.log，记录执行缓慢的查询    二十一、改善性能 #   使用explain语句让mysql解释它如何执行某个select语句 join、union和子查询的性能不一定谁高谁低，需要具体问题具体分析 不要用select * 使用多条select语句和union来代替or条件 索引提升查询性能，但是会降低插入、删除和更新的性能 like很慢 \u0026hellip;  "},{"id":4,"href":"/posts/css-note/","title":"css入门笔记","section":"Posts","content":"CSS入门笔记 #  参考MDN教程\n一、导入 css #  1、导入外部样式：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34; /\u0026gt; 2、内部样式\n使用 style 元素\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;My CSS experiment\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; h1 { color: blue; background-color: yellow; border: 1px solid black; } p { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; ... \u0026lt;/html\u0026gt; 3、内联样式\n使用 style 属性\n\u0026lt;h1 style=\u0026#34;color: blue;background-color: yellow;border: 1px solid black;\u0026#34;\u0026gt; Hello World! \u0026lt;/h1\u0026gt; 语法 #  1、选择器+大括号，属性:值;\nh1 { color: red; font-size: 5em; } 2、函数\nwidth: calc(90% - 30px);\n3、@规则\n@import：导入样式表 @media：媒体查询（当条件成立时才应用样式）\n4、速记属性\n允许在一行中设置多个属性值，如 padding、border 等，例如：\npadding: 10px 15px 15px 5px; /* 等价于 */ padding-top: 10px; padding-right: 15px; padding-bottom: 15px; padding-left: 5px; background: red url(bg-graphic.png) /* 等价于 */ background-color: red; background-image: url(bg-graphic.png); 选择器和选择符 #     选择器 例子     元素 h1   id #onething   类 .manythings、a.manythings、.classA.classB   伪类 a:link、*:link、:link   属性 a[title]、a[href=\u0026quot;https://example.com\u0026quot;]、a[attr~=v]、a[attr|=v]、a[attr]、[attr^=value]、[attr$=value]、[attr*=value]、[attr=value i]（结尾加个 i 代表按大小写不敏感匹配）   伪元素 p::first-line   通用选择器 *    注：\n 多个选择器连在一起写代表“与”的关系。 伪类代表元素的状态，伪元素是一种虚拟的元素。参考：常见伪类和伪元素     运算符 例子     空格：后代选择器 article p   \u0026gt;：子代选择器 article \u0026gt; p   +：相邻兄弟选择器 h1 + p   ~：通用兄弟选择器 h1 ~ p    继承 #  继承：有些父元素上的 css 属性可以被子元素继承，有些不能。\n使用 inherit、initial、unset、revert 这四个属性值控制继承，例如\n.my-class-1 a { color: inherit; } 属性 all 可以用来代表所有属性\n层叠 #   多个相同权重的规则应用到同一个元素时，后面的覆盖前面的 选择器具有优先级，优先级计算公式  千位：style 属性（内联属性）得一分 百位：id 选择器得一分 十位：类选择器、属性选择器、伪类选择器得一分 个位：元素选择器、伪元素选择器得一份 通用选择器 (*)，组合符 (+, \u0026gt;, ~, ' \u0026lsquo;)，和否定伪类 (:not) 不会影响优先级。 计算时不允许进位，无论多少个低位选择器的权重叠加，都不会超过一个高位选择器。 !important：优先级高于其他所有   当浏览器遇到无法解析的 css 时（比如 css 拼写错误）这个 css 会被忽略。  盒子 #  块级盒子（Block Box）：\n 盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间 会换行 可以设置宽高（width 和 height） padding、margin 和 border 会把周围的元素推开  内联盒子（Inline Box）：\n 不会换行 宽高不起作用（width 和 height） 垂直方向的 padding、margin 和 border 不会把其他 inline 盒子推开 水平方向的 padding、margin 和 border 会把其他 inline 盒子推开  盒子的显示类型：\n 外部显示类型：决定盒子在它的父元素内是如何布局的，display 值为 inline 或 block 内部显示类型：决定盒子内部元素如何布局，display 值为 flex、grid 等。默认为正常文档流（inline 是 inline，block 是 block） 其他类型：  inline-flex：外部显示类型为 inline，内部显示类型为 flex inline-block：不换行的 block，能设置高宽、margin 和 padding，能把周围推开    盒模型 #  完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。\n盒模型组成：content、padding、border、margin\n 标准盒模型：width 和 height 设置的是 content。box-sizing: content-box; 替代（IE）盒模型：width 和 height 设置的是总长宽。box-sizing: border-box;  外边距折叠：如果两个元素相邻，它们之间的距离不是两个元素的 margin 之和，而是取两个元素 margin 的较大值\nmargin 可以为负值。padding 不可以为负\n属性写法（去掉后缀就是简写）：{margin/border/padding}-{top/right/bottom/left}-{width/style/color}\n背景和边框 #  背景（background）:\n background-image 属性可以有多个图片，图片会叠在一起显示 {background}-{color/image/repeat/size/position/attachment} 可以设置渐变（gradient）背景  边框（border）:\n {border}-{width/style/color/radius}  文本方向与逻辑属性 #  writing-mode: horizontal-tb、vertical-rl、vertical-lr\n逻辑属性是为了解决文本方向变化时盒子的高宽等属性不能正确变化的问题，例如\n inline-size 对应 width block-size 对应 height 内外边距、边框也有对应的逻辑属性 属性值也有对应的逻辑属性值  处理内容溢出 #  内容溢出\n overflow:visible/hidden/scroll/auto overflow-x overflow-y  文本换行\n word-break overflow-wraps hyphens  值和单位 #  参考：CSS 的值与单位\ncss 值可以使用关键字和值。关键字是指 red、top 等。\n 数值类型：integer、number、dimension、\u0026lt;percentage\u0026gt;、\u0026lt;length\u0026gt;  长度（length）  绝对单位：px 相对单位：rem   百分比（percentage）  百分比通常是相对于父元素     颜色（\u0026lt;color\u0026gt;）  RGB 和 RGBA：RGBA 颜色在 RGB 的基础上增加了一个透明度值，与 opacity 属性不同，opacity 使得元素和它里面的所有东西都不透明，而 RGBA 颜色只让指定的颜色不透明。（可以用 RBGA 颜色来增加一层滤镜） HSL 和 HSLA：RGB 是红绿蓝，HSL 是色调、饱和度和亮度   图片（\u0026lt;image\u0026gt;）和渐变（\u0026lt;gradient\u0026gt;） 位置（\u0026lt;position\u0026gt;） 标识符，标识符就是指上面提到的 css 关键字 字符串，例如content: \u0026quot;This is a string\u0026quot; 函数，例如 rgb()、url()、calc()等  尺寸 #  原始尺寸/固有尺寸：\n 例如图像本身的尺寸 空 div 没有尺寸，高度为 0，宽度由于其是块级元素会扩展到和父元素一样宽。  用百分数设置尺寸时：\n 对于 width 和 height，是相对于父元素宽度的百分比 对于内外边距，不论是左右边距还是上下边距，都是相对于 inline-size（即宽度）的百分比  min-和 max-尺寸：\n 如果盒子内容会变化，用 min-和 max-设置最小或最大尺寸，盒子尺寸就会随内容自动变化 这个技术就是用来使图片（\u0026lt;image\u0026gt;）可响应的，可响应是指图片随设备尺寸自动缩放。  视口尺寸：\n vw 和 vh  替换元素和表单 #  替换元素：指图像和视频元素，css 不能影响其内部布局\n 调整大小，object-fit: cover/contain/fill; 在 flex 和 grid 布局中，元素会被拉伸，而图像不会  表单的样式在不同浏览器上不太统一，需要额外设置 css 样式保证其初始样式一致，已经有一些工具帮开发人员完成了这个工作，例如 Normalize.css。\n字体 #  web 安全字体：可以在任何一种操作系统上找到的字体。参考：cssfontstack\n五种字体的大类型：\n serif，有衬线字体，衬线是指字体笔画尾端的小装饰，常见于印刷体字体 sans-serif，无衬线字体 monospace，等宽字体，通常用于代码 cursive，手写体 fantasy，用来装饰的字体  使用上面这五种字体时，由浏览器决定具体使用什么字体\n常见属性属性名：\n font-family/size/style/weight/transform/decoration color text-shadow text-align line-height letter-spacing word-spacing  web 字体：访问时和页面一起下载，本不需要本地事先有这种字体\n@font-face { font-family: \u0026#34;myFont\u0026#34;; src: url(\u0026#34;myFont.ttf\u0026#34;); } 注意：\n 有些字体有版权，不能随便用 不同浏览器支持的字体格式可能不同，常见的格式有.ttf, .woff, .woff2 等 在线字体服务，例如 google fonts，可以从第三方站点导入字体，例如用\u0026lt;link\u0026gt;或@import导入字体，不需要开发人员自己提供字体  布局 #  正常布局流 #  正常布局流是指默认的布局。\n 块元素的布局方向垂直于书写方向 内联元素的布局方向和书写方向一致 默认的，块元素的宽度是其父元素的 100%，高度与其内容高度一致。内联元素的 height 和 width 与内容一致。 外边距叠加  flexbox（弹性盒子） #  display:flex\nflexbox 用于创建横向或纵向的一维布局，里面的子元素被称为 flex 项，flex 有以下特点：\n 默认方向是横向（父元素 flex-direction:row） 元素会被拉伸到和最高的元素相同（父元素 align-items:stretch） 所有 flex 项都默认从容器的开始位置进行排列，排列成一行后，在尾部留下一片空白。  概念：\n 主轴是指沿着 flex 项放置方向的轴，交叉轴是指垂直方向的轴 设置了 display:flex 的父元素被称为 flex 容器，里面的子元素被称为 flex 项  方向：\n flex-direction:row/column/row-reverse/column-reverse，设置主轴方向，-reverse 代表反向排列元素 flex-wrap: wrap，允许换行 flex-flow：以上两项的缩写  动态尺寸：\n flex:1，无单位的数字代表一个比例，其所占宽度=(1/所有 flex 项所占比例之和)*屏幕宽度 flex:1 200px，该 flex 项至少占 200px，剩余空间按比例分配 flex-grow、flex-basis，分别是以上两个的全写 flex-shrink：指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。  对齐：\n align-items 控制 flex 项在交叉轴上的位置 justify-content 控制 flex 项在主轴上的位置，其值包括 flex-start、flex-end、flex-around、flex-between  排序：使用 order 属性，默认值是 0，值越大，越往后排\ngrid（网格） #  display:grid\n默认只有一列，创建多个列：\n grid-template-columns: 200px 200px 200px; 用fr单位创建多个列，grid-template-columns: 2fr 1fr 1fr，fr定义了一个比例，有点类似于flexbox不带单位的尺寸 grid-template-columns: 300px 2fr 1fr，剩下的两列会根据除去300px后的可用空间按比例分配 使用repeat函数重复生成列  在网格系统中，行和列之间的间隙被称为 gutter（沟槽），如何修改gutter：\n grid-column/row-gap  显式网格和隐式网格，隐式网格是指浏览器会自动将多出来的内容放到新的行/列里面去：\n 参数默认是auto，大小会根据放入的内容自动调整 grid-auto-rows/columns，指定显式网格的大小  动态行列尺寸：\n  使用minmax函数设置行列尺寸，minmax函数可以设置一个取值范围，例如minmax(100px, auto)，下面是一个例子\n.container { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); grid-auto-rows: minmax(100px, auto); grid-gap: 20px; }   利用分隔线放置内容\n 我们的网格有许多分隔线，第一条线的起始点与文档书写模式相关。在英文中，第一条列分隔线（即网格边缘线）在网格的最左边而第一条行分隔线在网格的最上面。 grid-column/row-start/end gird-column/row：同时指定开始线和结束线，要使用/符号分开，例如：grid-column: 1 / 3;  利用grid-template-areas和grid-area放置内容\n 对于某个横跨多个格子的元素，重复写上那个元素grid-area属性定义的区域名字 所有名字只能出现在一个连续的区域，不能在不同的位置出现 一个连续的区域必须是一个矩形 使用.符号让一个格子留空  .container { display: grid; grid-template-areas: \u0026#34;header header\u0026#34; \u0026#34;sidebar content\u0026#34; \u0026#34;footer footer\u0026#34;; grid-template-columns: 1fr 3fr; grid-gap: 20px; } header { grid-area: header; } article { grid-area: content; } aside { grid-area: sidebar; } footer { grid-area: footer; } 浮动（float） #  略\n定位（position） #    静态定位：position: static;，默认值，将元素放入文档布局流中的正常位置\n  相对定位：position: relative;，使用top, bottom, left, 和 right定位\n  绝对定位：position: absolute;，绝对定位的元素不再存在于正常文档布局流中，它在自己的层独立于一切。绝对定位元素相对于其“包含元素定位”。哪个元素是绝对定位元素的“包含元素”取决于绝对定位元素的父元素的position属性\n 如果父元素都是static，绝对定位元素会被包含在初始快容器中（\u0026lt;html\u0026gt;元素外面，根据浏览器视口定位） 如何修改绝对定位元素的相对元素？把它的一个父元素设置为相对定位（position: relative）就好了。 z-index：如果有多个绝对定位元素，用z-index指定它们的堆叠顺序（z是指z轴，假设网页有高度）。z-index默认值是0，数字大的在上面，小的在下面。    固定定位：position: fixed;，固定定位固定元素相对于浏览器视口本身。\n/*让一个固定定位元素顶部居中*/ h1 { position: fixed; top: 0; margin: 0 auto; /*使用auto居中*/ background: white; padding: 10px; }   position: sticky;：相对定位和固定定位的混合体，被定位的元素一开始表现得像相对定位一样，直到它滚动到某个阈值点（例如，距视口顶部1​​0px）后它就变得固定了。\n  多列布局 #  通过这两个属性开启多列布局，column-count 或者 column-width\n column-count属性创建指定列数，由浏览器计算每一列分配多少空间。 column-width属性指定列宽，由浏览器计算创建几列。 用 column-gap 改变列间间隙。 用 column-rule 在列间加入一条分割线。column-rule 是 column-rule-color 和 column-rule-style的缩写，接受和 border 一样的单位。 禁止内容折断：break-inside: avoid 或 page-break-inside: avoid  响应式布局 #  媒体查询：当满足指定条件时css才会被应用，例如\n@media screen and (min-width: 800px) { .container { margin: 1em 2em; } } 断点：媒体查询，以及样式改变时的点，被叫做断点（breakpoints），通常是一个阈值。\n现代布局方式，多栏布局，弹性盒子和网格默认是响应式的。\n视口元标签：\n \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width,initial-scale=1\u0026quot;\u0026gt;，它告诉移动端浏览器，应该将视口宽度设定为设备的宽度，将文档放大到其预期大小的100%。如果不加这个，用断点和媒体查询实现的响应式设计不会生效，因为视口大小还是PC端的大小  initial-scale：设定了页面的初始缩放，我们设定为1。 height：特别为视口设定一个高度。 阻止用户缩放  minimum-scale：设定最小缩放级别。 maximum-scale：设定最大缩放级别。 user-scalable：如果设为no的话阻止缩放。      媒体查询 #  @media media-type and (media-feature-rule) { /* CSS rules go here */ } 它由以下部分组成：\n 一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）；  它的值可以是：all、print、screen、speech   一个媒体表达式，是一个被包含的CSS生效所需的规则或者测试；  min-width、max-width、width等   一组CSS规则，会在测试通过且媒体类型正确的时候应用。  "}]