---
title: "games101笔记"
date: 2025-09-12T08:47:49+08:00
draft: false

tags: ["图形"]
categories: ["编程"]
---

## 变换（Transform）

有几种常见的变换

- 缩放（Scale）
- 翻转（Reflection）
- 切变（Shear）
- 旋转（Rotate）

### 旋转（Rotate）

旋转矩阵

$$
\begin{bmatrix}
\cos\theta & -\sin\theta\\
\sin\theta & \cos\theta 
\end{bmatrix}
$$

一个结论：旋转矩阵的逆矩阵等于它的转置矩阵（我们把这样的矩阵称为**正交矩阵**），即

$$
R^{-1} = R^T
$$



### 切变（Shear）

以下是一个x方向上切变的例子（这是一个2维变换）

```text
变换前

   ^ y
   |
 1 | +-----+
   | |     |
 0 | +-----+
   +--------------> x

变换后

   ^ y
   |
 1 |    /-----/      ← 顶边向右平移 k
   |   /     /
 0 | +-----/
   +--------------> x
```

表示为矩阵乘法：

$$
\begin{bmatrix}
x'\\
y'
\end{bmatrix}
=
\begin{bmatrix}
1 & a\\
0 & 1
\end{bmatrix}
\begin{bmatrix}
x\\
y
\end{bmatrix}
$$

### 齐次坐标（Homogeneous Coordinates）和仿射变换（Affine Transformation）

（下面以2维变换为例来说明这个问题）

**齐次坐标（Homogeneous Coordinates）**

齐次坐标的引入是为了解决线性变换无法表示平移的问题，没有齐次坐标的情况下，一个带有平移的变化必须表示为以下形式：

$$
\vec{y} = A\vec{x} + \vec{b}
$$

展开为：

$$
\begin{bmatrix}
x'\\
y'
\end{bmatrix}
=
\begin{bmatrix}
a & b\\
c & d
\end{bmatrix}
\begin{bmatrix}
x\\
y
\end{bmatrix}
+
\begin{bmatrix}
t_x\\
t_y
\end{bmatrix}
$$

为了简化表示和计算，我们引入齐次坐标，将二维向量扩展为三维向量：

- 将二维的点 $(x, y)$ 扩展为 $(x, y, 1)$
- 将二维的向量 $(x, y)$ 扩展为 $(x, y, 0)$

以下是一个利用齐次坐标对一个点做平移变换的例子：

$$
\begin{pmatrix}
x'\\
y'\\
w'
\end{pmatrix}
=
\begin{pmatrix}
1 & 0 & t_x\\
0 & 1 & t_y\\
0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
1
\end{pmatrix}
=
\begin{pmatrix}
x+t_x\\
y+t_y\\
1
\end{pmatrix}
$$

为什么向量的第三维是0呢？是因为向量具有平移不变性，如果是对一个向量做变换，为了使向量不受平移变换的影响，它的第三维必须是0。

在这个定义下（点的第三维是1，向量的第三维是0），以下这些操作都是有效的：

1. vector + vector = vector
2. point - point = vector
3. point + vector = point
4. point + point = ??

对于第四种情况，由于两个点相加后，第三维变成了2，不再符合齐次坐标的定义，因此，人们对这种情况做了扩充，规定：

$$
\begin{pmatrix}
x\\
y\\
w
\end{pmatrix}
\text{ is the 2D point }
\begin{pmatrix}
x/w\\
y/w\\
1
\end{pmatrix},
\quad w\neq 0
$$

其实就是两个点相加的结果是这两个点的中点

这也意味着，我们对齐次坐标下的一个点的4个维度都乘以一个数k，它和原来的点是同一个点，后面的透视投影会用到这个性质。

**仿射变换（Affine Transformation）**

上面提到的线性变换+平移（Translation）的组合叫做仿射变换

$$
\begin{bmatrix}
x'\\
y'
\end{bmatrix}
=
\begin{bmatrix}
a & b\\
c & d
\end{bmatrix}
\begin{bmatrix}
x\\
y
\end{bmatrix}
+
\begin{bmatrix}
t_x\\
t_y
\end{bmatrix}
$$

利用齐次坐标，可以将仿射变换表示为矩阵乘法：

$$
\begin{pmatrix}
x'\\
y'\\
1
\end{pmatrix}
=
\begin{pmatrix}
a & b & t_x\\
c & d & t_y\\
0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
1
\end{pmatrix}
$$

### 3维变换

将齐次坐标引入3维空间可得3维变换，其基本形式为：

$$
\begin{pmatrix}
x'\\
y'\\
z'\\
1
\end{pmatrix}
=
\begin{pmatrix}
a & b & c & t_x\\
d & e & f & t_y\\
g & h & i & t_z\\
0 & 0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
z\\
1
\end{pmatrix}
$$

### 3维旋转

**欧拉角旋转**

将任意一个3维旋转分解为绕x轴、y轴、z轴的旋转的组合

$$
\vec{R}_{xyz}(\alpha,\beta,\gamma)
= \vec{R}_x(\alpha)\,\vec{R}_y(\beta)\,\vec{R}_z(\gamma)
$$

$\alpha$、$\beta$、$\gamma$又称为欧拉角（Euler Angles）

这三种旋转类似飞机的滚转（Roll）、俯仰（Pitch）、偏航（Yaw）

欧拉角旋转变换不太方便做插值，四元数变换可以解决这个问题。

**罗德里格斯旋转公式（Rodrigues' rotation formula）**

将绕**任意过原点的轴** $\vec{n}=(n_x,n_y,n_z)$ 旋转 $\alpha$ 角度的旋转矩阵表示为以下形式（其中，$\vec{I}$ 是单位矩阵）：

$$
\vec{R}(\vec{n},\alpha)
= \cos(\alpha)\,\vec{I}
+ \bigl(1-\cos(\alpha)\bigr)\,\vec{n}\,\vec{n}^{\mathsf T}
+ \sin(\alpha)\,
\underbrace{\begin{pmatrix}
0 & -n_z &  n_y\\
n_z &  0  & -n_x\\
-n_y & n_x & 0
\end{pmatrix}}_{\vec{N}}
$$

**四元数旋转**

四元数是一种代数结构，可以用来表示3维空间中的旋转。

和罗德里格斯公式一样，四元数旋转同样是表示绕**任意过原点的轴** $\vec{n}=(n_x,n_y,n_z)$ 旋转 $\alpha$ 角度。

这里给出四元数的基本形式:

$$
\vec{q} = x i + y j + z k + w
$$

简记为：

$$
\vec{q} = (u, w)
$$

**纯四元数是指把一个向量 $(x, y, z)$ 表示为四元数的形式**：

$$\vec{v} = (v, 0) = x i + y j + z k + 0$$

这里省略四元数的性质和运算规则。

**以下是四元数旋转的公式**：

$$
R_q(\vec{v}) = q\,\vec{v}\,q^{-1}
= q\,\vec{v}\,q^{\star}
= \cos(2\theta)\,\vec{v}
  + \bigl(1-\cos(2\theta)\bigr)\,(\vec{n}\!\cdot\!\vec{v})\,\vec{n}
  + \sin(2\theta)\,(\vec{n}\!\times\!\vec{v})
$$

**$R_q(\vec{v})$ 将向量绕轴 $\vec{n}$ 旋转 $2\theta$ 角度**，$\vec{v}$是把向量表示为纯四元数的形式（$q^{\star}$ 是四元数 $q$ 的共轭四元数。$q^{-1}$ 是四元数 $q$ 的逆四元数）

为了最终旋转的角度是 $\theta$，我们需要将四元数定义为：

$$q = \left(\sin(\theta/2)\vec{n}, \cos(\theta/2)\right)$$

计算结果也是个纯四元数，等价于向量

### 欧拉角

欧拉角是一种三维姿态的描述方法，它表示的是按某种固定顺序的三次旋转动作。

欧拉角按照旋转轴和旋转顺序分为**经典欧拉角**（Proper Euler Angle）和**泰特布莱恩角**（Tait–Bryan angles），共 12种旋转方式。

经典欧拉角只绕两个轴旋转，并且第一个旋转轴和第三个旋转轴相同，它的六种旋转顺序分别是：z-x-z, x-y-x, y-z-y, z-y-z, x-z-x, y-x-y

泰特-布莱恩角使用三个旋转轴，它的六种旋转顺序分别是：x-y-z, y-z-x, z-x-y, x-z-y, z-y-x, y-x-z

按照旋转的坐标系分为两种旋转方式：

**内旋**（intrinsic rotation），是每次都相对于变换后的坐标系（即自身的、本地的坐标系）做旋转，又叫动态旋转。

**外旋**（extrinsic rotation），是每次都相对初始的（固定的）坐标系做变换，又叫静态旋转。

**内旋和外旋有一种等价关系**，例如，内旋 z-x-y 等价于外旋 y-x-z，特点是第一次和最后一次旋转的轴颠倒了顺序，这个关系对12种旋转方式都成立。

### 万向节死锁（Gimbal Lock）问题

对于泰特布莱恩角（Tait–Bryan angles），例如，以x-y-z 外旋为例，当绕y轴旋转90度后，这时绕z轴旋转和最开始绕x轴的旋转实际上造成的效果是相同的，这是一种万向节死锁（Gimbal Lock）现象。

对于经典欧拉角（Proper Euler Angle），例如，以z-x-z 外旋为例，当绕x轴旋转0度或180度后，这时绕z轴旋转和最开始绕z轴的旋转实际上造成的效果是相同的，这也是一种万向节死锁（Gimbal Lock）现象。

**网上有很多拿万向陀螺仪来解释这个问题的文章，毫无疑问，全是错误的**，万向陀螺仪的万向节死锁问题和欧拉角的万向节死锁问题是两个完全不同的概念，万向陀螺仪的万向节死锁问题是因为机械结构的限制而产生的旋转自由度受限问题，而欧拉角的万向节死锁问题是由特殊旋转顺序和角度组合导致的旋转冗余问题。

## 观测变换（Viewing Transformation）

主要内容：

- View (视图) / Camera transformation
- Projection (投影) transformation
    - Orthographic (正交) projection
    - Perspective (透视) projection

渲染一个场景总共需要3步

1. Model transformation：把场景搭建好
2. View transformation：找个拍摄角度，把场景放到摄像机前面
3. Projection transformation：拍照！把3D场景投影到2D平面上

这三步统称 MVP 变换，本课程重点讲解 View 和 Projection 变换

### View / Camera transformation

定义相机

1. Position $\vec{e}$ （摄像机的位置）
2. Look-at / gaze direction $\hat{g}$（摄像机的朝向，g是单位向量）
3. Up direction $\hat{t}$（摄像机的上方，垂直于g，$\hat{g}$ 和 $\hat{t}$ 相配合可以确定相机镜头本身的旋转角度）

几个约定俗称的规则：

- 相机的位置永远在原点
- 相机永远看向z轴负方向（$-\hat{z}$）
- 相机的上方永远是y轴正方向（$\hat{y}$）

这里为什么是看向z轴负方向呢？因为我们使用的是右手坐标系，z轴正方向是从屏幕里指向屏幕外，而我们希望相机是看向屏幕里的方向，所以相机看向z轴负方向。

很多图形api或者3d软件使用的是左手坐标系，这时相机看向z轴正方向。

左手坐标系有个坏处，x叉乘y等于-z，这会让人很迷惑，本课程使用右手坐标系。

**把相机从当前位置移动到原点，并且让它看向z轴负方向，这个过程叫做 View / Camera transformation**

$$
M_{\mathrm{view}} = R_{\mathrm{view}}\,T_{\mathrm{view}}
$$

其中 $ R_{\mathrm{view}} $ 是旋转矩阵，$ T_{\mathrm{view}} $ 是平移矩阵。

平移矩阵：把相机从位置 $\vec{e}=(x_e,y_e,z_e)$ 移动到原点

$$
T_{\mathrm{view}} =
\begin{bmatrix}
1 & 0 & 0 & -x_e \\
0 & 1 & 0 & -y_e \\
0 & 0 & 1 & -z_e \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

旋转矩阵：把相机的朝向 $\hat{g}$ 变换到 $-\hat{z}$ 方向，把 $\hat{t}$ 变换到 $\hat{y}$ 方向，把 $\hat{r}=\hat{g}\times\hat{t}$ 变换到 $\hat{x}$ 方向

这个旋转矩阵不太好求，它的逆矩阵很容易写出来，可以先求它的逆矩阵 $ R_{\mathrm{view}}^{-1} $，然后再对它求逆

$$
R_{\mathrm{view}}^{-1} =
\begin{bmatrix}
x_{\hat{g}\times\hat{t}} & x_{\hat{t}} & x_{-\hat{g}} & 0 \\
y_{\hat{g}\times\hat{t}} & y_{\hat{t}} & y_{-\hat{g}} & 0 \\
z_{\hat{g}\times\hat{t}} & z_{\hat{t}} & z_{-\hat{g}} & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

由于旋转矩阵是正交矩阵，所以直接转置后就能得到逆矩阵

$$
R_{\mathrm{view}} =
\begin{bmatrix}
x_{\hat{g}\times\hat{t}} & y_{\hat{g}\times\hat{t}} & z_{\hat{g}\times\hat{t}} & 0 \\
x_{\hat{t}} & y_{\hat{t}} & z_{\hat{t}} & 0 \\
x_{-\hat{g}} & y_{-\hat{g}} & z_{-\hat{g}} & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

**这个过程也叫 Model / View transformation，因为相机和物体之间的关系不能变，场景中所有的物体也要做这个变换**。

### Projection transformation

- Orthographic (正交) projection
- Perspective (透视) projection

正交投影和透视投影的区别：

![/img/games101-notes/orthographic-perspective-1.png](/img/games101-notes/orthographic-perspective-1.png)

对正交投影来说，无论摄像机离得有多远，投影的物体大小都不会变：

![/img/games101-notes/orthographic-perspective-2.png](/img/games101-notes/orthographic-perspective-2.png)

### 正交投影 (Orthographic projection)

1. 先做View/Camera transformation，把场景放到摄像机前面
2. 丢掉z坐标
3. 将结果矩形缩放到$[-1,1]$范围内

一般来讲，正交投影是要把任意一个立方体变换为一个正则、规范、标准的（Canonical）立方体（$[-1,1]^3$）, 先做平移变换，然后缩放变换

![/img/games101-notes/orthographic-projection.png](/img/games101-notes/orthographic-projection.png)

假设我们要把一个立方体 $[l,r]\times[b,t]\times[n,f]$ 变换为 $[-1,1]^3$，其中 $l$ 是 left，$r$ 是 right，$b$ 是 bottom，$t$ 是 top，$n$ 是 near，$f$ 是 far

变换矩阵为：

$$
M_{\mathrm{ortho}} =
\begin{bmatrix}
\frac{2}{r-l} & 0 & 0 & 0 \\
0 & \frac{2}{t-b} & 0 & 0 \\
0 & 0 & \frac{2}{n-f} & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & -\frac{r+l}{2} \\
0 & 1 & 0 & -\frac{t+b}{2} \\
0 & 0 & 1 & -\frac{n+f}{2} \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

### 透视投影 (Perspective projection)

透视投影中，相机在原点，相机和视角围成一个四棱锥体（Frustum），相机前面有两个平面，近景平面和远景平面，近景平面和远景平面分别截出这个四棱锥体的顶部和底部。

透视投影分为两步：

1. 先把四棱锥体（Frustum）挤压成一个立方体（Cuboid），对应的变化写作 $M_{\mathrm{persp}\to\mathrm{ortho}}$
2. 然后对这个立方体做一次正交投影 $M_{\mathrm{ortho}}$

最终，完整的透视投影为 $M_{\mathrm{persp}} = M_{\mathrm{ortho}}\,M_{\mathrm{persp}\to\mathrm{ortho}}$

下图是透视投影挤压过程的示意图，其中，$n$ 和 $f$ 分别表示近景平面和远景平面的 z 坐标

![perspective-projection.png](/img/games101-notes/perspective-projection.png)

挤压过程中，近景平面的点不变，远景平面的点 z 坐标不变，尺寸变为和近景平面一样的大小

四棱锥远景平面和近景平面的 y 坐标呈现这样的关系：

![persp2ortho.png](/img/games101-notes/persp2ortho.png)

x 坐标同理。

经过一顿推导，得到挤压矩阵：

$$
M_{\mathrm{persp}\to\mathrm{ortho}} =
\begin{pmatrix}
n & 0 & 0 & 0 \\
0 & n & 0 & 0 \\
0 & 0 & n+f & -nf \\
0 & 0 & 1 & 0
\end{pmatrix}
$$

Frustum这个四棱锥体又叫视锥，由垂直方向的Fov（Field of View，视野角度）和宽高比（Aspect Ratio）决定，用FovY表示垂直方向的Fov。

用 $[l,r]\times[b,t]$ 来表示近景平面，$n$ 和 $f$ 仍然表示近景平面和远景平面的 z 坐标，那么FovY 和 aspect 与 $l,r,b,t,n,f$ 的关系为：

$$
\tan\!\left(\frac{\mathrm{FovY}}{2}\right) = \frac{t}{\lvert n\rvert}
$$

$$
\mathrm{aspect} = \frac{r}{t}
$$


