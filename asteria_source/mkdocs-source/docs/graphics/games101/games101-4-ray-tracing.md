---
title: "games101 四、光线追踪"
date: 2025-10-11T10:55:17+08:00
draft: false

tags: ["图形"]
categories: ["编程"]
---

## 光线追踪解决什么问题

- 软阴影（Soft Shadow）
- 光泽反射（Glossy Reflection）：有一些光泽，但不是完全镜面反射
- 间接光照（Indirect Illumination）：光线在场景中的多次反射

光栅化快，但是质量低，光线追踪更精确，更符合物理规律，但是慢。

## 光线（Light Ray）

- 假设光线沿着直线传播。
- 假设两个光线不会碰撞，各传播各的。
- 光线从光源发出，经过场景中的传播和反射，最后到达眼睛。
- 光路可逆（Reciprocity），假设眼睛发出光线，经过场景中的传播和反射，最后能到达光源。

光线追踪就是利用光路可逆的原理，从眼睛出发，追踪光线在场景中的传播路径，直到光源。

## 光线投射（Ray Casting）

从眼睛出发，投射光线，找到光线和场景中物体的交点，再从交点出发，投射光线到光源，判断交点是否在阴影中，如果不在阴影中，就计算着色。

**生成Eye Ray：每个像素投出一个光线**

眼睛和场景之间有一个成像平面（Image Plane），从眼睛发出一个光线（Eye Ray / Camera Ray）穿过成像平面上的一个像素，到达场景中最近的一个物体，找到交点。

**像素着色**

从交点往光源连一条线（Shadow Ray），根据这条线有没有被物体阻挡，判断这个点在不在阴影里。

再根据法线，光线的入射方向，眼睛的观察方向，计算这个点的颜色。

## Recursive (Whitted-Style) Ray Tracing

可以处理光线多次的反射和折射。

由于光线在场景中弹射多次，光线和场景中的物体会有多个交点，每个交点都会跟光源连线，做阴影判断。

**光线在场景中每个交点的着色都会叠加到同一个像素上**。

如果存在折射，那么光线和物体表面的交点会产生两条新的光路，一条是反射光路，一条是折射光路，这两条光路最终都汇聚回光源。

（从眼睛出发的角度来讲，这是同一条光线的弹射过程，但是，从光源的角度来讲，它其实是发出了多条不同的光线，经过不同的光路，最终汇聚到眼睛。）

光线在弹射的过程中，能量会有衰减。

- Primary Ray：从眼睛出发的光线。
- Secondary Ray：二次弹射的光线。
- Shadow Ray：从交点到光源的光线。

## 求交点（Ray-Surface Intersection）

光线由起点和方向定义。

光线上的任何一点，都可以用以下公式表示：

$$
\mathbf{r}(t) = \mathbf{o} + t\,\mathbf{d},\quad 0 \le t < \infty
$$

其中，$\mathbf{o}$ 是光线的起点，$\mathbf{d}$ 是光线的方向，$t$ 是一个非负实数。

### 光线与球的求交

球的隐式方程是：

$$
(\mathbf{p}-\mathbf{c})^2 - R^2 = 0
$$

球面上任意一点 $\mathbf{p}$，到球心 $\mathbf{c}$ 的距离等于球的半径 $R$。

求交方程：

$$
(\mathbf{o} + t\,\mathbf{d} - \mathbf{c})^2 - R^2 = 0
$$

使用二次方程求根公式，就能解出 $t$：

$$
t = \frac{-b \pm \sqrt{b^{2} - 4ac}}{2a}
$$

### 光线和一般隐式表面的求交

隐式表面（Implicit Surface）是指由一个隐式函数定义的曲面：

$$
\mathbf{p} : f(\mathbf{p}) = 0
$$

求交方程：

$$
f(\mathbf{o} + t\,\mathbf{d}) = 0
$$

### 光线和三角形Mesh的求交

光线和Mesh求交能干嘛：

- 渲染方面：判断可见性（Visibility），判断阴影（Shadow），光照计算（Lighting）。
- 几何方面：判断一个点是否在Mesh内部。  
    
判断内外部，有一个简单的方法：从这个点出发，向任意方向发射一条光线，计算光线和Mesh的交点个数，如果是奇数，说明这个点在内部，如果是偶数，说明这个点在外部。

如何计算？

**光线和三角形的求交**

先计算光线和平面的交点，然后判断交点是否在三角形内。

平面可以定义为一个点 $p'$ +法线，只要一个点和 $p'$ 的连线和法线 $n$ 垂直，就说明这个点在平面上，即

$$
\mathbf{p}: (\mathbf{p} - \mathbf{p}') \cdot \mathbf{n} = 0
$$

将这里的点和向量写成x、y、z的形式，代入光线方程，就能得到常见的平面方程：

$$
ax + by + cz + d = 0
$$

光线和平面的求交过程：

$$
\begin{aligned}
&\text{Set } \mathbf{p} = \mathbf{r}(t) \text{ and solve for } t\\
&(\mathbf{p} - \mathbf{p}') \cdot \mathbf{N} = (\mathbf{o} + t\,\mathbf{d} - \mathbf{p}') \cdot \mathbf{N} = 0\\
&t = \frac{(\mathbf{p}' - \mathbf{o}) \cdot \mathbf{N}}{\mathbf{d} \cdot \mathbf{N}},\quad \text{Check: } 0 \le t < \infty
\end{aligned}
$$

然后再判断交点是否在三角形内。

**Moller Trumbore Algorithm**

Moller Trumbore 算法是一种高效的光线和三角形求交算法，一下就能求出光线和三角形的交点。

其基本思想是用三角形重心坐标描述交点的位置。

下图展示了 Moller Trumbore 算法的计算过程，$(1-b_1-b_2)$、$b_1$、$b_2$ 是重心坐标，$P_0$、$P_1$、$P_2$ 是三角形的三个顶点。

![moller-trumbore-algorithm.png](/img/games101-notes/moller-trumbore-algorithm.png)

上图中将求交过程转换为解线性方程组（因为公式中的向量和点都是三维的），利用克拉默法则（Cramer's Rule）求解，克拉默法则可以用来解n个式子和n个变量的线性方程组。

得到解以后，只要t和三个重心坐标都是非负的，并且重心坐标之和为1，就说明交点在三角形内。

### 包围盒

最简单的想法是，遍历所有三角形，计算光线和每个三角形的交点，找到最近的交点，但是这个方法很慢。

如何加速计算呢？

包围盒（Bounding Volume）是一个简单的几何体，能包住复杂的几何体。

包围盒的基本思想是：如果光线和包围盒相交，那么光线一定和包围盒内部的某个物体相交；如果光线和包围盒不相交，那么光线一定和包围盒内部的物体不相交。

长方体是最常用的包围盒，我们通常使用轴对齐包围盒（Axis-Aligned Bounding Box, AABB），长方体的每一轴都是沿着坐标轴的，它计算简单。

如何判断光线和盒子相交？

包围盒一共有6个面，两两相对，构成三组对面，我们将这6个面看作是无限延伸的，那么和包围盒求交的主要思路是：

- 只有当光线进入每组对面时，光线才进入了包围盒
- 只要光线离开任意一组对面，光线就离开了包围盒

对于每组对面，都能求出光线进入和离开的时间 $t_{min}$ 和 $t_{max}$，负值也ok（负值代表光线反向传播），光线进入包围盒的时间是三组对面中最大的 $t_{min}$，光线离开包围盒的时间是三组对面中最小的 $t_{max}$，即，

$$
t_{enter} = \max(t_{min})
$$

$$
t_{exit} = \min(t_{max})
$$

从几何的角度来看，光线和每组对面相交构成一个线段，共形成三个线段，对三个线段求交，得到的线段的起点和终点分别对应 $t_{enter}$ 和 $t_{exit}$。

当 $t_{enter} < t_{exit}$ 时，说明光线和包围盒相交，反之，不相交。

现在考虑负值的情况

- 当 $t_{exit} < 0$ 时，说明包围盒在光线传播方向的背后，光线和包围盒不相交。
- 当 $t_{enter} < 0$ 且 $t_{exit} > 0$ 时，说明光线从包围盒内部发出，光线和包围盒相交。

**结论，当 $t_{enter} < t_{exit}$ 且 $t_{exit} > 0$ 时，说明光线和包围盒相交，反之，不相交**。

**AABB包围盒的好处**

包围盒是和坐标轴对齐，比如，我们要计算一条光线和垂直于x轴的对面的交点，求交公式可以简化为：

$$
t = \frac{\mathbf{p}'_x - \mathbf{o}_x}{\mathbf{d}_x}
$$

只需要用这些点和向量的x分量计算就行了，原因是这组对面的法线 $N$ 刚好就是x轴方向的单位向量，和 $N$ 做点积得到的就是x分量。

在对包围盒求交后，如果光线和包围盒相交，那么就要计算光线和包围盒内部的物体求交，如何加速这个过程呢，这就要用到均匀网格（Uniform Grids）和空间划分（Spatial Partitions），这是两种加速计算光线和物体求交的方法。

**均匀网格（Uniform Grids）**

首先，对包围盒做预处理：

1. 构造包围盒。
2. 建立网格。
3. 标记和物体表面相交的格子。

然后，光线追踪求交

1. 光线穿过包围盒，和每个格子求交（这个计算比直接和物体求交快）。
2. 经过被标记的格子时，光线是有可能和物体产生交点的。
3. 检查光线是否和上一步骤中被标记格子中的物体表面相交。

光线穿过包围盒时，要去判断光线经过哪些格子，这有点类似光栅化时，对直线进行采样的过程，三维空间也有类似二维空间的直线光栅化算法（这个略过）。

为了最优化光线和场景求交的速度，格子不能太多也不能太少，一个经验值是，在3D场景下，格子数目 = 27 * 物体数目。

**空间划分（Spatial Partitions）**

场景中的物体分布比较稀疏或者比较不均匀时，均匀网格就仍然会产生很多没必要的计算消耗，这时就可以用空间划分的方法。

空间划分的思路是，根据物体在空间中的分布情况，将空间划分为大小不一的格子。

下图列出了三种空间划分方法（简化成二维的形式），分别是八叉树（Oct-Tree），KD树（KD-Tree），BSP树（BSP-Tree）。

![spatial-partitions.png](/img/games101-notes/spatial-partitions.png)

八叉树是将空间递归地划分为8个子空间，直到每个子空间内的物体数目小于某个阈值（在二维空间中，就退化为了四叉树）

KD树是将空间递归地划分为两个子空间，划分的平面是和坐标轴对齐的，他是一个二叉树。

BSP树是将空间递归地划分为两个子空间，划分的平面可以是任意方向的。

KD树是最简单的。