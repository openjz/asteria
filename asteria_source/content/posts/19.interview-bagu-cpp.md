---
title: "面试八股-c++"
date: 2022-10-25T15:46:32+08:00
draft: false

tags: ["面试", "c/c++"]
categories: ["编程"]
---

- threadlocal
- volatile


## c++11中的新特性

我们通常把c++11之后的c++称为现代c++，以下是一些常见新特性

- 语法
    - 列表初始化
        - 可以使用`initializer_list<T>`让一个类拥有列表初始化的能力
    - 范围for语句
    - using，新的类型别名声明，代替typedef
    - 尾置返回类型，`auto func(int) -> int(*)[10];`
- 类型、关键字
    - long long类型
    - nullptr常量
    - auto类型
    - constexpr
        - 是一种在编译器求值的常量表达式（常量表达式，值为常量并且在编译过程就能得到计算结果）
        - 可以定义constexpr变量，constexpr函数，字面值常量类（需要constexpr构造函数）
    - decltype
        - 作用是推断一个表达式的类型，并可以将返回值作为类型声明
        - 和auto的区别是，当你不想要表达式的值，只想要表达式的类型时，可以使用decltype
- 类型转换
    - static_cast、dynamic_cast、reinterpret_cast
- 面向对象
    - =default、=delete
    - explicit，防止隐式类型转换
    - 虚函数的override
    - final阻止继承
    - move语义和右值引用
    - lambda表达式
    - bind，函数适配器
- 内存管理
    - 智能指针
- stl
    - unordered_map、unordered_set

## 类型转换

- static_cast，常规的类型转换
- const_cast，改变对象的底层const
- dynamic_cast，用于父子类指针和引用之间的转换，属于一种多态特性
- reinterpret_cast，不会改变变量本身的值，而是在字节层面上把变量解释为另外一个类型

## 内存管理

- malloc、free
- new、delete
- operator new、operator delete
- placement new

### 智能指针

- shared_ptr
    - make_shared，构造对象并创建智能指针，最安全
    - 利用普通指针初始化shared_ptr，不安全
        - 混用普通指针和shared_ptr会导致普通指针在用户不想释放的时候被shared_ptr释放
        - 混用两个智能指针会导致两个智能指针单独计算引用计数，引发问题
    - 通过拷贝shared_ptr增加引用计数
    - reset，引用计数-1
- unique_ptr，不支持拷贝和赋值
- weak_ptr，shared_ptr的弱引用，不会影响引用计数。不能直接访问数据，必须先使用lock方法获得shared_ptr，解决shared_ptr相互引用造成的资源不释放问题（属于一种内存泄漏）
- RAII

### allocator

- stl中用来内存管理的类
- stl容易一般都有一个模板参数Allocator，因为是个模板参数而不是函数参数，所以可以用自定义的allocator代替std::Allocator
- allocator负责内存的分配和释放，对象的创建和销毁

## 面向对象

- 拷贝控制
    - 会默认生成的函数：默认构造、拷贝构造、拷贝赋值、析构函数
- 初始化顺序
    - 优先构造基类对象（按派生顺序构造）
    - 然后构造成员对象（按声明顺序构造）
- 成员能不能是引用类型？
    - 能，但是
        - 构造函数形参必须也是引用类型（否则永远只能获得一个局部变量的引用）
        - 必须在构造函数的初始化列表里初始化
- 访问权限，public、private、protected
    - protected表示成员可以被派生类访问，但不公共可见
    - **private对派生类不可见**
- 继承权限
    - **控制派生类的用户（包括派生类的派生类和类外部）对基类的访问权限，而不是控制派生类本身对基类的访问权限**
    - public，保留原来的权限
    - private，public和protected变为private
    - protected，public变为protected
- 虚继承/虚基类
    - 解决由多重继承引起的多基类实例问题
    - 在继承类名前加上virtual
- 多态性
    - 虚函数
        - 虚函数又叫动态多态
        - 虚析构函数的必要性
            - 使用基类指针指向派生类时，如果基类的析构函数不是虚函数，会导致无法调用派生类的析构函数
            - 而虚构造会产生一个悖论，当对象没有实例化时，没有虚表指针，是无法调用虚构造函数的
        - 类A的对象a保存一个虚函数指针，虚函数指针指向类A的虚函数表，虚函数表保存了虚函数指针，指向的是实际调用函数地址，不同类的虚表中可能回复用同一个函数（类的继承导致的）
        - 纯虚函数/抽象类
            - 抽象类不能实例化
            - 纯虚函数也不能实现，`virtual int func1() = 0;`
        - 能否在构造函数和析构函数中调用虚函数？
            - 可以，但是此时多态特性是失效的
    - 重载
        - 重载又叫静态多态，对调用函数的推断发生在编译器
        - 重载实现原理，命名倾轧技术，在函数名上带上参数信息
        - 普通函数重载、成员函数重载、重写、运算符重载、函数对象几种
            - 仿函数（functor）是指函数对象
    - 函数对象
    - lambda表达式，`[capture] (param) mutable noexcept/throw() -> return type {};`
    - bind函数适配器
- 名字查找
    - 作用域
    - 命名空间
    - 友元

## 泛型

- 模板的实例化发生在编译期
- 模板实例化是指从函数模板/类模板生成一个真正的函数/类的过程
    - 显式模板实参
    - 模板实参推断

## stl

- stl中包括：容器、算法、迭代器、适配器、内存分配器allocator
- vector
- unordered_map、unordered_set
- 适配器
    - 容器适配器，stack，queue
    - 迭代器适配器，插入迭代器、移动迭代器、流迭代器、反向迭代器
    - 函数适配器，bind

## 隐式类型转换

- 内置类型的隐式类型转换
- 构造函数
- 类型转换运算符

## 其他

- extern "C"
    - 导入c函数的关键字，它告诉编译器这段代码按c编译
- threadlocal
    - 线程局部变量
    - 要配合C++ thread标准库一起使用
- atomic
    - 可以对基本类型封装原子操作
- mutable
    - 可以把一个成员声明为可变的，操作成员的函数仍然能受到const保护

## C++20

- concept
    - 和模板类型推断有关，可以用来约束模板实参的类型，`concept concept-name = expression`
- coroutine
- modules

