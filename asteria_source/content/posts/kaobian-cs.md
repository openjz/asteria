---
title: "事业编计算机知识"
date: 2022-06-21T19:21:16+08:00
tags:
categories:
  - "考编"
---

## 考点

1. 组成原理、体系结构
2. 网络
3. 操作系统、windows
4. 数据库
5. 软件工程
6. 安全
7. office
8. 编程语言(c、java)
9. 基础数据结构、算法

## 组成原理

多媒体信息：文本，图片，音频，视频，动画...

计算机内部通常是并行传输，通信线路上通常是串行传输

### 编码

码距：两个码不同的二进制位数

### RAID

- **raid0**：假设有 disk1、disk2、disk3、disk4 四块硬盘，数据被分为四份分别放在四块硬盘上
  - 优点：硬盘空间利用率高、处理大文件速度快
  - 缺点：一块硬盘损坏，所有数据均不可用
- **raid1**：至少要有两块硬盘，一块硬盘存储，一块硬盘做备份
  - 优点：提供数据冗余
  - 缺点：可使用容量减半
- raid2：在 raid0 基础上加入汉明码纠错
- raid3：在 raid0 基础上增加一块硬盘专门做奇偶校验
- raid4：不常见，略
- **raid5**：和 raid0 类似，一个数据分为多份，分别存储到不同的硬盘上去，但会有另外一块硬盘专门存放这个数据的校验码，各个数据的存储是独立的，所有硬盘都可以作为存储盘和校验盘
  - 优点：兼顾存储性能、数据安全、存储成本
  - 缺点：有两块或两块以上硬盘损坏，数据就无法恢复、数据重建慢
- raid6：在 raid5 的基础上加入双重校验
- raid10/raid01：raid1 和 raid0 的结合
- **raid7**：最优化的异步高 I/O 速率和高数据传输率，RAID7 不仅仅是一种技术，还是一种存储计算机，可完全独立于主机运行，不占用主机 CPU 资源

### 图灵和冯诺依曼

图灵，计算机科学之父，人工智能之父，计算机科学的奠基人

冯·诺依曼，现代计算机之父，博弈论之父，提出冯诺依曼结构

### 字符编码方案

输入码是指输入字符时的编码，例如五笔码、全拼码等

交换码是指逻辑上的编码标准，例如 unicode 就是一种交换码

内码是指字符在计算机内部实际的编码方案，例如 utf-8 就是一种内码

### 接口

- SCSI  
  并行接口，支持热插拔
- IEEE 1394  
  串行接口，传输速度快。最早由苹果公司为了取代 SCSI 提出。USB 和 IEEE 1394 是现今比较流行的两种外部总线标准
- rs232：两排，共 9 针（一排 4 针，一排 5 针），全双工，距离短，速度慢
- rs485：无固定接口，半双工，距离长，速度快
- DVI 接口：三排 15 针

### 周期

- 指令周期：计算机执行一条指令需要的时间
- CPU 周期/机器周期：一条指令的执行分为若干阶段，每个阶段的执行周期称为 CPU 周期或机器周期。（通常用一次方访存时间来衡量）
- 时钟周期：振荡周期，一个时钟滴答

### 内存-缓存映射

- 直接映射：一个内存块映射到固定的缓存块
- 半相联映射：一组内存块映射到固定的缓存块，块内部是任意映射
- 全相联映射：任意一个内存块映射到任意一个缓存块

### 总线

PCI 总线

- 以桥连接实现的 PCI 总线允许多条总线并行工作
- 系统中允许有多条 PCI 总线
- 基本传输机制是猝发式传输
- 同步时序协议和集中式仲裁策略

## windows 系统

windows 通配符：“\*”用于匹配多个字符，“?”用于匹配单个字符

windows 中不能作为文件名的是：/\<>?\*

fat 分区最大 2TB，最大文件 4GB

### windows 快捷键

1. win7 开机时进入安全模式按 f8
2. 切换语言，shift+alt
3. 切换输入法，shift+ctrl
4. 切换输入法的语言，shift 或 ctrl+空格
5. 全半角状态转换，shift+空格
6. 打开开始菜单，ctrl+esc 或 win

## 数据库

### 数据库的特征

0. 持久存储（不属于基本特点，选择题不选）
1. 数据结构化，有组织，按一定数据模型组织、描述和存储（数据冗余度低）
2. 数据可共享
3. 数据独立性高，易扩展。数据独立性分为逻辑独立性和物理独立性

### 数据库管理系统（DBMS）

位于操作系统之上，管理数据库，提供数据定义、数据操纵、数据控制、数据查询四种功能，并对应有以下语言供用户使用

- DDL，数据定义语言（建库、建表等）
- DML，数据操纵语言（增、删、改）
- DCL，数据控制语言
- DQL，数据查询语言

此外还负责网络通信，保障数据安全性和完整性，事务控制，并发控制等

### 数据库系统结构

三级模式：外模式、模式和内模式

二级映射：外模式-模式映射、模式-内模式映射

**外模式，又称子模式或用户模式**，对应用户级，用户使用外模式描述语言来定义用户的数据记录，或者使用 DML 对数据记录做描述。

**模式，又称概念模式或逻辑模式**，对应于概念级，是所有用户的公共数据视图，使用 DDL 来描述。

**内模式，又称存储模式**，对应于物理级，描述了数据在存储介质上的物理结构。

### 数据模型

**数据模型分为概念数据模型、逻辑数据模型、物理数据模型**

**概念数据模型**是从用户视角描述数据，反映客观世界的联系和规则

E-R 图（实体-联系图）是一种概念模型，用实体、属性和联系来描述客观世界，联系也称关系，分为一对一、一对多、多对多。实体用矩形表示，属性用椭圆形表示，关系用菱形表示。

**逻辑数据模型**由数据结构、数据操作和完整性约束构成

数据库支持的逻辑数据模型有层次模型、网状模型、关系模型和面向对象模型。

### 关系型数据库

关系数据模型，是一种用二维表结构来表示实体和实体间关系的模型

### 关系规范化理论

关系规范化理论是一种用来指导如何设计关系型数据库的理论，规范化用形式更简洁、结构更规范的关系模式取代原有关系模式，其目的是为了解决不合理的关系模式设计导致的数据冗余、操作异常（增删改异常）等问题。

完整的关系模式是一个五元组 R(U,D,Dom,F)，R 是关系，U 是属性集，D 是属性的域，Dom 是属性到域的映射，F 为属性的数据依赖集

关系模型可以简化为一个三元组 R(U,F)

数据依赖是关系模式的重点，包括函数依赖、多值依赖和连接依赖

**函数依赖**

对于 R(U)，设 X 和 Y 是 U 的两个子集，如果对任意一个 X，有唯一的 Y 与之对应，则这个依赖是函数依赖，称为“X 函数确定 Y”或“Y 函数依赖 X”，记为`X->Y`，X 为决定因素，Y 为依赖因素。例如，确定了学号，就能确定姓名、性别等。

函数依赖有三种情形

1. 平凡函数依赖和非平凡函数依赖  
   如果 Y 是 X 的子集，Y 对 X 就是平凡函数依赖，否则是非平凡函数依赖。
2. 完全函数依赖和部分函数依赖  
   如果 X 的任何一个真子集都不能决定 Y，Y 对 X 就是完全函数依赖，否则是部分函数依赖。
3. 传递函数依赖  
   如果 X->Y，Y->Z，且不存在 Y->X，那么 Z 对 X 传递依赖。

**码/键**

- 码/键  
  表中的一个或几个属性，用来标识该表的每一行或与另一个表产生联系
- 超码/超键  
  去掉一个属性，还是码
- 候选码/候选键  
  最小的码（属性集完全函数依赖于该码）
- 主码/主键  
  从候选码中选一个
- 主属性  
  候选码中的属性是主属性

**规范化**

不同的规范化程度可用范式来衡量。目前有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、BC 范式（BCNF）、第四范式（4NF）和第五范式（5NF）。

- 第一范式，关系 R 的每个属性都不可分解，都是原子的
- 第二范式，关系 R 满足第一范式，且所有非主属性都完全函数依赖于任意候选码
- 第三范式，关系 R 满足第二范式，所有非主属性都不传递函数依赖于任何候选码
- BCNF 范式，基于满足第一范式的基础之上，是对第三范式的改进

> BCNF 范式，关系 R 满足第一范式，对任何非平凡依赖 X->Y（Y!->X），X 都包含码，这意味着  
>  （1）所有非主属性都完全函数依赖于每个候选码
> （2）所有主属性都完全函数依赖于每个不包含它的候选码
> （3）没有任何属性完全函数依赖于非码的任何一组属性

数据库设计普遍采用的是基于 3NF 的设计方法

### 事务

事务是用户定义的一个操作系列，具有原子性，要么都完成，要么都不完成。事务可以是一条 SQL 语句，也可以是一组 SQL 语句

事务的 ACID 特性：原子性、一致性、隔离性、持久性

## 网络

计算机网络要求误码率低于 10^-6，如果达不到这个指标，就必须进行差错校验

按网络覆盖范围分类

- WAN（wide area network），广域网
- MAN（metropolitan area network），城域网
- LAN（local area network），局域网，是一种点对点结构的网络
- WLAN（wireless local area network），无线局域网
- PAN（personal area network），个人区域网络（蓝牙、USB 等）
- CAN（campus area network），校园区域网络
- SAN（storage area network），存储区域网络

### 服务访问点 SAP

服务访问点 SAP 是指上下两层协议实体之间的逻辑接口（某一层的 SAP 是其对上层的访问接口），例如网络层的 SAP 是 IP 地址

### 物理层

物理层设备：

- 光纤，光纤只能单向传输，光纤抗干扰和传输距离都比同轴电缆强
- 中继器，集线器
- 双绞线
  - 既可以传输模拟信号，又可以传输数字信号
  - 不仅适用点到点连接，也适用多点连接

计算机中的传输设备包括：双绞线、同轴电缆、光纤、无线传输介质（无线电波、微波、红外线、激光）

物理协议

- 电气特性：电压范围
- 功能特性：电平代表的含义
- 规程特性：事件顺序
- 机械特性：接口外形、形状、大小、引脚数

### 数据链路层

数据链路层设备：

- 网桥
- 交换机
- 网卡，网卡工作在物理层和数据链路层的 MAC 子层

数据链路层有两个子层，逻辑链路控制层（LLC）和介质访问控制层（MAC），LLC 层位于 MAC 层之上。

CSMA/CD 协议，发送数据前先侦听总线的忙/闲状态，发送数据的同时要进行冲突检测

以太网拓扑结构有很多种，主要是**总线型**，加入交换机后，变为**星型**拓扑。其他结构还有：

- 环型
- 树型
- 网状型

IEEE 802.3，数据链路层协议，CSMA/CD，2进制指数退避，1-坚持算法

### 交换机和集线器的区别

集线器工作在物理层，不涉及网络协议层面的工作，只能以广播模式转发数据

交换机工作在数据链路层，可以根据报文中的 MAC 地址对数据做针对性的转发

### 网络层

**虚电路和数据报**

虚电路和数据报是分组交换的两种方式（分组就是包，是网络层的概念），目前因特网用的就是数据报方式。

数据报方式为网络层提供无连接服务，每个分组都包含源地址和目的地址，每个分组独立路由和转发，不保证分组按顺序到达，不保证可靠传输。

虚电路方式为网络层提供面向连接的服务，建立连接后分组只包含一个虚电路号作为标识，同一条虚电路的分组按同一条路由转发，保证分组的有序到达，保证可靠传输。

### Internet、Intranet 和 Extranet

Internet 是英特网，Intranet 是企业内部网，Extranet 是外联网

### 安全

文件型病毒主要感染 com 和 exe 文件

## 操作系统

操作系统的发展：单道批处理系统，多道批处理系统，分时系统，实时系统，通用操作系统

### 死锁

死锁是指多个进程并发执行时因争夺资源造成的互相等待现象。

死锁发生有四个必要条件

1. 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到进程使用完成后释放该资源；
2. 请求保持条件：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，而且该进程不会释放自己已经占有的资源；
3. 不可剥夺条件：进程已获得的资源，只能自己释放，不可剥夺；
4. 环路等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

如何解决：

1. 把独占资源变为共享资源
2. 资源一次性分配，从而解决请求保持的问题
3. 资源可剥夺，当进程新的资源未得到满足时，释放已有的资源；
4. 资源有序分配，对所有资源编号，进程请求资源时按资源递增顺序请求，释放则相反，破坏了环路等待条件。
5. 一个著名死锁避免算法，银行家算法

### 进程调度

1. 先来先服务，对长作业有利，但是对短作业不利
2. 最短作业优先，会发生饥饿现象
3. 高响应比优先，同时将要求服务时间和等待时间算入优先级，照顾到了长进程
4. 时间片轮转
5. 最高优先级调度，静态优先级和动态优先级（Linux的nice值和pr值）
6. 多级反馈队列调度，多个队列，队列优先级从高到低，高优队列时间片最短，低优队列时间片最长，新进程先进入高优队列，如果在时间片内没执行完，就进入

## 软件工程

项目管理三角形：范围、时间、成本

### 软件生命周期

- 软件计划阶段
  - 问题定义
  - 可行性分析  
    可行性分析的目的是用最小的代价在尽可能短的时间内确定该项目是否能够开发，是否值得开发，其本质是要进行一次简化的、压缩的需求分析和设计过程，要在较高层次上以较抽象的方式进行需求分析和设计，给出可行性分析报告
- 软件开发阶段
  - 需求分析
  - 软件概要设计
  - 软件详细设计
  - 软件编码
  - 软件测试
- 软件运行阶段
  - 软件运行与维护

**软件开发模型**

瀑布模型

- 也称生存周期模型或线性顺序模型，这种模型是将软件生命周期各个阶段活动依线性顺序连接。
- 各阶段具有顺序性和依赖性
- 具有推迟实现的特点
- 重视质量保证，每个阶段都必须完成规定的文档，并对文档进行评审。
- 缺点：不灵活，必须分析清楚需求才能能到预期结果

快速原型模型

- 需求分析阶段只进行初步的需求分析，快速设计开发出原型供用户测试评定，根据改进意见丰富细化软件，然后在给用户试用，反复改进，直至用户满意

增量模型

- 将瀑布模型和快速原型模型相结合，每次发布一个增量，第一个增量是核心产品，用户对每个增量的反馈将成为下一个增量的新特性

螺旋模型

- 螺旋模型是一种迭代模型，结合了瀑布模型与增量模型，它把开发过程分为几个螺旋周期，在每个周期中加入了风险分析

其他模型

- 喷泉模型，是一种比较典型的面向对象软件开发模型，适合面向对象的开发方法
- 基于构件的开发模型
- 统一过程（RUP）模型
- 基于形式化的开发模型

### 软件开发方法

程序设计可以分为面向过程设计和面向对象设计，软件工程也分为面向过程软件工程（即传统软件工程）和面向对象软件工程，面向过程软件工程是以结构化程序设计为基础，面向对象软件工程是以面向对象程序设计为基础。

- 结构化开发方法  
  结构化开发方法(Structured Developing Method)是现有的软件开发方法中最成熟，应用最广泛的方法。结构化开发方法由结构化分析方法(SA 方法)、结构化设计方法(SD 方法)及结构化程序设计方法(SP 方法)构成。
- 面向对象方法
  - 基本概念：类、对象、实例、消息（一个函数调用）、方法...
  - 面向对象建模得到的模型包含系统的 3 个要素：静态结构（对象模型）、交互次序（动态模型）和数据变换（功能模型）。
    - 对象模型：描述数据结构（UML 图）
    - 动态模型：描述交互和次序（状态图）
    - 功能模型：功能模型作用在对象模型说明的数据上，同时还表示了对对象值的约束
  - 对象的特点：标识唯一性、分类性/抽象性、多态性、封装性
  - 面向对象的特点：封装、继承、多态
- Jackson 方法
  - Jackson 方法是一种面向数据结构的开发方法。
  - JSP(JacksonStructure Programming）方法以数据结构为驱动，适合小规模项目。JSP 方法首先描述问题的输入/输出数据结构，分析其对应性，然后推出相应的**程序结构**，从而给出问题的软件过程描述。
  - JSD 方法是 JSP 方法的扩展，是一个完整的系统开发方法。首先建立现实世界的模型，再确定系统的功能需求，对需求的描述特别强调操作之间的时序性。它是以事件作为驱动的，是一种基于进程的开发方法，所以适用于时序特别较强的系统，包括数据处理系统和一些实时控制系统。
  - Jackson 图，描述数据元素彼此之间的逻辑关系，只有顺序、选择和重复三类。

### 面向过程的软件开发

一、结构化分析方法（SA）

结构化分析方法（Structured Analysis，**SA**），是面向数据流的需求分析方法。结构化分析就是使用**数据流图、数据字典、结构化语言、判定树和判定表**等工具，来建立一种新的称为结构化说明书的目标文档。

采用自顶向下逐层分解的分析策略，把一个复杂问题分解成若干小问题。分解可分层进行，在分解中要充分体现“抽象”的原则，上一层就是下一层的抽象。最高层的问题最抽象，而低层的较为具体。

结构化分析工具：

可划分成非形式化、半形式化和形式化三类，自然语言是非形式化的，数据流图是半形式化的，数学描述是形式化的

- **数据流图**(Data Flow Diagram，**DFD**)，描述系统由哪几部分组成，各部分之间的联系，描述了系统数据的流动和处理过程。
- 数据字典。数据字典是关于数据的信息的集合，是对数据流图中包含的所有元素的定义的汇集。
- 结构化语言，判定树，判定表，用于描述数据流图中的不能被分解的每个基本加工处理逻辑
  - 结构化语言，三种结构，顺序、循环、判定。简单的控制流（顺序执行和循环执行的动作）用结构化语言描述。存在多个条件复杂组合的判断问题，用判定树和判定表描述
  - 判定树，又称决策树，易读
  - 判定表，严格，可以先用判定表做底稿，在此基础上产生判定树

二、软件设计

模块是构成程序的基本构件，是能够独立完成一定功能的程序语句的集合，如高级语言中的过程、函数、子程序等。广义地说，面向对象方法学中的对象也是模块。在软件体系结构中，模块是可以组合、分解和更换的单元。

模块最重要的特征有两个：一是抽象，二是信息隐蔽和局部化

模块化是指解决一个复杂问题时自顶向下逐层把软件系统划分成若干模块的过程。

软件模块设计原则

1. 高内聚低耦合
2. 模块结构的深度、宽度、扇出和扇入应适当。（所有模块会构成树状结构，这些指标就是这棵模块树的指标）
3. 模块的作用范围应该在控制范围内（作用范围是指该模块能影响的模块，控制范围是指从属于该模块的模块）
4. 模块接口设计要简单，以便降低复杂程度和冗余度
5. 设计功能可预测并能得到验证的模块
6. 适当划分模块规模，以保持其独立性

三、 结构化设计方法（SD）

结构化设计方法是以**数据流图**为基础设计系统的软件结构。

数据流图分为变换型数据流图和事务型数据流图

四、 结构化程序设计方法（SP）

结构化程序设计所使用的结构有顺序、条件和重复三种

五、详细设计工具

过程设计语言（Process Design Language，PDL）也称为伪码（伪代码）

### 面向对象的软件开发

一、 面向对象基本概念

1. 对象的两大要素：属性和操作
2. 类是对具有相同属性和操作的相似对象的抽象
3. 消息
4. 封装是对象和类的一个基本特性

类与类之间的关系：继承、多态、关联、依赖、实现、聚集与组合

统一建模语言UML

二、面向对象的分析

面向对象分许，首要是建模，通常要建立四类模型

1. 对象模型（静态模型），用类和对象表示，该模型主要关心系统中对象的结构、属性与操作，以及对象与对象之间关系的映射。对象模型是对客观世界的对象及对象彼此间的关系静态结构的描述。
    - 类图和对象图
2. 功能模型（用例模型），由用例和场景表示，反映用户对目标系统的需求，描述数据在系统中的变换过程及系统的功能。
    - 用例图
3. 动态行为模型（动态模型），由状态机图和交互图表示的，动态模型定义对象模型中对象的变化序列和生命周期，描述系统中不同对象类之间的交互。
    - 顺序图（时序图）或通信图
    - 状态图或活动图
4. 物理实现模型，由构件图和部署图表示的。

面向对象建模

- 对象模型：描述数据结构（UML 图）
- 动态模型：描述交互和次序（状态图）
- 功能模型：功能模型作用在对象模型说明的数据上，同时还表示了对对象值的约束

对象的特点：标识唯一性、分类性/抽象性、多态性、封装性

面向对象的特点：封装、继承、多态

### 软件编码

表驱动法（Table-Driven Methods）是一种编程模式，从表里面查找信息而不使用逻辑语句（if 和 case） ，它的好处是消除代码里面到处出现的 if、else、swith 语句，让凌乱代码变得简明和清晰。逻辑越来越复杂，表驱动法就越有吸引力。

程序调试方法

- 简单调试，在程序中插入打印语句、运行程序、借助调试工具
- 归纳法，从特殊推断一般的方法，从线索出发，通过分析线索之间的关系找到问题
- 演绎法，从一般推特殊，设想可能的原因，用已有的数据排除不合理的假设
- 回溯法，确定发生错误的地方，沿着程序的控制流往回追溯

### 软件测试

测试阶段

- 单元测试：对最小最基本的软件设计模块进行验证，通常情况下是白盒的，主要针对程序设计、业务逻辑、代码风格进行测试，目的是尽早发现不易显现的错误
- 集成测试：将各模块按照程序结构图组合起来测试，目的是通过测试发现与模块接口有关的问题
  - 增量集成：逐步集成，分为自顶向下的集成和自底向上的集成，自顶向下是从主模块开始，按照深度优先或广度优先的策略集成，自底向上是从系统结构图的最底层模块开始集成
  - 非增量集成：一次将所有模块组合起来测试，一步到位
- 系统测试：基于系统整体需求的黑盒类测
- 回归测试：目的是判断代码修改有没有对软件已有功能引入新的问题
- 验收测试
  - alpha 测试：由用户在开发者的场所进行，内部测试，环境受控
  - beta 测试：由用户在用户场所进行，在开放环境测试，环境不受控，是软件发布前的最后测试

白盒测试，测试者完全了解程序的结构和处理过程，根据程序的内部逻辑设计测试用例，检查逻辑通路是否符合预期

- 逻辑覆盖测试的六个级别（发现错误的能力由弱到强）
  1. 语句覆盖，每条语句至少执行一次
  2. 判定覆盖（分支覆盖），覆盖每个判定分支（**2和3是并列的**）
  3. 条件覆盖，覆盖判定条件的每个取值
  4. 判定/条件覆盖，同时满足判定覆盖和条件覆盖
  5. 条件组合覆盖，覆盖所有判定条件的所有取值组合
  6. 路径覆盖，覆盖每条可能的路径
- 控制结构测试
  1. 基本路径测试
  2. 条件测试
  3. 循环测试

黑盒测试，测试者不关心程序的内部结构，而是根据功能来设计测试用例，检查程序的功能是否符合要求

- 等价类划分法，将系统的输入域划分为若干部分，从每个部分选取少量代表性数据进行测试。可分为有效等价类和无效等价类。
- 边界值分析法，优先选择不同等价类的边界值进行测试，因此该方法要和等价类划分法结合使用。
- 错误推测法，人们根据经验、直觉和简单的判断来推测程序中可能存在的各种错误，从而有针对性地设计测试用例。
- 因果图法，通过因果图获得判定表
- 判定表驱动分析法，判定表可以把复杂的逻辑组合表达的非常明确
- 正交实验设计法，从大量实验点中挑出适量有代表性的点进行测试

### 软件维护

软件可维护性的决定因素：可理解性、可测试性、可修改性、可移植性、可重用性

软件可维护性的提高方法：

1. 使用先进的软件开发工具（版本管理，测试工具，调试工具）
2. 明确软件的质量目标和优先级
3. 进行质量保证审查
4. 选择可维护的程序设计语言
5. 详细的设计文档、结构文档、代码文档、维护文档、接口文档（改善可理解性）
6. 良好的软件设计（模块化、高内聚、低耦合、可测试）

### 软件工程中的图

1. 系统流程图，描述系统的功能模型，描绘现在系统和目标系统的概貌。一个系统可以包含人员、硬件、软件等多个子系统。系统流程图以黑盒子形式描述系统的主要成分（硬件设备、程序、文档及各类人工过程等）。表达的是信息在系统各部件之间流动情况。
   - 以概括形式绘图时需要五种符号，加工或处理、输入输出、控制流向、连接或汇合（同于连接同一页的多个图）、换页连接（用于换页连接）
2. 数据流图（DFD），描述系统的功能模型，用于 SA 方法和 SD 方法，描述系统由哪几部分组成，各部分之间的联系，描述了系统数据的流动和处理过程
   - 四种成分，源点和终点、加工、数据存储、数据流
   - 数据流图分为两种典型结构，变换型结构和事务型结构。
     - 变换型结构由三部分组成：输入、变换（数据加工、中心变换)和输出。
     - 事务型结构由三层组成：事务层、操作层和细节层。发出多条路径的数据流中枢被称为“事务中心”，要完成3项基本任务，接受事务（输入数据）、分析每个事务以确定其类型、根据事务类型选一条活动路径。
3. 层次方框图，描述系统的数据模型，用于需求分析，由一个个矩形框构成树形结构，描述数据的层次结构
4. 维纳图（Warnier-Orr），描述系统的数据模型，用于需求分析，和层次方框图类似，也是描述数据的层次结构，用大括号、异或符号和圆括号构建一个树状结构
5. IPO 图，用于需求分析，IPO 图是输入—处理—输出图（Input-Process-Output）的简称，是美国 IBM 公司发展完善起来的一种图形工具。
6. 软件结构图（Structure Chart，SC），用于软件结构设计，用来表达软件的组成模块及其调用关系，是一种树状图。一般包括，模块、模块间调用关系、辅助符号
   - 辅助符号，弧形箭头表示循环调用；菱形表示选择或者条件调用
7. 层次图，用于软件结构设计，是一种由矩形框构成的树状图，表示模块之间的调用关系
8. HIPO 图（Hierarchy Plus Input-Process-Output），用于软件结构设计，是层次图加上输入—处理—输出图，是美国 IBM 公司发展起来的一种层次结构的描述工具
9. 程序流程图，用于软件详细设计，使用三种基本控制结构描述程序执行流程。
10. 盒图（N-S图），用于软件详细设计，也是顺序、选择、循环三种基本结构
11. PAD图，PAD（Problem Analysis Diagram）问题分析图是日本日立公司于1979年提出的一种算法描述工具。有六种基本结构。
12. 用例图，用于面向对象分析中功能模型，包括包含关系（<\<include>>）、扩展关系（<\<extend>>）、泛化关系（三角形箭头）、使用关系（<\<use>>）
13. 对象和类图，用于面向对象分析中对象模型
14. 顺序图（时序图），用于面向对象分析中动态模型
    - 强调交互的时间顺序
15. 通信图，用于面向对象分析中动态模型
    - 强调交互的空间结构
16. 状态图，用于面向对象分析中动态模型，活动图和状态图都是状态机的表现形式
17. 活动图，活动图可以分区，分区后的图被称为泳道图，每个分区都是一个对象的负责范围，属于某个对象的负责的活动会被放到这个对象的分区
18. 构件图，用于面向对象分析中物理实现模型，构件是指一个可装配的独立物理块，一般是一个文件
19. 部署图，用于面向对象分析中物理实现模型

## 信息安全



## office

快捷键

- 保存、搜索（略）
- 打开文件：ctrl+o
- 新建文件：ctrl+n
- 打印：ctrl+p

退出操作

- 双击左上角
- 左/右键单击左上角，选关闭
- 右键单击标题栏中间，选关闭
- 单击右上角红叉
- 文件->关闭
- alt+f4

## word

1. 两种编辑方式，插入和改写（使用 insert 键调整）
2. 查找和替换，开始->编辑->替换，或者开始->编辑->查找->高级查找
3. 缩进方式，左缩进，右缩进，首行缩进，悬挂缩进
4. 标尺的作用，定位、对齐和缩进等。
   - 小三角用来调整缩进（左缩进，右缩进，首行缩进），小方块用来设置制表位的对齐方式。
   - 拖动标尺边界，可以设置页边距
5. 在快速选择区三击，可选择整篇文章

## excel

1. 一个 excel 文件最多有 255 个工作表
2. 工作簿是指大的 excel 文档，工作表是指里面的 sheet1、sheet2
3. 公式以等号开头
4. 每个单元格最多可以容纳约 32000 个字符

### 公式与函数

1. 单元格引用
   - 绝对引用和相对引用，列表或行标前面带`$`符时为绝对引用，不带时为相对引用
   - 引用一个单元格，A1
2. 引用运算符
   - 引用一个单元格区域，A1:B3
   - 引用多个单元格区域，(A1:B3,C1:D3)
   - 引用两个单元格的相交区域，(A1:B3 C1:D3)
3. 运算符优先级：- > % > ^ > (\*、/) > (+、-) > & > 比较

## powerpoint

播放快捷键：f5

### 模板

- 人们通常说的模板是指别人做好的 ppt 文件，我们拿到后可以在其基础上做修改
- ppt 提供了和模板相关的两种功能，**母版和主题**
  - 母版用来定义一些可复用的版式。（操作：视图->幻灯片母版）
  - 主题比母版高级，每个主题里面都包含一套母版，还另外做了统一的配色、字体、效果等。主题做好后会导出成 thmx 文件（操作：设计->主题）
- **官方提供的模板**，官方的模板是以 pot/potx 格式提供的，官方的模板可以直接在新建文件界面搜索和选择

## 程序设计

结构化程序三种基本结构：顺序、分支、循环，goto 语句属于无条件跳转语句，属于非结构化程序

## c 程序基本结构

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

#define mydef 0

struct mystruct {
  int a;
  char *b;
}

int main() {
  return 0;
}
// 标准输入输出
int a;
scanf("%d",&a);
printf("%d",a);
// 按行
char * in = char[100];
char * out = "123";
char * res = gets(in); //返回字符串或NULL
int res = puts(out); //返回长度或EOF
//按字符
int res = getchar(); //返回字符或EOF
int res = putchar(c);//返回字符或EOF

// 文件操作
// 打开关闭文件
FILE * f = fopen("/data/input","r") //r读，w写，a追加
int status = fclose(f)
// 读写字符
char * in = char[100];
char * out = "123";
char * res = fgets(in,10,f); //返回字符串或NULL
int res = fputs(out,f); //返回长度或EOF
int res = fgetc(f);
int res = fputc(c,f);
// 读写块
char buffer[100];
char c[] = "This is w3schools";
int res = fread(buffer, strlen(c)+1,1,f) //参数：buffer，块大小，块个数，文件，返回读取长度
int res = fwrite(buffer, strlen(c)+1,1,f) //参数：buffer，块大小，块个数，文件，返回写入长度

//初始化结构体
struct mystruct mst = {1,NULL};
//数组
int a[5] = {2, 3, 4, 4, 7};
//指针
int *b = (int *)malloc(sizeof(int)*5);
b = (int *)realloc(b, sizeof(int)*10);
free(b)
//字符串/内存操作
char *s1 = "123";
char *s2 = "234";
char *res = strcat(s1,s2); //s2拼接到s1的末尾
char *res = strncat(s1,s2,n); //把s2的前n个字符拼接到s1的末尾
int res = strcmp(s1,s2);  //s1>s2，返回大于0，s1<s2，返回小于0，s1=s2，返回等于0，
int res = strncmp(s1,s2,n); //比较前n个字符
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
int memcmp(const void *str1, const void *str2, size_t n)
void *memcpy(void *dest, const void *src, size_t n)
void *memmove(void *dest, const void *src, size_t n)
void *memset(void *str, int c, size_t n)
// math，操作数都是double
b = exp(a)  //e^x
b = pow(x,y)  //x^y
b = sqrt(a) //平方根
b = log(a)  //自然对数，基数为e
b = log10(a)  //基数为10
b = fabs(a) //绝对值
b = ceil(a) //向上取整
b = floor(a)  //向下取整
b = sin/cos/tan(a)  //三角函数

```

## java 程序基本结构

```java

public class Hello{
  public static void main(String []args){
    System.out.println("Hello World");
  }
}

//import
import java.util.Scanner;
import java.lang.String;
import java.lang.Integer;
import java.lang.Double;
import java.io.*;
import java.io.FileWriter;
import java.io.IOException;

//标准输入输出
Scanner scan = new Scanner(System.in);
if(scan.hasNext()){     //按单词输入
  String str1 = scan.next();
}
Scanner scan = new Scanner(System.in);
if(scan.hasNextLine()){   //按行输入
    String str2 = scan.nextLine();
}
System.out.println("Hello World");

//类型转换
String.valueOf(xxx) //万物转String
//int和String互转
Integer.toString(xxx) //int、Integer转String
Integer a = Integer(5)
a.toString(xxx) //Integer转String
Integer.valueOf("...")  //String转Integer
Integer.valueOf("...").intValue()  //String转int
Integer.parseInt("...")  //String转int
//其他类型和String互转大同小异

//异常处理（捕获全部异常）
try{}catch(Exception e){
   System.out.println("Exception thrown  :" + e);
}
//序列化到文件
try{
    FileOutputStream fileOut = new FileOutputStream("data/out");
    ObjectOutputStream out = new ObjectOutputStream(fileOut);
    out.writeObject(e);
    out.close();
    fileOut.close();
}catch(IOException e){
    e.printStackTrace();
}
//从文件反序列化
Employee e = null;
try{
    FileInputStream fileIn = new FileInputStream("/tmp/employee.ser");
    ObjectInputStream in = new ObjectInputStream(fileIn);
    e = (Employee) in.readObject();
    in.close();
    fileIn.close();
}catch(IOException i){
    i.printStackTrace();
    return;
}catch(ClassNotFoundException c){
    c.printStackTrace();
    return;
}
//读写文件
//写（FileWriter）
try {
  FileWriter myWriter = new FileWriter("filename.txt");
  myWriter.write("Files in Java might be tricky, but it is fun enough!");
  myWriter.close();
} catch (IOException e) {
  e.printStackTrace();
}
//读（Scanner）
try {
  File myObj = new File("filename.txt");
  Scanner myReader = new Scanner(myObj);
  while (myReader.hasNextLine()) {
    String data = myReader.nextLine();
    System.out.println(data);
  }
  myReader.close();
} catch (FileNotFoundException e) {
  e.printStackTrace();
}
//arraylist
ArrayList<Integer> myNumbers = new ArrayList<Integer>();
myNumbers.add(33);
myNumbers.remove(0);  //按下标删
myNumbers.get(0); //按下标获取
myNumbers.size(); //获取大小
for(int i =0;i<myNumbers.size();++i){
  myNumbers.get(i);
}
//hashmap
HashMap<Integer,String> mymap = new HashMap<Integer,String>();
mymap.put(3,"11")
mymap.get(3)
mymap.remove(3)
mymap.size()
for (Map.Entry<String, String> entry : map.entrySet()) {
    String mapKey = entry.getKey();
    String mapValue = entry.getValue();
    System.out.println(mapKey + "：" + mapValue);
}
for (String key : map.keySet()) {
  System.out.println(key);
}
for (String value : map.values()) {
  System.out.println(value);
}
//String操作
String s2  = "Hello".substring(1, 4); // 开始和结束索引
String[] parts = str.split(",");  //切分
String res = String.join(",",parts);  //拼接
s2.length();  //获取字符串长度
//math
Math.abs(a)
Math.max(a,b)
Math.min(a,b)
Math.ceil(a,b)
Math.exp(a)
Math.pow(a,b)
Math.sqrt(a)
Math.log(a)
Math.log10(a)
Math.sin/cos/tan(a)
```
