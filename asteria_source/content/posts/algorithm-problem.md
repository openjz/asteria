---
title: "算法题"
date: 2022-07-06T11:37:09+08:00
# bookComments: false
# bookSearchExclude: false
tags:
  - "算法"
categories:
  - "编程"
---

## 常用方法

常用方法：

1. 动态规划，把问题转化为子问题的求解，在子问题求解完成的基础上即可得到问题的解，重点在于（1）问题的建模，（2）求出正确的递推方程，（3）搞清楚基本问题的解
2. 双指针，重点在于搞清楚什么时候移动哪个指针
3. 二分
4. 回溯（DFS）
5. 分治

常用辅助工具：排序，map，堆，栈，队列

## leetcode 4.寻找两个正序数组的中位数

> 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数

### 方法 1-归并法

方法 1，按归并的思路，每次排除一个数，直到找到中位数为止。时间复杂度 O(m+n)

### 方法 2-改良的归并法

方法 1 是一种比较符合直觉的方法，更进一步，我们考虑每次多排除一些数，以提高算法的执行速度。

**寻找中位数问题可以视为寻找第 k 大数问题的特殊情况**，现在设中位数是第 k 大的数为`Kth`，我们每次比较 k/2 个数，就能每次排除掉 k/2 个数。随着被排除的数逐渐增多，k 会逐渐变小，当 k 变为 1 的时候，比较最后一次，就找到了`Kth`。由于 k 每次缩小一半，时间复杂度为 O(log(m+n))

**这里面有一个关键问题，为什么比较步长是 k/2**？

为了解释这个问题，先看一个例子，

```
A：1，2，3，8
B：4，5，6，7
```

有递增序列 A 和 B，现在我们想找到第 4 大的数（即 4），如果将比较步长设置为 4，即直接比较 7 和 8，会导致 4,5,6,7 全都被排除掉，最后无法找到 4。所以我们必须设置合理的比较步长，来避免这种情况。

下面说明为什么是 k/2

在对位于比较点的两个数做比较后，我们会将较小数及其之前的数排除掉。为了保证一定能够排除较小数及其之前的数，我们必须保证`Kth`不在被排除的数中，换言之，**我们一定不能让位于比较点的两个数都大于`Kth`**。

假设有以下两个序列

```
A：a0,a1,...,am
B: b0,b1,...,bn
```

假设比较步长为 p，位于比较点的两个数是`ap`，`bp`，现在对`Kth`所在位置分情况讨论

1. `ap`和`bp`都在`Kth`之前
2. `ap`在`Kth`之前，`bp`在`Kth`之后（即`Kth∈[b0,bp]`）
3. `ap`在`Kth`之后（即`Kth∈[a0,ap]`），`bp`在`Kth`之前

情况 1 不做讨论，排除哪个都行。

情况 2 和情况 3 是等价的，现在假设`Kth∈[a0,ap]`，即`a0 <= kth <= ap`，如果我们想排除`[b0,bp]`，就必须保证`bp <= Kth <= ap`，即不能让位于比较点的两个数都大于等于`Kth`

当比较步长 p 为 k/2 时，`[a0,ap]`和`[b0,bp]`加起来一共 k 个数，如果`ap`和`bp`都大于`Kth`，`[a0,ap]`和`[b0,bp]`加起来一定会超过 k 个数，前后矛盾。所以当比较步长为 k/2 时必不可能出现比较点的两个数都大于`Kth`这个情况，反之当比较步长大于 k/2 时，被比较的两个子序列的数字量大于 k，就有可能出现这个情况。

相应的，如果有三个有序数列，比较步长最长为 k/3，有四个序列，比较步长最长为 k/4，以此类推。

### 方法 3-二分法

方法 2 是将问题转化为求第 K 大的数，而方法 3 是利用了中位数的以下性质：

1. 中位数两边的数个数相等
2. 中位数左边最大的数小于右边最小的数、

具体方法是分别将序列 1 和序列 2 一分为 2，将左序列 1+左序列 2 视为左半部分，将右序列 1+右序列 2 视为右半部分，保证左半部分的数字个数等于右半部分的数字个数，并且左半部分的最大值大于右半部分的最小值。

那如何找到切分位置？在较短序列上进行二分搜索即可

## leetcode 10.正则表达式匹配

> 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持'.'和'\*'的正则表达式匹配。
>
> - '.'匹配任意单个字符
> - '\*'匹配零个或多个前面的那一个元素
>
> 所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。

用动态规划求解

1. 将问题转化为求`f[i][j]`的问题，`f[i][j]`指字符串 s 的前 i 个字符和模式 p 的前 j 个字符是否匹配。
2. 以下是该问题的求解方程
   ```
   # 注意，p[0]和s[0]对应的是f[1][1]
   1. 当p[j-1]不是'*'时，
       如果p[j-1]和s[i-1]匹配，
           f[i][j] = f[i-1][j-1]
       否则
           f[i][j] = false
   2. 当p[j-1]是'*'时（要看'*'前面那个字符），
       如果p[j-2]不和s[i-1]匹配(字母和'*'的组合被干掉)，
           f[i][j] = f[i][j-2]
       否则，既可以字母和'*'的组合被干掉也可以s[i-1]被干掉
           f[i][j] = f[i][j-2] or f[i-1][j]
   ```
3. 当 s 和 p 都为空时，视为匹配，即`f[0][0]=True`。p 为空，s 为空时，一定不匹配，即`f[0][x]=False`。**而 s 为空，p 不为空时，不一定匹配，例如 p 为`a*a*`时，可以和空串形成匹配，因此在循环时，i 要从 0 开始，j 可以从 1 开始**。

## leetcode 5.求最长回文子串

> 给你一个字符串 s，找到 s 中最长的回文子串。
>
> 示例 1：
>
> 输入：s = "babad"  
> 输出："bab"  
> （"aba" 同样是符合题意的答案。）

使用动态规划求解

将问题转换为求`f[i][j]`的问题，`f[i][j]`是指 s 的子串`s[i,j]`是否为回文串，求`f[i][j]`之前要先求出`f[i+1][j-1]`

## leetcode 11.盛水最多的容器

> 给定一个长度为 n 的整数数组  height 。有  n  条垂线，第 i 条线的两个端点是  (i, 0)  和  (i, height[i]) 。
>
> 找出其中的两条线，使得它们与  x  轴共同构成的容器可以容纳最多的水。
>
> 返回容器可以储存的最大水量。

用双指针法求解，双指针的初始位置位于数组两端，不断向中间逼近，每次移动高度较低的指针（移动指针会导致容器底部变小，为了寻找更大的容积，就要舍弃较低的边，保留较高的边）

## leetcode 15.三数之和

> 给你一个包含 n 个整数的数组  nums，判断  nums  中是否存在三个元素 a，b，c ，使得  a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。

三数之和要求对组合去重，这个问题和两数之和有所不同，在两数之和问题中，每个数只能属于一个组合，所以，要对组合去重，只要给已经构成组合的数打标记即可，不用对组合打标记。但是对三数之和问题不能采用这种去重方法，因为一个数可以属于多个组合，如果要采用打标记这种方式，必须对组合打标记，不能对数打标记。

因此，通过打标记去重在三数之和问题中不可行

采用排序+双指针的方法，可以在 O(n^2)的时间复杂度内完成求解

## leetcode 23.合并 K 个升序链表

> 给你一个链表数组，每个链表都已经按升序排列。
>
> 请你将所有链表合并到一个升序链表中，返回合并后的链表。

设链表个数为 k，节点总数为 n

方法 1，从 k 个链表的开头各拿出一个节点，从这 k 个节点中选取一个最小的链接到大链表中，利用堆选取最小元素，堆操作的时间复杂度是 O(logk)，一共 n 个节点，总的时间复杂度为 O(nlogk)

方法 2，对 k 个链表进行两两归并，归并次数是 logk，归并的时间复杂度是 O(n)，总的时间复杂度是 O(nlogk)

方法 2 的归并策略是尽量降低归并次数，还有另外一种归并策略是尽量降低比较次数，具体方法是每次选取长度最短的两个序列进行归并，但是由于本题是对链表进行归并，无法快速获取序列长度，因此无法采用这种策略

## leetcode 31.下一个排列

> 给你一个整数数组 nums，找出 nums 的下一个排列。
>
> 必须原地修改，只允许使用额外常数空间。

思路

如果序列最后两个元素是正序，直接交换这两个元素即可

在剩下的情况中，每个排列都可以分成前后两个子序列 a，b，并且子序列 b 是一个倒序序列

例如，

[1,2,5,4,3] = a+b = [1,2]+[5,4,3]

此时子序列 b 自己没有下一个排列，要想为 nums 找到下一个排列，必须把 a 的最后一个元素和 b 中的一个元素交换，这个元素必须刚好大于 a。交换后，子序列 b 仍然是一个倒序序列，将 b 翻转，就完成了求解

两次遍历，一次翻转，时间复杂度为 O(n)，第二次遍历可以改成二分查找，但是总的时间复杂度仍然是 O(n)

## leetcode 32.最长有效括号

> 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

```golang
//策略：')'决定是否有效，有效时更新max，遍历完成后，不管stack为空还是不为空，都结束
//1. 当前为')'，匹配后stack为空，[start,cur]有效，更新max，cur+1
//2. 当前为')'，匹配后stack不为空，[top+1,cur]有效，更新max，cur+1
//3. 当前为')'，stack为空，无匹配，[start,cur]无效，start和cur都移动到cur+1位置
//4. 当前为'('，入栈，cur+1
```

## leetcode 81. 搜索旋转排序数组 II

> 在旋转数组中搜索目标值 target，旋转数组中有重复数组

思路很简单，在旋转数组上的任意位置切分，切成两个数组，其中一定有一个数组是有序的，可以在这个有序数组上进行二分查找，如果找不到，在另一个数组上递归。

处理流程：

1. 对于数组 a[start,end]，计算中间位置 mid
2. 如果 a[mid] == target，返回mid
3. 如果 a[mid] > a[left]，左半边一定有序，先在左半边二分查找，再在右半边递归
4. 如果 a[mid] < a[left]，右半边一定有序，先在右半边二分查找，再在左半边递归
5. 否则，直接依次在两边递归。（注：这种情况没必要考虑那么多复杂的边界情况，因为无论进行多少判断，最坏情况下时间复杂度都会退化到O(n)）
