---
title: "算法题"
date: 2022-07-06T11:37:09+08:00
# bookComments: false
# bookSearchExclude: false
tags:
  - "算法"
categories:
  - "编程"
---

## 常用方法

常用方法：

1. 动态规划，把问题转化为子问题的求解，在子问题求解完成的基础上即可得到问题的解，重点在于（1）问题的建模，（2）求出正确的递推方程，（3）搞清楚基本问题的解
2. 双指针，重点在于搞清楚什么时候移动哪个指针
3. 二分
4. 回溯（DFS）
5. 分治

常用辅助工具：排序，map，堆，栈，队列

## leetcode 4.寻找两个正序数组的中位数

> 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数

### 方法 1-归并法

方法 1，按归并的思路，每次排除一个数，直到找到中位数为止。时间复杂度 O(m+n)

### 方法 2-改良的归并法

方法 1 是一种比较符合直觉的方法，更进一步，我们考虑每次多排除一些数，以提高算法的执行速度。

**寻找中位数问题可以视为寻找第 k 大数问题的特殊情况**，现在设中位数是第 k 大的数为`Kth`，我们每次比较 k/2 个数，就能每次排除掉 k/2 个数。随着被排除的数逐渐增多，k 会逐渐变小，当 k 变为 1 的时候，比较最后一次，就找到了`Kth`。由于 k 每次缩小一半，时间复杂度为 O(log(m+n))

**这里面有一个关键问题，为什么比较步长是 k/2**？

为了解释这个问题，先看一个例子，

```
A：1，2，3，8
B：4，5，6，7
```

有递增序列 A 和 B，现在我们想找到第 4 大的数（即 4），如果将比较步长设置为 4，即直接比较 7 和 8，会导致 4,5,6,7 全都被排除掉，最后无法找到 4。所以我们必须设置合理的比较步长，来避免这种情况。

下面说明为什么是 k/2

在对位于比较点的两个数做比较后，我们会将较小数及其之前的数排除掉。为了保证一定能够排除较小数及其之前的数，我们必须保证`Kth`不在被排除的数中，换言之，**我们一定不能让位于比较点的两个数都大于`Kth`**。

假设有以下两个序列

```
A：a0,a1,...,am
B: b0,b1,...,bn
```

假设比较步长为 p，位于比较点的两个数是`ap`，`bp`，现在对`Kth`所在位置分情况讨论

1. `ap`和`bp`都在`Kth`之前
2. `ap`在`Kth`之前，`bp`在`Kth`之后（即`Kth∈[b0,bp]`）
3. `ap`在`Kth`之后（即`Kth∈[a0,ap]`），`bp`在`Kth`之前

情况 1 不做讨论，排除哪个都行。

情况 2 和情况 3 是等价的，现在假设`Kth∈[a0,ap]`，即`a0 <= kth <= ap`，如果我们想排除`[b0,bp]`，就必须保证`bp <= Kth <= ap`，即不能让位于比较点的两个数都大于等于`Kth`

当比较步长 p 为 k/2 时，`[a0,ap]`和`[b0,bp]`加起来一共 k 个数，如果`ap`和`bp`都大于`Kth`，`[a0,ap]`和`[b0,bp]`加起来一定会超过 k 个数，前后矛盾。所以当比较步长为 k/2 时必不可能出现比较点的两个数都大于`Kth`这个情况，反之当比较步长大于 k/2 时，被比较的两个子序列的数字量大于 k，就有可能出现这个情况。

相应的，如果有三个有序数列，比较步长最长为 k/3，有四个序列，比较步长最长为 k/4，以此类推。

### 方法 3-二分法

方法 2 是将问题转化为求第 K 大的数，而方法 3 是利用了中位数的以下性质：

1. 中位数两边的数个数相等
2. 中位数左边最大的数小于右边最小的数、

具体方法是分别将序列 1 和序列 2 一分为 2，将左序列 1+左序列 2 视为左半部分，将右序列 1+右序列 2 视为右半部分，保证左半部分的数字个数等于右半部分的数字个数，并且左半部分的最大值大于右半部分的最小值。

那如何找到切分位置？在较短序列上进行二分搜索即可

## leetcode 10.正则表达式匹配

> 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持'.'和'\*'的正则表达式匹配。
>
> - '.'匹配任意单个字符
> - '\*'匹配零个或多个前面的那一个元素
>
> 所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。

用动态规划求解

1. 将问题转化为求`f[i][j]`的问题，`f[i][j]`指字符串 s 的前 i 个字符和模式 p 的前 j 个字符是否匹配。
2. 以下是该问题的求解方程
   ```
   # 注意，p[0]和s[0]对应的是f[1][1]
   1. 当p[j-1]不是'*'时，
       如果p[j-1]和s[i-1]匹配，
           f[i][j] = f[i-1][j-1]
       否则
           f[i][j] = false
   2. 当p[j-1]是'*'时（要看'*'前面那个字符），
       如果p[j-2]不和s[i-1]匹配(字母和'*'的组合被干掉)，
           f[i][j] = f[i][j-2]
       否则，既可以字母和'*'的组合被干掉也可以s[i-1]被干掉
           f[i][j] = f[i][j-2] or f[i-1][j]
   ```
3. 当 s 和 p 都为空时，视为匹配，即`f[0][0]=True`。p 为空，s 为空时，一定不匹配，即`f[0][x]=False`。**而 s 为空，p 不为空时，不一定匹配，例如 p 为`a*a*`时，可以和空串形成匹配，因此在循环时，i 要从 0 开始，j 可以从 1 开始**。

## leetcode 5.求最长回文子串

> 给你一个字符串 s，找到 s 中最长的回文子串。
>
> 示例 1：
>
> 输入：s = "babad"  
> 输出："bab"  
> （"aba" 同样是符合题意的答案。）

使用动态规划求解

将问题转换为求`f[i][j]`的问题，`f[i][j]`是指 s 的子串`s[i,j]`是否为回文串，求`f[i][j]`之前要先求出`f[i+1][j-1]`

## leetcode 11.盛水最多的容器

> 给定一个长度为 n 的整数数组  height 。有  n  条垂线，第 i 条线的两个端点是  (i, 0)  和  (i, height[i]) 。
>
> 找出其中的两条线，使得它们与  x  轴共同构成的容器可以容纳最多的水。
>
> 返回容器可以储存的最大水量。

用双指针法求解，双指针的初始位置位于数组两端，不断向中间逼近，每次移动高度较低的指针（移动指针会导致容器底部变小，为了寻找更大的容积，就要舍弃较低的边，保留较高的边）

## leetcode 15.三数之和

> 给你一个包含 n 个整数的数组  nums，判断  nums  中是否存在三个元素 a，b，c ，使得  a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。

三数之和要求对组合去重，这个问题和两数之和有所不同，在两数之和问题中，每个数只能属于一个组合，所以，要对组合去重，只要给已经构成组合的数打标记即可，不用对组合打标记。但是对三数之和问题不能采用这种去重方法，因为一个数可以属于多个组合，如果要采用打标记这种方式，必须对组合打标记，不能对数打标记。

因此，通过打标记去重在三数之和问题中不可行

采用排序+双指针的方法，可以在 O(n^2)的时间复杂度内完成求解

## leetcode 23.合并 K 个升序链表

> 给你一个链表数组，每个链表都已经按升序排列。
>
> 请你将所有链表合并到一个升序链表中，返回合并后的链表。

设链表个数为 k，节点总数为 n

方法 1，从 k 个链表的开头各拿出一个节点，从这 k 个节点中选取一个最小的链接到大链表中，利用堆选取最小元素，堆操作的时间复杂度是 O(logk)，一共 n 个节点，总的时间复杂度为 O(nlogk)

方法 2，对 k 个链表进行两两归并，归并次数是 logk，归并的时间复杂度是 O(n)，总的时间复杂度是 O(nlogk)

方法 2 的归并策略是尽量降低归并次数，还有另外一种归并策略是尽量降低比较次数，具体方法是每次选取长度最短的两个序列进行归并，但是由于本题是对链表进行归并，无法快速获取序列长度，因此无法采用这种策略

## leetcode 31.下一个排列

> 给你一个整数数组 nums，找出 nums 的下一个排列。
>
> 必须原地修改，只允许使用额外常数空间。

思路

如果序列最后两个元素是正序，直接交换这两个元素即可

在剩下的情况中，每个排列都可以分成前后两个子序列 a，b，并且子序列 b 是一个倒序序列

例如，

[1,2,5,4,3] = a+b = [1,2]+[5,4,3]

此时子序列 b 自己没有下一个排列，要想为 nums 找到下一个排列，必须把 a 的最后一个元素和 b 中的一个元素交换，这个元素必须刚好大于 a。交换后，子序列 b 仍然是一个倒序序列，将 b 翻转，就完成了求解

两次遍历，一次翻转，时间复杂度为 O(n)，第二次遍历可以改成二分查找，但是总的时间复杂度仍然是 O(n)

## leetcode 32.最长有效括号

> 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**思路**

使用滑动窗口法配合栈来解决

左括号`'('`入栈，用来和右括号进行匹配，右括号`')'`决定是否匹配到了一个有效的括号序列，有效时更新结果（使用`max`表示结果）。

从滑动窗口起点开始往后遍历。

用`start`表示滑动窗口起点，用`cur`表示当前遍历的位置，用`stack`表示栈，**当遇到右括号时**，共分为以下几种情况

1. 匹配后`stack`为空，代表[`start`,`cur`]有效，更新结果，`cur`+1
2. 匹配后`stack`不为空，[`stack 顶部元素+1`,`cur`]有效，更新结果，`cur`+1
3. `stack`为空，无法匹配，[`start`,`cur`]无效，移动窗口起点，将`start`移动到`cur`位置

遍历完成后，丢掉栈中剩余的左括号

## leetcode 81. 搜索旋转排序数组 II

> 在旋转数组中搜索目标值 target，旋转数组中有重复数组

思路很简单，在旋转数组上的任意位置切分，切成两个数组，其中一定有一个数组是有序的，可以在这个有序数组上进行二分查找，如果找不到，在另一个数组上递归。

处理流程：

1. 对于数组 a[start,end]，计算中间位置 mid
2. 如果 a[mid] == target，返回 mid
3. 如果 a[mid] > a[left]，左半边一定有序，先在左半边二分查找，再在右半边递归
4. 如果 a[mid] < a[left]，右半边一定有序，先在右半边二分查找，再在左半边递归
5. 否则，直接依次在两边递归。（注：这种情况没必要考虑那么多复杂的边界情况，因为无论进行多少判断，最坏情况下时间复杂度都会退化到 O(n)）

## leetcode 53.最大子数组和

> 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 子数组 是数组中的一个连续部分。

本题不适合用滑动窗口法，原因是对于任何一个窗口，必须遍历到数组末尾，才能滑动这个窗口，时间复杂度时间复杂度过高

一个更好的方法是将问题转化为求“以第 n 个数字结尾的子序列中，和最大的子序列之和”

例如，对于 nums = [1,5,4,6]，求以第 4 个数字结尾的子序列中，和最大的子序列之和，我们将这个问题表示为 f(4)

f(4)包含以下子序列

- A = [6]
- B = [4,6]
- C = [5,4,6]
- D = [1,5,4,6]

那么，f(4) = max(A,B,C,D)，其中，和最大的子序列是 D = [1,5,4,6]，因此，f(4) = sum(D) = 16

然而，光求出 f(4)并不能解决问题，如果第四个数字不是 6，是个负数，那么和最大的子序列就不在 f(4)包含的序列中，可能在 f(3)中，或是在 f(2)中

因此，问题最终变成了求 max(f(1), f(2), f(3), f(4))

然后我们发现，f(4)中，子序列 B、C、D 删掉最后一个数字之后得到的序列[4], [5,4], [1,5,4]恰好覆盖了所有以第三个数字结尾的子序列，也就是说，f(4)依赖 f(3)

**这时，f(n)变成了一个动态规划问题：f(n) = max(nums[n], f(n-1)+nums[n])，f(1)=nums[1]**

与此同时我们发现，从第一个数开始，每向后遍历一个位置，就能得到对应位置 i 的 f(i)值，而max(f(1)~f(n))可以在从求 f(1)到求 f(n)的过程中得到，因此本题可以通过对数组做一次遍历完成求解

## leetcode 55.跳跃游戏

>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
>
>数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
>判断你是否能够到达最后一个下标。

思路：

如果某个起跳点值为k，那么这个位置往后的k个位置都能作为新的起跳点

所有的跳法会构成一棵路径树，我们遍历这棵树，如果能在这颗树上找到最后一个位置，说明能跳到最后一个位置

上面是一个比较通用的解法，对于本题，解法可以简化一下

路径树上实际上有很多重复起跳点

如果我们按照广度优先遍历的方式遍历，并且生成新起跳点时只生成比当前最远起跳点更远的起跳点，就能消除重复节点

而节点的遍历顺序恰好和数组的遍历顺序一致，所以我们只要顺序遍历数组，并且维护一个最远起跳点即可

## leetcode 84. 柱状图中最大的矩形

>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
>
>求在该柱状图中，能够勾勒出来的矩形的最大面积。

### 方法1.暴力法

遍历所有柱子，每遍历到一个柱子，求出以这个柱子为高度的矩形大小，怎么求呢？以这个柱子为中心，分别向左右两边遍历，找到第一个高度小于它的柱子，此时这两个高度小于它的柱子就是矩形的边界。

时间复杂度为O(n^2)，需要假设数组两端有两个高度为0的虚拟柱子，作为所有矩形的边界。

### 方法2.分治法

遍历一遍，找到高度最低的柱子，此时这个高度最低的柱子把所有柱子分为左右两部分，由于分界点是高度最低的柱子，左右两边所有高度高于这个柱子的矩形都不可能向另外一边扩展，这就给了我们分治的可能性。

最大的矩形面积 = max(以高度最低的柱子为高度的矩形面积, 左半部分最大矩形面积, 右半部分最大矩形面积）

平均时间复杂度为O(nlogn)，但在最坏情况下时间复杂度会退化到O(n^2)。（有点类似快速排序）

### 方法3.单调栈法

单调栈是指栈中的数要么单调递增，要么单调递减

我们发现一个现象，从左向右遍历柱子，如果当前遍历到的柱子比上一个柱子低，那么以上一个柱子为高度的矩形不可能朝右边扩展。如果我们将高度递增的柱子依次入栈，遇到高度递减的柱子时停下来，就可以确定以栈顶柱子为高度的矩形的面积，矩形的宽度是栈顶柱子和栈中第二个柱子之间的距离。在遍历的过程中随时更新最大值max。

时间复杂度为O(n)

注意两点：

1. 矩形的面积是栈顶柱子距离栈中第二个柱子的距离，而不是它左边紧挨着的柱子的距离。（栈中的两个柱子之间可能隔着很多已经出栈的柱子）
2. 栈中相邻的柱子高度可以相等，不会影响最终结果，两个相邻的高度相等的柱子，先入栈的柱子构建的矩形面积肯定大于后入栈的柱子构建的矩形面积

## leetcode 42. 接雨水

>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

这道题和上一道题一样，也是一道使用单调栈法解决的题，和上一道题不同，这个题的栈是递减栈，把高度递减的柱子入栈，遇到高度递增的柱子停下求以这个柱子为界能接的雨水。

如果一个柱子比上一个柱子高度更高，那以这个柱子为界能接的雨水 = 以前一个柱子为界能接的雨水量 + 比上一个柱子多出来的高度能接的雨水量

如果一个柱子比上一个柱子更低，以这个柱子为界能接的雨水量和上一个柱子相等

遍历到最后一个柱子时所求出的接雨水量就是最终的累计雨水量

