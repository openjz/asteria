---
title: "《effective C++》阅读笔记"
date: 2025-02-07T16:03:06+08:00
draft: false

tags: ["c/c++"]
categories: ["编程"]
---

## 第二条：少用#define，用const, enum, inline代替#define

#define定义的名字会被预处理器替换为它的值，这回导致定位问题困难，因为不管是编译报错还是dump文件调用栈里面的名字都是#define的值，而不是#define的名字，跟代码完全对不上

尤其是#define定义的函数宏，难以阅读，难以维护

## 第三条：多用const 及 const的正确用法

### const是什么

const是一个语义约束，告诉编译器某个对象不该被修改。

const用在指针上时，分为顶层const和底层const

### 将函数返回值定义为const有什么用

将函数返回定义为const，可以避免用户写出这样的东西：`a * b = 6`，（a和b是两个自定义类型的对象，如果a和b是内置类型，这么做当然是不合法的），以下代码就是个例子：

```c++
class CNum
{
public:
    //1. 构造函数定义了一个从内置类型int到CNum的隐式类型转换
	CNum(int n) :_n(n) {}
    //2. 重载了拷贝复制运算符
	CNum& operator=(const CNum& num)
	{
		_n = num._n;
	}
private:
	int _n;
};

//3. 重载了乘法运算符
CNum operator*(const CNum& a, const CNum& b)
{
	return a * b;
}

int main(int argc, char**argv)
{
	CNum a(1);
	CNum b(2);
    //4. 然后就能写出下面这样的东西
	a * b = 6;
	return 0;
}
```

如果我们在上面这段代码中让重载乘法运算符返回一个const值，就能避免`a * b = 6`这样的写法

### const成员函数怎么用

const对象只能调用const成员函数

**const有两种，一种是bitwise constness（physical constness），字面翻译是物理const，第二种是logical constness，即逻辑const**，这两种const有什么区别呢，下面给出两个例子，

**例一**：一个对象有一个指针成员，如果我们在一个const成员函数里改了指针指向的内容，而没有改指针本身，这种const属于bitwise constness，即我们没有修改对象的任何一个成员，哪怕一个bit，但不属于logical constness，因为从逻辑上讲实际上我们改东西了，只不过改的不是成员本身的值，改的是它指向地址里的内容。这种情况编译器不会报错，编译器只认bitwise constness。

**例二**：和例一相反，我们有一个const成员函数length，是获取对象的长度，但是获取的时候呢，我们希望更新一下内部的一个长度变量的值，从逻辑上讲，调用length函数的用户肯定对更新变量是无所谓的（它只是对长度的一个缓存而已），但编译器不同意，它不允许你去修改任何一个成员。

像例二这种情况，我们的解决办法是将长度变量定义为`mutable`

我们在编写const函数时，最好是基于logical constness的原则，因为这更符合人类的思维

当同一个成员函数要同时定义const和非const两个版本时，为了避免代码重复，最好让非const版去调用const版，而不要反过来，因为那会打破const函数不修改任何东西的承诺（而且还需要引入类似`const_cast`这样的特性，这不是个好兆头）


