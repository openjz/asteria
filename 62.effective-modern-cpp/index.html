<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>《Effective Modern C&#43;&#43;》阅读笔记 - 星</title><meta name="Description" content=""><meta property="og:title" content="《Effective Modern C&#43;&#43;》阅读笔记" />
<meta property="og:description" content="条款1：模板类型推导 c&#43;&#43;模板类型推导经常用在模板函数类型推导，和auto类型推导 函数模板一般是以下形式 1 2 template&lt;typename T&gt; void f(ParamType param); ParamType和T" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.shiwj.top/62.effective-modern-cpp/" /><meta property="og:image" content="http://blog.shiwj.top/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-04-09T16:22:06+08:00" />
<meta property="article:modified_time" content="2025-05-16T00:20:35+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://blog.shiwj.top/logo.png"/>

<meta name="twitter:title" content="《Effective Modern C&#43;&#43;》阅读笔记"/>
<meta name="twitter:description" content="条款1：模板类型推导 c&#43;&#43;模板类型推导经常用在模板函数类型推导，和auto类型推导 函数模板一般是以下形式 1 2 template&lt;typename T&gt; void f(ParamType param); ParamType和T"/>
<meta name="application-name" content="星">
<meta name="apple-mobile-web-app-title" content="星"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://blog.shiwj.top/62.effective-modern-cpp/" /><link rel="prev" href="http://blog.shiwj.top/61.understand-scitools-keygen/" /><link rel="next" href="http://blog.shiwj.top/63.affine-transformation/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "《Effective Modern C++》阅读笔记",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/blog.shiwj.top\/62.effective-modern-cpp\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "http:\/\/blog.shiwj.top\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048 
                        }],"genre": "posts","keywords": "c\/c\u002b\u002b","wordcount":  8265 ,
        "url": "http:\/\/blog.shiwj.top\/62.effective-modern-cpp\/","datePublished": "2025-04-09T16:22:06+08:00","dateModified": "2025-05-16T00:20:35+08:00","publisher": {
            "@type": "Organization",
            "name": "shiwj","logo": {
                    "@type": "ImageObject",
                    "url": "http:\/\/blog.shiwj.top\/images\/avatar.png",
                    "width":  690 ,
                    "height":  690 
                }},"author": {
                "@type": "Person",
                "name": "shiwj"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 全部 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i>  </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">全部</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">《Effective Modern C&#43;&#43;》阅读笔记</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/openjz" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>shiwj</a>
</span>&nbsp;<span class="post-category">included in <a href="/categories/%E7%BC%96%E7%A8%8B/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>编程</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2025-04-09">2025-04-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;8265 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;17 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#条款1模板类型推导">条款1：模板类型推导</a>
      <ul>
        <li><a href="#1paramtype是指针或引用但不是万能引用">1.ParamType是指针或引用，但不是万能引用</a></li>
        <li><a href="#2paramtype是万能引用">2.ParamType是万能引用</a></li>
        <li><a href="#3paramtype既非引用也非指针">3.ParamType既非引用也非指针</a></li>
        <li><a href="#数组和函数实参推导">数组和函数实参推导</a>
          <ul>
            <li><a href="#数组实参推导">数组实参推导</a></li>
            <li><a href="#函数实参推导">函数实参推导</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#条款2auto类型推导">条款2：auto类型推导</a></li>
    <li><a href="#条款3decltype">条款3：decltype</a></li>
    <li><a href="#条款4如何查看类型推导结果">条款4：如何查看类型推导结果</a></li>
    <li><a href="#条款8nullptr">条款8：nullptr</a></li>
    <li><a href="#条款9using-和-typedef">条款9：using 和 typedef</a></li>
    <li><a href="#条款10优先使用-enum-class-而不是-enum">条款10：优先使用 enum class 而不是 enum</a></li>
    <li><a href="#条款11优先使用--delete-而不是-private声明">条款11：优先使用 <code>= delete</code> 而不是 private声明</a></li>
    <li><a href="#条款14不抛出异常的函数尽量声明为noexcept的">条款14：不抛出异常的函数，尽量声明为noexcept的</a></li>
    <li><a href="#条款17特殊成员函数的生成规则">条款17：特殊成员函数的生成规则</a></li>
    <li><a href="#条款18unique_ptr">条款18：unique_ptr</a></li>
    <li><a href="#条款19shared_ptr">条款19：shared_ptr</a></li>
    <li><a href="#条款20weak_ptr">条款20：weak_ptr</a>
      <ul>
        <li><a href="#基本操作检查资源有效性">基本操作：检查资源有效性</a></li>
        <li><a href="#循环引用问题">循环引用问题</a></li>
        <li><a href="#weak_ptr的使用原则">weak_ptr的使用原则</a></li>
      </ul>
    </li>
    <li><a href="#条款21优先使用-make_shared-和-make_unique">条款21：优先使用 make_shared 和 make_unique</a></li>
    <li><a href="#条款23stdmove-和-stdforward">条款23：std::move 和 std::forward</a></li>
    <li><a href="#条款24区分右值引用和万能引用">条款24：区分右值引用和万能引用</a></li>
    <li><a href="#条款25对右值引用用stdmove对万能引用用stdforward">条款25：对右值引用用std::move，对万能引用用std::forward</a></li>
    <li><a href="#条款26避免用万能引用重载函数">条款26：避免用万能引用重载函数</a></li>
    <li><a href="#条款27条款26的替代方案">条款27：条款26的替代方案</a></li>
    <li><a href="#条款28理解引用折叠">条款28：理解引用折叠</a></li>
    <li><a href="#条款29移动语义不好用的场景">条款29：移动语义不好用的场景</a></li>
    <li><a href="#条款30-熟悉完美转发的失败情形">条款30: 熟悉完美转发的失败情形</a></li>
    <li><a href="#条款32lambda表达式初始化捕获">条款32：lambda表达式初始化捕获</a></li>
    <li><a href="#条款33lambda表达式万能引用">条款33：lambda表达式万能引用</a></li>
    <li><a href="#条款34lambda表达式全面优于stdbind">条款34：lambda表达式全面优于std::bind</a></li>
    <li><a href="#条款35基于任务的程序设计">条款35：基于任务的程序设计</a></li>
    <li><a href="#条款36stdasync的启动模式">条款36：std::async的启动模式</a></li>
    <li><a href="#条款37thread-join和detach">条款37：thread join和detach</a></li>
    <li><a href="#条款38stdfuture的析构">条款38：std::future的析构</a>
      <ul>
        <li><a href="#什么是future和promise">什么是future和promise？</a></li>
        <li><a href="#future的析构规则">future的析构规则</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="条款1模板类型推导">条款1：模板类型推导</h2>
<p>c++模板类型推导经常用在模板函数类型推导，和auto类型推导</p>
<p>函数模板一般是以下形式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>ParamType和T的区别是ParamType会包含一些饰词，例如const，引用符&amp;等</p>
<p>T的推导结果要分三种情况讨论：</p>
<h3 id="1paramtype是指针或引用但不是万能引用">1.ParamType是指针或引用，但不是万能引用</h3>
<p>这种情况下，T中只会包含ParamType中没有的饰词，ParamType中已经有的饰词会被忽略，例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>         <span class="c1">//param现在是reference-to-const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">27</span><span class="p">;</span>                       <span class="c1">//x是int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>                 <span class="c1">//cx是const int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>                <span class="c1">//rx是指向作为const int的x的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                           <span class="c1">//T是int，param的类型是const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                          <span class="c1">//T是int，param的类型是const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                          <span class="c1">//T是int，param的类型是const int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="2paramtype是万能引用">2.ParamType是万能引用</h3>
<p>什么是万能引用？右值引用形参+模板类型推导就是万能引用（不在模板中使用右值引用就不能叫万能引用），例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时模板类型推导的规则如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>              <span class="c1">//param现在是一个万能引用类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">27</span><span class="p">;</span>                       <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>                 <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">rx</span><span class="o">=</span><span class="n">cx</span><span class="p">;</span>              <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                           <span class="c1">//x是左值，所以T是int&amp;，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">//param类型也是int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                          <span class="c1">//cx是左值，所以T是const int&amp;，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">//param类型也是const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                          <span class="c1">//rx是左值，所以T是const int&amp;，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">//param类型也是const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>                          <span class="c1">//27是右值，所以T是int，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">//param类型就是int&amp;&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这也是为什么这种形式的声明叫做万能引用，当函数入参是右值时，param的类型是右值引用，当函数入参是左值时，param的类型就是左值引用</p>
<h3 id="3paramtype既非引用也非指针">3.ParamType既非引用也非指针</h3>
<p>这种情况也就是按值传递参数，类型推导时会忽略传入参数的引用符号&amp;、const和volatile，如果传入参数是个指针，会忽略顶层const，但不会忽略底层const</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>                <span class="c1">//以传值的方式处理param
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">27</span><span class="p">;</span>                       <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>                 <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">rx</span><span class="o">=</span><span class="n">cx</span><span class="p">;</span>              <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                           <span class="c1">//T和param的类型都是int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                          <span class="c1">//T和param的类型都是int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                          <span class="c1">//T和param的类型都是int
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为什么要忽略const，因为c++认为，既然是按值传递，传入参数不能修改不意味着副本不能修改</p>
<h3 id="数组和函数实参推导">数组和函数实参推导</h3>
<p>简单来说，ParamType中的类型饰词非引用时，数组和函数类型都会退化为指针</p>
<h4 id="数组实参推导">数组实参推导</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;J. P. Briggs&#34;</span><span class="p">;</span>     <span class="c1">//name的类型是const char[13]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>                        <span class="c1">//传值形参的模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>                                <span class="c1">//T被推导为const char*
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;J. P. Briggs&#34;</span><span class="p">;</span>     <span class="c1">//name的类型是const char[13]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>                        <span class="c1">//传值形参的模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>                                <span class="c1">//T被推导为const char (&amp;)[13]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当模板函数的参数是按值传递时，数组入参会退化为指针，当模板函数的参数是按引用传递时，数组入参会按数组的引用传递</p>
<p><strong>这一特性可以用来实现一个利用模板获取数组大小的功能</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>                                                       
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="函数实参推导">函数实参推导</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>         <span class="c1">//someFunc是一个函数，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                    <span class="c1">//类型是void(int, double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>                   <span class="c1">//传值给f1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>                 <span class="c1">//传引用给f2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f1</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>                       <span class="c1">//param被推导为指向函数的指针，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                    <span class="c1">//类型是void(*)(int, double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>                       <span class="c1">//param被推导为指向函数的引用，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                    <span class="c1">//类型是void(&amp;)(int, double)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>和数组实参类型推导类似，函数实参的推导取决于模板形参的类型，模板形参为按值传递时，函数类型会退化为函数指针吗，模板形参为按引用传递时，函数入参会按照函数引用传递</p>
<h2 id="条款2auto类型推导">条款2：auto类型推导</h2>
<p>C++11 新增了auto类型声明</p>
<p>auto类型推导和模板类型推导类似，像<code>auto x = f(2);</code>这样一个变量定义，auto对应的是模板类型推导中的ParamType，即类型T+饰词。</p>
<p>也分三种情况：</p>
<ol>
<li>类型饰词是指针或引用，但不是万能引用。</li>
<li>类型饰词是万能引用。</li>
<li>类型饰词既非指针也非引用。</li>
</ol>
<p>和模板类型推导结果是相同的。</p>
<p>类型饰词非引用的情况下，数组和函数类型也会退化成指针。</p>
<p><strong>auto推导和模板推导唯一不同之处，是对于大括号初始化表达式的处理方式</strong>，如果一个auto变量以这种方式声明，<code>auto x={27};</code>，x会被推导为<code>std:: initializer_ list</code>类型，如果大括号里的值类型不一，则类型推导失败，代码通不过编译，例如<code>auto xs = { 1, 2, 3.0 };</code>，而<strong>模板推导不了<code>{27}</code>这种形式的入参</strong>。</p>
<p>C++14中，函数返回值可以声明为auto，lambda表达式中的函数形参也可以声明为auto，这两种auto推导实际上是模板推导</p>
<h2 id="条款3decltype">条款3：decltype</h2>
<p>decltype可以在编辑器计算表达式的类型，可以这么用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">authenticateUser</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里使用了C++尾置返回值（trailing return type），尾置返回值的好处是可以使用形参列表中的变量</p>
<p><strong>decltype会返回给定名字或表达式的确切类型，不会忽略或转换任何东西，这一点和模板推导和auto推导不同</strong>，这有个好处，如果auto返回值声明不符合预期，<strong>可以使用<code>decltype(auto) </code>让auto的推导采用decltype的规则</strong>，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">authenticateUser</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面这段代码中，如果不使用decltype(auto)，只使用auto，按模板推导的规则，返回类型会将引用去掉，实际返回的是值类型</p>
<p><strong>decltype有一些比较复杂的情况</strong>，例如，对于这种用法，<code>decltype(Expr)</code>（Expr是个左值表达式），如果Expr只是个名字，那这个名字对应的类型是啥，decltype返回的就是啥，如果Expr稍微复杂一点，decltype就会返回引用类型，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>    <span class="c1">//返回int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">((</span><span class="n">x</span><span class="p">));</span>  <span class="c1">//返回int &amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="条款4如何查看类型推导结果">条款4：如何查看类型推导结果</h2>
<p>构造一个空模板，利用编译错误输出模板推导结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//比方说，想知道x和y的推导结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">theAnswer</span><span class="p">;</span> <span class="mi">42</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">theAnswer</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">theAnswer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//声明一个模板，不实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TD</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//只要试图实例化该模板，就会诱发一个错误消息，编译器输出的错误信息就会把x和y的类型打印出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TD</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">xType</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="n">TD</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">yType</span><span class="p">;</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>还可以使用<code>typeid(x).name()</code>在运行时打印类型信息，但是这种方法打印出来的不一定准</p>
<p>IDE中显示的类型也不一定准。</p>
<p>boost库的<code>Boost.Typelndex</code>是准的。</p>
<h2 id="条款8nullptr">条款8：nullptr</h2>
<p>nullptr比起NULL，有利于模板类型推导，有利于消除重载函数调用的二义性，原因是NULL实际上是个int类型</p>
<h2 id="条款9using-和-typedef">条款9：using 和 typedef</h2>
<p>尽量使用using，using可以模板化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">MyAllocList</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">lw</span><span class="p">;</span> <span class="c1">//用户代码
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果用typedef，必须新定义一个struct，然后写在struct内部</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>                            <span class="c1">//MyAllocList&lt;T&gt;是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">MyAllocList</span> <span class="p">{</span>                            <span class="c1">//std::list&lt;T, MyAlloc&lt;T&gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">type</span><span class="p">;</span>      <span class="c1">//的同义词  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">lw</span><span class="p">;</span>                   <span class="c1">//用户代码
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>用户代码要加个<code>::type</code></p>
<p>如果要在模板内部使用这个typedef定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>                              <span class="c1">//Widget&lt;T&gt;含有一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>                                    <span class="c1">//MyAllocLIst&lt;T&gt;对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typename</span> <span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">list</span><span class="p">;</span>     <span class="c1">//作为数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>前面要加<code>typename</code>，后面要加<code>::type</code></p>
<h2 id="条款10优先使用-enum-class-而不是-enum">条款10：优先使用 enum class 而不是 enum</h2>
<h2 id="条款11优先使用--delete-而不是-private声明">条款11：优先使用 <code>= delete</code> 而不是 private声明</h2>
<h2 id="条款14不抛出异常的函数尽量声明为noexcept的">条款14：不抛出异常的函数，尽量声明为noexcept的</h2>
<p>stl容器采用移动操作的前提是，移动操作声明为noexcept的，这样stl容器才能在满足异常安全保证的前提下使用移动操作</p>
<p>其他略</p>
<h2 id="条款17特殊成员函数的生成规则">条款17：特殊成员函数的生成规则</h2>
<ol>
<li>默认构造函数：用户没有定义任何构造函数的时候，编译器才会去生成默认构造函数</li>
<li>拷贝构造函数和拷贝赋值运算符
<ul>
<li>相互独立，如果用户只定义了其中一个，编译器会去生成另外一个</li>
</ul>
</li>
<li>移动构造函数和移动赋值运算符
<ul>
<li>只要用户定义了其中一个，编译器就不去生成另外一个了，只有两个都没有定义的时候，编译器才会去生成</li>
</ul>
</li>
<li>拷贝，移动和析构的关系
<ul>
<li>如果用户定义了拷贝操作，那么编译器不会去生成默认的移动操作</li>
<li>反过来，如果用户定义了移动操作，那么编译器也不会去生成默认的拷贝操作</li>
<li>如果定义了析构函数，编译器也不会去生成移动构造函数</li>
</ul>
</li>
</ol>
<h2 id="条款18unique_ptr">条款18：unique_ptr</h2>
<p>指针所有权只能转移，不能共享</p>
<p>默认情况下，销毁将通过<code>delete</code>进行，也可以自定义删除器</p>
<p><code>unique_ptr</code>可以直接类型转换为<code>shared_ptr</code></p>
<p>自定义删除器的写法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">delInvmt</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Investment</span><span class="o">*</span> <span class="n">pInvestment</span><span class="p">)</span>         <span class="c1">//自定义删除器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">{</span>                                   <span class="c1">//（lambda表达式）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">makeLogEntry</span><span class="p">(</span><span class="n">pInvestment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">delete</span> <span class="n">pInvestment</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">                <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Investment</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">delInvmt</span><span class="p">)</span><span class="o">&gt;</span> <span class="c1">//应返回的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pInv</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">delInvmt</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="条款19shared_ptr">条款19：shared_ptr</h2>
<p><code>std::shared_ptr</code>使用引用计数（reference count）确定有多少个对原始指针的引用</p>
<p>引用计数的性能问题</p>
<ol>
<li>引用计数必须动态分配，<code>make_shared</code>比直接用shared_ptr构造开销要小一些，它将控制块的构造和对象的构造过程合并了</li>
<li>引用计数的增减是原子的，因此，对shared_ptr进行移动构造比拷贝构造快，移动构造不需要增减引用计数</li>
</ol>
<p>shared_ptr自定义删除器时，和unique_ptr不同，删除器不是类型的一部分</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">loggingDel</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Widget</span> <span class="o">*</span><span class="n">pw</span><span class="p">)</span>        <span class="c1">//自定义删除器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="p">{</span>                     <span class="c1">//（和条款18一样）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="n">makeLogEntry</span><span class="p">(</span><span class="n">pw</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                      <span class="k">delete</span> <span class="n">pw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span>                        <span class="c1">//删除器类型是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Widget</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">loggingDel</span><span class="p">)</span>        <span class="c1">//指针类型的一部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">&gt;</span> <span class="n">upw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">loggingDel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span>                 <span class="c1">//删除器类型不是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">loggingDel</span><span class="p">);</span>        <span class="c1">//指针类型的一部分
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>shared_ptr会为管理的对象建立一个控制块，控制块中包含引用计数，自定义删除器的拷贝等，多个shared_ptr会利用指针共享这个控制块</p>
<p>shared_ptr提供了<code>std::enable_shared_from_this</code>和<code>shared_from_this</code>这两个设施，对象可以用这两个东西获取到指向自身的shared_ptr，保证对象在处理一些异步操作时被错误释放掉，<code>shared_from_this</code>要求对象外必须已经有一个shared_ptr指向对象了，如果没有会抛出异常（很合理，如果<code>shared_from_this</code>是创建一个新的shared_ptr，这个shared_ptr一旦被释放，对象也跟着被释放了），用法如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">process</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">process</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">thisPtr</span> <span class="o">=</span> <span class="n">shared_from_this</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="条款20weak_ptr">条款20：weak_ptr</h2>
<p>weak_ptr不是独立的智能指针，是对shared_ptr的增强，它不能解引用，也不能判空（和nullptr比较）</p>
<p>std::weak_ptr通常从std::shared_ptr上创建，但它不会影响shared_ptr的引用计数</p>
<h3 id="基本操作检查资源有效性">基本操作：检查资源有效性</h3>
<p>检查所指对象是否有效：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">wpw</span><span class="p">.</span><span class="n">expired</span><span class="p">())</span> <span class="err">…</span>  
</span></span></code></pre></td></tr></table>
</div>
</div><p>检查并访问对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw1</span> <span class="o">=</span> <span class="n">wpw</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>  <span class="c1">//如果wpw过期，spw1就为空
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>shared_ptr的控制块中除了引用计数以外还有弱计数，对应weak_ptr的引用，但weak_ptr是通过检查引用计数判断对象是否有效的，并不是弱计数。</p>
<h3 id="循环引用问题">循环引用问题</h3>
<p>weak_ptr可以解决shared_ptr循环引用问题</p>
<p>有两个shared_ptr分别指向A和B，同时对象A和B各自持有对方的shared_ptr，这种情况下，释放智能指针实际上是释放不了A和B的</p>
<p>可以通过将A或B内部持有的shared_ptr换成weak_ptr来解决</p>
<h3 id="weak_ptr的使用原则">weak_ptr的使用原则</h3>
<p><strong>weak_ptr和shared_ptr的最主要区别是weak_ptr不会获得资源的所有权，想要正确使用weak_ptr，要牢记这一点</strong></p>
<h2 id="条款21优先使用-make_shared-和-make_unique">条款21：优先使用 make_shared 和 make_unique</h2>
<p>为什么要优先使用 make_shared 和 make_unique：</p>
<ol>
<li><code>std::shared_ptr&lt;Widget&gt;(new Widget)</code>这种写法存在潜在的资源泄露，构造对象和构造智能指针分成了两步，很容易因为编译器优化在这两步中间插入别的操作，一旦中间这个操作有异常，就会造成资源泄露</li>
<li><code>std::shared_ptr&lt;Widget&gt; spw(new Widget)</code>会比 make_shared 多分配一次内存，第一次是new一个对象，第二次是为shared_ptr的控制块分配内存，make_shared 会把这两次内存分配合并</li>
</ol>
<p>make系列函数的限制：</p>
<ol>
<li>无法使用自定义析构器</li>
<li>对自定义new和delete的类不友好</li>
<li><strong>由于控制块和对象的内存是一起分配的，因此最后一个weak_ptr不销毁的情况下，对象即使析构，内存也是不会回收的</strong>，使用new 则不会有这个问题，对象的内存和控制块的内存是分开分配的。</li>
</ol>
<h2 id="条款23stdmove-和-stdforward">条款23：std::move 和 std::forward</h2>
<p>std::move 和 std::forward 都是强制类型转换，本身不做任何移动和转发的操作</p>
<p>举个例子，下面这段代码实际上并不会触发value的移动构造函数，原因是std::move转换后的text是一个带const的右值，无法触发value的移动构造</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&#34;abc&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">text</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>std::forward会将传入的右值引用参数强行转换为右值引用，这句话看起来很奇怪，是因为函数形参在函数内部使用时始终是个左值表达式，如果想保留传入参数的右值引用属性，就需要std::forward强转，std::forward一般配合模板的万能引用参数（T &amp;&amp;）来使用</p>
<h2 id="条款24区分右值引用和万能引用">条款24：区分右值引用和万能引用</h2>
<p>涉及到模板类型推导的就是万能引用</p>
<p>例如，以下写法都是万能引用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">var1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>万能引用必须是<code>T&amp;&amp;</code>这种形式</p>
<p>像以下这种不涉及类型推导的模板，也不是万能引用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">vector</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>  <span class="c1">//不是万能引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>作为对比，以下属于万能引用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>   <span class="c1">//依旧来自C++标准
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一种完美转发函数调用的写法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">AnyFuncWrapper</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">	<span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>           <span class="c1">//C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;func in&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span>     <span class="c1">//对params调用func
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...</span>
</span></span><span class="line"><span class="cl">			<span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;func out&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>万能引用实际上涉及到一个叫引用折叠（reference collapse）的概念</p>
<h2 id="条款25对右值引用用stdmove对万能引用用stdforward">条款25：对右值引用用std::move，对万能引用用std::forward</h2>
<p>如题所示</p>
<p>另外一个知识点是关于C++的返回值优化（return value optimization，RVO）的</p>
<p>什么是RVO呢？即对于下面这种代码，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">makeWidget</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译器会考虑是否为返回值做拷贝消除（copy elision）优化，即直接把w构造到返回值对象上，而不是返回时拷贝一次，有点类似于下面的代码，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">makeWidget</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>所以，一般不推荐手动编写上面这种代码，有可能会对编译器的优化形成干扰，做出负优化</strong></p>
<h2 id="条款26避免用万能引用重载函数">条款26：避免用万能引用重载函数</h2>
<p><strong>万能引用几乎能和所有类型产生精确匹配，很容易造成误匹配</strong></p>
<p>重载函数匹配一旦和模板实例化、继承等结合起来，规则会非常复杂，很容易出现让人意想不到的行为</p>
<h2 id="条款27条款26的替代方案">条款27：条款26的替代方案</h2>
<ol>
<li>
<p>放弃重载</p>
</li>
<li>
<p>使用<code>const T&amp;</code>形参代替万能引用</p>
</li>
<li>
<p>传值，而不是传引用</p>
</li>
<li>
<p>将真正需要重载的功能委托给万能引用，判断传入参数类型，例如使用<code>is_integral&lt;T&gt;()</code>判断参数类型是否为整型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>完整写法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//1. 判断参数类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">logAndAdd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">logAndAddImpl</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//2. 编译期区分调用哪个函数
</span></span></span><span class="line"><span class="cl"><span class="c1">//std::false_type 和 std::true_type 是两个不同的类型，分别对应 true 和 false
</span></span></span><span class="line"><span class="cl"><span class="c1">//它们主要是为了作为一个标签，能让程序在编译器决定调用哪个重载函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">logAndAddImpl</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">log</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="s">&#34;logAndAdd&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">names</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nameFromIdx</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">logAndAddImpl</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">logAndAdd</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>使用<code>enable_if</code>在条件满足时禁用模板（过于复杂，略过）</p>
</li>
</ol>
<h2 id="条款28理解引用折叠">条款28：理解引用折叠</h2>
<p>万能引用的工作原理是引用折叠，具体工作过程如下：</p>
<ol>
<li>对于<code>T &amp;&amp;</code>这个参数，如果传入左值，T会推导为左值引用，如果是右值，则推导为非引用</li>
<li>对于左值参数，推导后的结果就变成了<code>type &amp; &amp;&amp;</code></li>
<li>此时触发引用折叠机制，将双重引用变为单引用，规则是：任意一个引用为左值引用，则最终折叠为左值引用，否则，折叠为右值引用</li>
<li>完美转发<code>std::forward</code>也依赖引用折叠工作（原理略过，书里写了一大堆，懒得看了）</li>
</ol>
<h2 id="条款29移动语义不好用的场景">条款29：移动语义不好用的场景</h2>
<ol>
<li>对象没有提供移动操作</li>
<li>对象的移动实现很慢，比如<code>std::array</code>，因为<code>std::array</code>本质上就是一个支持stl操作的内建数组，用的是栈内存</li>
<li>要求移动操作不发生异常的情况下，移动操作未架上<code>noexcept</code></li>
</ol>
<h2 id="条款30-熟悉完美转发的失败情形">条款30: 熟悉完美转发的失败情形</h2>
<p>完美转发的失败情形，源于模板类型推导失败，或推导结果错误</p>
<p>会导致完美转发失败的实参种类有大括号初始化物、 以值0或NULL表达的空指针、仅有声明的整型 static const 成员变量、模板或重载的函数名字，以及位域</p>
<h2 id="条款32lambda表达式初始化捕获">条款32：lambda表达式初始化捕获</h2>
<p>可以在捕获列表中写初始化表达式，可以实现移动捕获</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">pw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pw</span><span class="p">)]</span>        <span class="c1">//使用std::move(pw)初始化闭包数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">{</span> <span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValidated</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                     <span class="o">&amp;&amp;</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isArchived</span><span class="p">();</span> <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="条款33lambda表达式万能引用">条款33：lambda表达式万能引用</h2>
<p>lambda可以模板化，例如 <code>auto f = [](auto x){ return func(normalize(x)); };</code></p>
<p>万能引用+完美转发的写法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">            <span class="nf">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">            <span class="nf">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...));</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="条款34lambda表达式全面优于stdbind">条款34：lambda表达式全面优于std::bind</h2>
<p>lambda 式比起使用 std::bind 而言，可读性更好、表达力更强，可能运行效率也更高</p>
<h2 id="条款35基于任务的程序设计">条款35：基于任务的程序设计</h2>
<p>从条款35开始介绍现代c++的并发api</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">doAsyncWork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//基于线程的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">doAsyncWork</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//基于任务的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">doAsyncWork</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>std::thread的缺陷：</p>
<ul>
<li>无法获取函数返回值</li>
<li>无法在线程外部捕获线程抛出的异常</li>
<li>无法控制线程数量</li>
<li>多线程时存在频繁的线程上下文切换<br>
线程上下文切换成本高，而且线程调度会降低线程的缓存命中率</li>
</ul>
<p>简单来说，基于任务的api提供了更高级的抽象，使开发者不必关心线程管理的问题</p>
<h2 id="条款36stdasync的启动模式">条款36：std::async的启动模式</h2>
<p>std::async有两种启动模式</p>
<ul>
<li><code>std::launch::async</code>：异步启动</li>
<li><code>std::launch::deferred</code>：延迟启动，只会在std::async返回值上调用get或wait时启动，启动后同步执行，会阻塞调用线程</li>
</ul>
<p>默认的启动模式是async或deferred，由并发api自己调度</p>
<p>判断async的启动策略</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>               <span class="c1">//同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">fut</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="mi">0</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span>                 <span class="c1">//如果task是deferred（被延迟）状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">deferred</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">…</span>                                   <span class="c1">//在fut上调用wait或get来异步调用f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                <span class="c1">//task没有deferred（被延迟）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">fut</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="mi">100</span><span class="n">ms</span><span class="p">)</span> <span class="o">!=</span>       <span class="c1">//不可能无限循环（假设f完成）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="err">…</span>                               <span class="c1">//task没deferred（被延迟），也没ready（已准备）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                        <span class="c1">//做并行工作直到已准备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="err">…</span>                                   <span class="c1">//fut是ready（已准备）状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>手动指定启动策略</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>   <span class="c1">//异步启动f的执行
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>默认以异步模式启动的函数封装</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">inline</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span>                                        <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">reallyAsync</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="条款37thread-join和detach">条款37：thread join和detach</h2>
<p>thread析构之前，要么join，要么detach，否则崩溃</p>
<h2 id="条款38stdfuture的析构">条款38：std::future的析构</h2>
<p><code>std::future</code>，<code>std::promise</code>，<code>std::shared_future</code></p>
<h3 id="什么是future和promise">什么是future和promise？</h3>
<p>future和promise是线程间异步通信的一种手段，一个线程持有promise，另一个线程持有future，持有promise的线程set数据，持有future的线程get数据</p>
<p>创建promise的时候，他会同时创建一个future和他绑定，通过<code>promise.get_future()</code>能获取到future，必须通过这个future获取到promise的值</p>
<p>future和promise在底层实现上，他们之间还有一个称为“共享状态的buffer”，用于保存promise set的数据</p>
<p>shared_future允许多个线程同时访问共享状态，每个shared_future都能访问到相同的结果</p>
<p>future是独占的，不能拷贝，只能移动，shared_future可以拷贝</p>
<p>用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">promise</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello world.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="s">&#34;Hi, I&#39;m Alice&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">testAsync</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="n">fuRet</span> <span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">future</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fuRet</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>shared_future用法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//用法1，通过独占future的share成员函数获得
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">future1</span><span class="o">=</span> <span class="n">future</span><span class="p">.</span><span class="n">share</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="n">future1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//用法2，把promise绑定的future直接转换成shared_future，然后拷贝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">future1</span> <span class="o">=</span> <span class="n">future</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="n">future</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>注意，第一种写法中，调用<code>future.share()</code>之后，<code>future</code>本身会失效</strong>，所以创建<code>shared_future</code>最好采用第二种写法，不会出错</p>
<h3 id="future的析构规则">future的析构规则</h3>
<ul>
<li>future的正常析构行为就是销毁future本身</li>
<li>有多个共享future时，最后一个future的析构函数会阻塞住，直到任务完成，相当于一个隐式的join操作。</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2025-05-16&nbsp;<a class="git-hash" href="https://github.com/openjz/asteria/commit/f6e8d372703c11f27b854f1474e77a1ab2d87b62" target="_blank" title="commit by shiwj(swj6086085@163.com) f6e8d372703c11f27b854f1474e77a1ab2d87b62: update post 62">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>f6e8d37</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/62.effective-modern-cpp/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/c/c&#43;&#43;/">c/c&#43;&#43;</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/61.understand-scitools-keygen/" class="prev" rel="prev" title="Scientific Toolworks Understand 7.0.x 破解机使用方法"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>Scientific Toolworks Understand 7.0.x 破解机使用方法</a>
            <a href="/63.affine-transformation/" class="next" rel="next" title="理解仿射变换">理解仿射变换<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/openjz" target="_blank">shiwj</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp">津ICP备2020010292号-1</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
