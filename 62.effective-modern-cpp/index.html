<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>《Effective Modern C&#43;&#43;》阅读笔记 - 星</title><meta name="Description" content=""><meta property="og:title" content="《Effective Modern C&#43;&#43;》阅读笔记" />
<meta property="og:description" content="条款1：模板类型推导 c&#43;&#43;模板类型推导经常用在模板函数类型推导，和auto类型推导 函数模板一般是以下形式 1 2 template&lt;typename T&gt; void f(ParamType param); ParamType和T" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.shiwj.top/62.effective-modern-cpp/" /><meta property="og:image" content="http://blog.shiwj.top/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-04-09T16:22:06+08:00" />
<meta property="article:modified_time" content="2025-05-01T21:58:55+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://blog.shiwj.top/logo.png"/>

<meta name="twitter:title" content="《Effective Modern C&#43;&#43;》阅读笔记"/>
<meta name="twitter:description" content="条款1：模板类型推导 c&#43;&#43;模板类型推导经常用在模板函数类型推导，和auto类型推导 函数模板一般是以下形式 1 2 template&lt;typename T&gt; void f(ParamType param); ParamType和T"/>
<meta name="application-name" content="星">
<meta name="apple-mobile-web-app-title" content="星"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://blog.shiwj.top/62.effective-modern-cpp/" /><link rel="prev" href="http://blog.shiwj.top/61.understand-scitools-keygen/" /><link rel="next" href="http://blog.shiwj.top/63.affine-transformation/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "《Effective Modern C++》阅读笔记",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/blog.shiwj.top\/62.effective-modern-cpp\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "http:\/\/blog.shiwj.top\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048 
                        }],"genre": "posts","keywords": "c\/c\u002b\u002b","wordcount":  4498 ,
        "url": "http:\/\/blog.shiwj.top\/62.effective-modern-cpp\/","datePublished": "2025-04-09T16:22:06+08:00","dateModified": "2025-05-01T21:58:55+08:00","publisher": {
            "@type": "Organization",
            "name": "shiwj","logo": {
                    "@type": "ImageObject",
                    "url": "http:\/\/blog.shiwj.top\/images\/avatar.png",
                    "width":  690 ,
                    "height":  690 
                }},"author": {
                "@type": "Person",
                "name": "shiwj"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 全部 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i>  </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">全部</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">《Effective Modern C&#43;&#43;》阅读笔记</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/openjz" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>shiwj</a>
</span>&nbsp;<span class="post-category">included in <a href="/categories/%E7%BC%96%E7%A8%8B/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>编程</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2025-04-09">2025-04-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;4498 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;9 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#条款1模板类型推导">条款1：模板类型推导</a>
      <ul>
        <li><a href="#1paramtype是指针或引用但不是万能引用">1.ParamType是指针或引用，但不是万能引用</a></li>
        <li><a href="#2paramtype是万能引用">2.ParamType是万能引用</a></li>
        <li><a href="#3paramtype既非引用也非指针">3.ParamType既非引用也非指针</a></li>
        <li><a href="#数组和函数实参推导">数组和函数实参推导</a>
          <ul>
            <li><a href="#数组实参推导">数组实参推导</a></li>
            <li><a href="#函数实参推导">函数实参推导</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#条款2auto类型推导">条款2：auto类型推导</a></li>
    <li><a href="#条款3decltype">条款3：decltype</a></li>
    <li><a href="#条款4如何查看类型推导结果">条款4：如何查看类型推导结果</a></li>
    <li><a href="#条款8nullptr">条款8：nullptr</a></li>
    <li><a href="#条款9using-和-typedef">条款9：using 和 typedef</a></li>
    <li><a href="#条款10优先使用-enum-class-而不是-enum">条款10：优先使用 enum class 而不是 enum</a></li>
    <li><a href="#条款11优先使用--delete-而不是-private声明">条款11：优先使用 <code>= delete</code> 而不是 private声明</a></li>
    <li><a href="#条款17特殊成员函数的生成规则">条款17：特殊成员函数的生成规则</a></li>
    <li><a href="#条款18unique_ptr">条款18：unique_ptr</a></li>
    <li><a href="#条款19shared_ptr">条款19：shared_ptr</a></li>
    <li><a href="#条款20weak_ptr">条款20：weak_ptr</a>
      <ul>
        <li><a href="#检查资源有效性">检查资源有效性</a></li>
        <li><a href="#循环引用问题">循环引用问题</a></li>
        <li><a href="#weak_ptr的使用原则">weak_ptr的使用原则</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="条款1模板类型推导">条款1：模板类型推导</h2>
<p>c++模板类型推导经常用在模板函数类型推导，和auto类型推导</p>
<p>函数模板一般是以下形式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>ParamType和T的区别是ParamType会包含一些饰词，例如const，引用符&amp;等</p>
<p>T的推导结果要分三种情况讨论：</p>
<h3 id="1paramtype是指针或引用但不是万能引用">1.ParamType是指针或引用，但不是万能引用</h3>
<p>这种情况下，T中只会包含ParamType中没有的饰词，ParamType中已经有的饰词会被忽略，例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>         <span class="c1">//param现在是reference-to-const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">27</span><span class="p">;</span>                       <span class="c1">//x是int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>                 <span class="c1">//cx是const int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>                <span class="c1">//rx是指向作为const int的x的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                           <span class="c1">//T是int，param的类型是const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                          <span class="c1">//T是int，param的类型是const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                          <span class="c1">//T是int，param的类型是const int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="2paramtype是万能引用">2.ParamType是万能引用</h3>
<p>什么是万能引用？右值引用形参+模板类型推导就是万能引用（不在模板中使用右值引用就不能叫万能引用），例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时模板类型推导的规则如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>              <span class="c1">//param现在是一个万能引用类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">27</span><span class="p">;</span>                       <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>                 <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">rx</span><span class="o">=</span><span class="n">cx</span><span class="p">;</span>              <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                           <span class="c1">//x是左值，所以T是int&amp;，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">//param类型也是int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                          <span class="c1">//cx是左值，所以T是const int&amp;，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">//param类型也是const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                          <span class="c1">//rx是左值，所以T是const int&amp;，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">//param类型也是const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>                          <span class="c1">//27是右值，所以T是int，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">//param类型就是int&amp;&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这也是为什么这种形式的声明叫做万能引用，当函数入参是右值时，param的类型是右值引用，当函数入参是左值时，param的类型就是左值引用</p>
<h3 id="3paramtype既非引用也非指针">3.ParamType既非引用也非指针</h3>
<p>这种情况也就是按值传递参数，类型推导时会忽略传入参数的引用符号&amp;、const和volatile，如果传入参数是个指针，会忽略顶层const，但不会忽略底层const</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>                <span class="c1">//以传值的方式处理param
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">27</span><span class="p">;</span>                       <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>                 <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">rx</span><span class="o">=</span><span class="n">cx</span><span class="p">;</span>              <span class="c1">//如之前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                           <span class="c1">//T和param的类型都是int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                          <span class="c1">//T和param的类型都是int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                          <span class="c1">//T和param的类型都是int
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为什么要忽略const，因为c++认为，既然是按值传递，传入参数不能修改不意味着副本不能修改</p>
<h3 id="数组和函数实参推导">数组和函数实参推导</h3>
<p>简单来说，ParamType中的类型饰词非引用时，数组和函数类型都会退化为指针</p>
<h4 id="数组实参推导">数组实参推导</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;J. P. Briggs&#34;</span><span class="p">;</span>     <span class="c1">//name的类型是const char[13]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>                        <span class="c1">//传值形参的模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>                                <span class="c1">//T被推导为const char*
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;J. P. Briggs&#34;</span><span class="p">;</span>     <span class="c1">//name的类型是const char[13]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>                        <span class="c1">//传值形参的模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>                                <span class="c1">//T被推导为const char (&amp;)[13]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当模板函数的参数是按值传递时，数组入参会退化为指针，当模板函数的参数是按引用传递时，数组入参会按数组的引用传递</p>
<p><strong>这一特性可以用来实现一个利用模板获取数组大小的功能</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>                                                       
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="函数实参推导">函数实参推导</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>         <span class="c1">//someFunc是一个函数，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                    <span class="c1">//类型是void(int, double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>                   <span class="c1">//传值给f1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>                 <span class="c1">//传引用给f2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f1</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>                       <span class="c1">//param被推导为指向函数的指针，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                    <span class="c1">//类型是void(*)(int, double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>                       <span class="c1">//param被推导为指向函数的引用，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                    <span class="c1">//类型是void(&amp;)(int, double)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>和数组实参类型推导类似，函数实参的推导取决于模板形参的类型，模板形参为按值传递时，函数类型会退化为函数指针吗，模板形参为按引用传递时，函数入参会按照函数引用传递</p>
<h2 id="条款2auto类型推导">条款2：auto类型推导</h2>
<p>C++11 新增了auto类型声明</p>
<p>auto类型推导和模板类型推导类似，像<code>auto x = f(2);</code>这样一个变量定义，auto对应的是模板类型推导中的ParamType，即类型T+饰词。</p>
<p>也分三种情况：</p>
<ol>
<li>类型饰词是指针或引用，但不是万能引用。</li>
<li>类型饰词是万能引用。</li>
<li>类型饰词既非指针也非引用。</li>
</ol>
<p>和模板类型推导结果是相同的。</p>
<p>类型饰词非引用的情况下，数组和函数类型也会退化成指针。</p>
<p><strong>auto推导和模板推导唯一不同之处，是对于大括号初始化表达式的处理方式</strong>，如果一个auto变量以这种方式声明，<code>auto x={27};</code>，x会被推导为<code>std:: initializer_ list</code>类型，如果大括号里的值类型不一，则类型推导失败，代码通不过编译，例如<code>auto xs = { 1, 2, 3.0 };</code>，而<strong>模板推导不了<code>{27}</code>这种形式的入参</strong>。</p>
<p>C++14中，函数返回值可以声明为auto，lambda表达式中的函数形参也可以声明为auto，这两种auto推导实际上是模板推导</p>
<h2 id="条款3decltype">条款3：decltype</h2>
<p>decltype可以在编辑器计算表达式的类型，可以这么用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">authenticateUser</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里使用了C++尾置返回值（trailing return type），尾置返回值的好处是可以使用形参列表中的变量</p>
<p><strong>decltype会返回给定名字或表达式的确切类型，不会忽略或转换任何东西，这一点和模板推导和auto推导不同</strong>，这有个好处，如果auto返回值声明不符合预期，<strong>可以使用<code>decltype(auto) </code>让auto的推导采用decltype的规则</strong>，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">authenticateUser</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面这段代码中，如果不使用decltype(auto)，只使用auto，按模板推导的规则，返回类型会将引用去掉，实际返回的是值类型</p>
<p><strong>decltype有一些比较复杂的情况</strong>，例如，对于这种用法，<code>decltype(Expr)</code>（Expr是个左值表达式），如果Expr只是个名字，那这个名字对应的类型是啥，decltype返回的就是啥，如果Expr稍微复杂一点，decltype就会返回引用类型，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>    <span class="c1">//返回int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">((</span><span class="n">x</span><span class="p">));</span>  <span class="c1">//返回int &amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="条款4如何查看类型推导结果">条款4：如何查看类型推导结果</h2>
<p>构造一个空模板，利用编译错误输出模板推导结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//比方说，想知道x和y的推导结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">theAnswer</span><span class="p">;</span> <span class="mi">42</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">theAnswer</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">theAnswer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//声明一个模板，不实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TD</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//只要试图实例化该模板，就会诱发一个错误消息，编译器输出的错误信息就会把x和y的类型打印出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TD</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">xType</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="n">TD</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">yType</span><span class="p">;</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>还可以使用<code>typeid(x).name()</code>在运行时打印类型信息，但是这种方法打印出来的不一定准</p>
<p>IDE中显示的类型也不一定准。</p>
<p>boost库的<code>Boost.Typelndex</code>是准的。</p>
<h2 id="条款8nullptr">条款8：nullptr</h2>
<p>nullptr比起NULL，有利于模板类型推导，有利于消除重载函数调用的二义性，原因是NULL实际上是个int类型</p>
<h2 id="条款9using-和-typedef">条款9：using 和 typedef</h2>
<p>尽量使用using，using可以模板化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">MyAllocList</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">lw</span><span class="p">;</span> <span class="c1">//用户代码
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果用typedef，必须新定义一个struct，然后写在struct内部</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>                            <span class="c1">//MyAllocList&lt;T&gt;是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">MyAllocList</span> <span class="p">{</span>                            <span class="c1">//std::list&lt;T, MyAlloc&lt;T&gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">type</span><span class="p">;</span>      <span class="c1">//的同义词  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">lw</span><span class="p">;</span>                   <span class="c1">//用户代码
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>用户代码要加个<code>::type</code></p>
<p>如果要在模板内部使用这个typedef定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>                              <span class="c1">//Widget&lt;T&gt;含有一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>                                    <span class="c1">//MyAllocLIst&lt;T&gt;对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typename</span> <span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">list</span><span class="p">;</span>     <span class="c1">//作为数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>前面要加<code>typename</code>，后面要加<code>::type</code></p>
<h2 id="条款10优先使用-enum-class-而不是-enum">条款10：优先使用 enum class 而不是 enum</h2>
<h2 id="条款11优先使用--delete-而不是-private声明">条款11：优先使用 <code>= delete</code> 而不是 private声明</h2>
<h2 id="条款17特殊成员函数的生成规则">条款17：特殊成员函数的生成规则</h2>
<ol>
<li>默认构造函数：用户没有定义任何构造函数的时候，编译器才会去生成默认构造函数</li>
<li>拷贝构造函数和拷贝赋值运算符
<ul>
<li>相互独立，如果用户只定义了其中一个，编译器会去生成另外一个</li>
</ul>
</li>
<li>移动构造函数和移动赋值运算符
<ul>
<li>只要用户定义了其中一个，编译器就不去生成另外一个了，只有两个都没有定义的时候，编译器才会去生成</li>
</ul>
</li>
<li>拷贝，移动和析构的关系
<ul>
<li>如果用户定义了拷贝操作，那么编译器不会去生成默认的移动操作</li>
<li>反过来，如果用户定义了移动操作，那么编译器也不会去生成默认的拷贝操作</li>
<li>如果定义了析构函数，编译器也不会去生成移动构造函数</li>
</ul>
</li>
</ol>
<h2 id="条款18unique_ptr">条款18：unique_ptr</h2>
<p>指针所有权只能转移，不能共享</p>
<p>默认情况下，销毁将通过<code>delete</code>进行，也可以自定义删除器</p>
<p><code>unique_ptr</code>可以直接类型转换为<code>shared_ptr</code></p>
<p>自定义删除器的写法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">delInvmt</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Investment</span><span class="o">*</span> <span class="n">pInvestment</span><span class="p">)</span>         <span class="c1">//自定义删除器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">{</span>                                   <span class="c1">//（lambda表达式）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">makeLogEntry</span><span class="p">(</span><span class="n">pInvestment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">delete</span> <span class="n">pInvestment</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">                <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Investment</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">delInvmt</span><span class="p">)</span><span class="o">&gt;</span> <span class="c1">//应返回的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pInv</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">delInvmt</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="条款19shared_ptr">条款19：shared_ptr</h2>
<p><code>std::shared_ptr</code>使用引用计数（reference count）确定有多少个对原始指针的引用</p>
<p>引用计数的性能问题</p>
<ol>
<li>引用计数必须动态分配，<code>make_shared</code>比直接用shared_ptr构造开销要小一些，它将控制块的构造和对象的构造过程合并了</li>
<li>引用计数的增减是原子的，因此，对shared_ptr进行移动构造比拷贝构造快，移动构造不需要增减引用计数</li>
</ol>
<p>shared_ptr自定义删除器时，和unique_ptr不同，删除器不是类型的一部分</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">loggingDel</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Widget</span> <span class="o">*</span><span class="n">pw</span><span class="p">)</span>        <span class="c1">//自定义删除器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="p">{</span>                     <span class="c1">//（和条款18一样）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="n">makeLogEntry</span><span class="p">(</span><span class="n">pw</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                      <span class="k">delete</span> <span class="n">pw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span>                        <span class="c1">//删除器类型是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Widget</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">loggingDel</span><span class="p">)</span>        <span class="c1">//指针类型的一部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">&gt;</span> <span class="n">upw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">loggingDel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span>                 <span class="c1">//删除器类型不是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">loggingDel</span><span class="p">);</span>        <span class="c1">//指针类型的一部分
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>shared_ptr会为管理的对象建立一个控制块，控制块中包含引用计数，自定义删除器的拷贝等，多个shared_ptr会利用指针共享这个控制块</p>
<p>shared_ptr提供了<code>std::enable_shared_from_this</code>和<code>shared_from_this</code>这两个设施，对象可以用这两个东西获取到指向自身的shared_ptr，保证对象在处理一些异步操作时被错误释放掉，<code>shared_from_this</code>要求对象外必须已经有一个shared_ptr指向对象了，如果没有会抛出异常（很合理，如果<code>shared_from_this</code>是创建一个新的shared_ptr，这个shared_ptr一旦被释放，对象也跟着被释放了），用法如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">process</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">process</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">thisPtr</span> <span class="o">=</span> <span class="n">shared_from_this</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="条款20weak_ptr">条款20：weak_ptr</h2>
<p>weak_ptr不是独立的智能指针，是对shared_ptr的增强，它不能解引用，也不能判空（和nullptr比较）</p>
<p>std::weak_ptr通常从std::shared_ptr上创建，但它不会影响shared_ptr的引用计数</p>
<p>weak_ptr有两个用处，检查资源是否有效，解决shared_ptr循环引用问题</p>
<h3 id="检查资源有效性">检查资源有效性</h3>
<p>检查所指对象是否有效：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">wpw</span><span class="p">.</span><span class="n">expired</span><span class="p">())</span> <span class="err">…</span>  
</span></span></code></pre></td></tr></table>
</div>
</div><p>检查并访问对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw1</span> <span class="o">=</span> <span class="n">wpw</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>  <span class="c1">//如果wpw过期，spw1就为空
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="循环引用问题">循环引用问题</h3>
<p>有两个shared_ptr分别指向A和B，同时对象A和B各自持有对方的shared_ptr，这种情况下，释放智能指针实际上是释放不了A和B的</p>
<p>可以通过将A或B内部持有的shared_ptr换成weak_ptr来解决</p>
<h3 id="weak_ptr的使用原则">weak_ptr的使用原则</h3>
<p><strong>weak_ptr和shared_ptr的最主要区别是weak_ptr不会获得资源的所有权，想要正确使用weak_ptr，要牢记这一点</strong></p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2025-05-01&nbsp;<a class="git-hash" href="https://github.com/openjz/asteria/commit/deb297ec5a4027c9c40fe017a330d479f3b6754f" target="_blank" title="commit by shiwj(swj6086085@163.com) deb297ec5a4027c9c40fe017a330d479f3b6754f: update post 62">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>deb297e</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/62.effective-modern-cpp/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/c/c&#43;&#43;/">c/c&#43;&#43;</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/61.understand-scitools-keygen/" class="prev" rel="prev" title="Scientific Toolworks Understand 7.0.x 破解机使用方法"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>Scientific Toolworks Understand 7.0.x 破解机使用方法</a>
            <a href="/63.affine-transformation/" class="next" rel="next" title="理解仿射变换">理解仿射变换<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/openjz" target="_blank">shiwj</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp">津ICP备2020010292号-1</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
