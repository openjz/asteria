[{"categories":["编程"],"content":"group by…having 和 where 的区别 mysql 先对数据按照 where 子句过滤，然后在对返回的结果分组，最后对分组后的数据按照 having 子句过滤。 where 是对行过滤，而 having 是对分组过滤，所以可以在 having 子句后面使用聚集函数，而在 where 子句后面使用聚集函数是没有意义的。 ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:1:0","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"join…on 和 where 的区别 在联结查询中，join…on…子句和 where 子句是可以一起出现的，要想弄清楚它们的区别，首先要清楚联结查询的过程。联结查询时要先根据联结条件对两张表做笛卡尔积，生成一个大表，然后再对这个大表做过滤，最终得到查询结果。 join…on 和 where 的区别在于，join…on…子句是在联结时生效，而 where 子句是在联结后生效。 因此，当联结是外部联结（联结子句是 left join 或 right join）时，由于外部联结会将左表或右表中没有建立联结的行都返回，所以 on 后面的条件不会去掉那些不符合条件的行，而 where 子句是严格的，会将不等值的行都去掉。 而当联结是内部联结（等值联结）的时候，联结子句（join…on…）只会返回等值的行，这时写在 on 后面的条件和 where 子句中的条件是等价的，因此，使用内部联结的时候，完全可以用 where 子句代替 join…on… ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:2:0","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"窗口函数 参考mysql-8.0-documentation-window-functions ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:3:0","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"介绍 窗口函数是 mysql 8.0 加入的功能，目的是为了满足分组统计场景的查询需求。 我们使用 SQL 语句查数据时通常会有一些统计分析的需求（例如聚合和排序），一般有以下三类统计场景： 简单统计 按条件查出数据后，对返回数据整体做统计操作，这种统计使用select...from...where...order by配合聚合函数即可完成。 分组聚合 按条件查出数据后，对数据分组，然后对每个分组做聚合操作，每个分组返回一条数据即可，这种统计使用group by即可完成。 分组排序 很多时候我们既想分组，又想对分组聚合，又想把分组内部的数据全部返回，而不是每个分组只返回一个数据，这时光用group by是不能完成任务的，为了解决问题，我们经常要写一堆复杂的自联结，不仅 SQL 难以读懂，而且查询效率也很低下。 窗口函数的引入就是为了方便解决上述第三种查询场景，我们可以使用窗口函数对分组内部的数据做统计，然后把统计后的数据全部返回，并且可以按排序为每行计算出一个序号，方便我们使用序号对数据做二次过滤 对于窗口函数来说，“窗口”的概念非常重要。窗口函数会对组内的每条记录执行统计，这需要给窗口函数规定一个统计范围（例如统计范围是从当前行的前一行到当前行的后一行），我们把这个统计范围称为窗口，有的窗口函数的窗口是固定的，有的是滑动的，需要用户指定 ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:3:1","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"用法 以下是窗口函数的用法 -- 简单写法（把窗口函数返回的行序号作为新的一列new_col） selectwindow_function()over(partitionxxxorderbyxxx)asnew_col-- 上面也可以把分组条件拆成单独的window语句 selectwindow_function()overwasnew_colfromxxxwindowwas(partitionxxxorderbyxxx) 窗口函数的完整语法如下 window_function_name(expression)OVER([partition_defintion][order_definition][frame_definition]) window_function_name(expression) 是窗口函数，over()为窗口函数指定了分组规则，如果里面什么都不写就是在整个表上运行窗口函数 partition子句定义了按哪些列分组，order by子句定义了按哪些列排序，frame子句定义了一个滑动窗口，分为按行定义和按范围定义 窗口函数只能用在 select 列表和 order by 子句里。mysql 是对 where、group by、having 子句返回的结果上进行窗口函数的处理，处理顺序在 order by、limit、select distinct 之前 frame语法 -- frame_units是窗口类型，frame_extent是窗口范围 frame_unitsframe_extent-- frame_units有两种，ROWS和RANGE，分别是按行指定范围和直接指定范围 frame_units:{ROWS|RANGE}-- 对于ROWS，也有两种，只指定开始行（结尾行默认是当前行），和同时指定开始和结束行 frame_extent:{frame_start|frame_between}frame_between:BETWEENframe_startANDframe_endframe_start,frame_end:{CURRENTROW-- 当前行 |UNBOUNDEDPRECEDING-- 分组第一行 |UNBOUNDEDFOLLOWING-- 分组最后一行 |exprPRECEDING-- 当前行之前的expr行，例如10 PRECEDING的意思是当前行之前的10行 |exprFOLLOWING-- 当前行之后的expr行 } ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:3:2","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"常用窗口函数 以下是常用窗口函数（不是全部） 函数 功能 row_number() 返回分组内排序后的行号 rank() 返回排序后的序号，如果有并列的行，它们行号相同，行号是并列组前面的总记录数+1 dense_rank() 返回分组内排序后的序号，如果有并列的行，它们行号相同，行号是上一个并列组的序号+1 first_value(expr)/last_value(expr) 返回窗口中的第一个行或最后一个行，并对其做表达式计算 lag(expr,N,default) 返回分组内位于当前行之前N行（这里是指上方）的行，default是指如果没有之前N行返回的值，N和default的默认值分别为1和null lead(expr,N,default) 返回分组内位于当前行之后N行（下方）的行。（这里的之前之后是指遍历顺序） nth_value(expr,N) 返回窗口内的第n行 ntile(n) 将组内行平均分成n个桶，返回每个行所属的桶号 以下是row_number、rank和dense_rank的区别 +------+------------+------+------------+ | val | row_number | rank | dense_rank | +------+------------+------+------------+ | 1 | 1 | 1 | 1 | | 1 | 2 | 1 | 1 | | 2 | 3 | 3 | 2 | | 3 | 4 | 4 | 3 | | 3 | 5 | 4 | 3 | | 3 | 6 | 4 | 3 | | 4 | 7 | 7 | 4 | | 4 | 8 | 7 | 4 | | 5 | 9 | 9 | 5 | +------+------------+------+------------+ ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:3:3","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"其他 ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:4:0","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"case 函数 case 函数可以用在 select 子句里，并将其结果命名为一个字段，还可以按这个字段分组，比如以下 sql selectcasewhenage\u003e=25then\"25岁及以上\"else\"25岁以下\"endasage_cut,count(id)asnumberfromuser_profilegroupbyage_cut; 这个 sql 返回的结果如下所示 age_cut,number 25岁以下,4 25岁及以上,3 case 函数有两种写法，第一种， CASE\u003c表达式\u003eWHEN\u003c值1\u003eTHEN\u003c操作\u003eWHEN\u003c值2\u003eTHEN\u003c操作\u003e...ELSE\u003c操作\u003eENDCASE; 第二种（有点类似于 golang 的 switch 语句）， CASEWHEN\u003c条件1\u003eTHEN\u003c操作\u003eWHEN\u003c条件2\u003eTHEN\u003c操作\u003e...ELSE\u003c操作\u003eENDCASE; ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:4:1","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"IP地址的发展 最开始将IP地址分为ABCDE五类地址，后来为了不浪费IP地址资源提出了划分子网，发明了子网掩码，再后来又（在可变长子网掩码VLSM的基础上）提出了无分类域间路由CIDR（Classless Inter-Domain Routing），提出了变长网络前缀，进一步提高了IP地址利用率 在最初的五类IP编址方法中，IP地址是两级编址，由网络号+主机号构成。划分子网被提出后，IP地址变为了三级编址，即网络号+子网号+主机号。到了CIDR出现以后，就不再使用之前的IP地址分类和划分子网的概念了，而是使用长度可变的网络前缀代替了网络号和子网号，写的时候使用“斜线记法”，即在IP地址后面加一个斜线“/”，然后写上网络前缀所占的位数。 CIDR实际上已经没有子网的概念，但仍然使用掩码这一称呼，IP地址从三级（网络号+子网号+主机号）又变回了两级（网络号+主机号） ","date":"2022-07-15","objectID":"/ip-address/:1:0","tags":["网络"],"title":"关于IP地址的发展","uri":"/ip-address/"},{"categories":["编程"],"content":"最初的五类IP地址 一个IPv4地址共四个字节，由网络号和主机号组成。IPv4地址分为A、B、C、D、E五类 网络号全0代表本网络，因此，A、B、C类地址分别有一个网络号不能使用（0.0.0.0/8，128.0.0.0/16，192.0.0.0/24）。但是随着后来子网和CIDR的出现，IP地址分类已经没有意义，128.0.0.0/16已经被分配出去了，192.0.0.0/24暂时还保留在IANA手中，以后或许会分配出去，只有0.0.0.0/8这个网络号仍然保留，代表本网络 此处参考 知乎tckidd的回答 RFC790-Assigned numbers ，RFC790中给出了具体的IP地址划分 RFC791-Internet Protocol ，RFC791中规定了全0表示本网络 RFC3330-Special-Use IPv4 Addresses ，RFC3330声明了128.0.0.0/16和192.0.0.0/24不再保留 主机号全1表示本网络中的所有主机，因此主机号全1的IP地址是一个广播地址。主机号全0时这个IP地址就是网络号。 特殊地址： 环回地址（loopback），127.0.0.1，等价于localhost和本机ip。（实际上整个127.0.0.0/8网段都是环回地址） 地址0.0.0.0代表本机 0.0.0.0/8中除0.0.0.0以外的其他地址用于表示本网络中的特定主机 主机号全0 主机号全1 A类网络号占一个字节，由0开头。其中，全0的网络号被0.0.0.0/8占用，全1的网络号被环回地址占用，因此A类网络号范围是1~126。 B类网络号占两个字节，由10开头（范围是128.0.0.0/16~191.255.0.0/16） C类网络号占三个字节，由110开头 D类IP地址是多播地址，由1110开头 E类IP地址保留，由11110开头 A、B、C三类地址都各自划分出一块区域作为私有地址 A类私有地址，10.0.0.0~10.255.255.255 B类私有地址，172.16.0.0~172.31.255.255 C类私有地址，192.168.0.0~192.168.255.255 ","date":"2022-07-15","objectID":"/ip-address/:2:0","tags":["网络"],"title":"关于IP地址的发展","uri":"/ip-address/"},{"categories":["编程"],"content":"格式化输入输出 参考https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#formatted-string-literals print(\"demo1: {0}{1}{2}\".format(\"hello\", 2, 3)) print(\"demo2: %s%d%d\" % (\"hello\", 2, 3)) ","date":"2022-07-08","objectID":"/python-basic/:1:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"for 循环 n = [1,2,3,4] # 正序 for v in n: ... for i in range(10): ... # 倒序 for v in reversed(n): ... for i in range(10,-1,-1): #从10到0，步长为-1，第三个参数为步长 ... ","date":"2022-07-08","objectID":"/python-basic/:2:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"列表推导式 # 创建一个长度为10的数组，每个元素的值为下标的平方 squares = [x**2 for x in range(10)] ","date":"2022-07-08","objectID":"/python-basic/:3:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"创建数组 # 1维数组 array1d = [0]*(len(s)) array1d_2 = [0 for i in range(len(s))] # 2维数组 array2d = [[0]*(len(s)) for i in range(len(s))] array2d = [[0 for i in range(4)] for i in range(len(s))] # 唯独不能这么写：array2d = [[0]*4]*5，因为*操作对于引用类型来说是传递引用操作，这等于把一维数组的引用复制了5份 ","date":"2022-07-08","objectID":"/python-basic/:4:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"list ","date":"2022-07-08","objectID":"/python-basic/:5:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"翻转 n = [1,2,3] n.reverse() # 原地翻转 reversed(n) # 返回一个翻转后的迭代器，原序列不变 ","date":"2022-07-08","objectID":"/python-basic/:5:1","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"迭代器和生成器 迭代器 n = [1,2,3,4] # 获取迭代器 it = iter(n) # 通过迭代器访问数据 while True: try: print(next(it)) except StopIteration: break # 遍历迭代器 it = iter(n) for i in it: print(i) 生成器是一种特殊的迭代器，作用是一边迭代一边生成数据 # 1. 创建生成器 # （1）生成器表达式（类似列表推导式） b = (i for i in range(5)) # （2）生成器函数 def gen1(): yield 1 yield \"hello\" yield 3 def gen2(n): for i in range(n): yield i b = gen1() c = gen2(4) # 2. 遍历生成器 while True: try: print(next(b)) # 0 except StopIteration: break ","date":"2022-07-08","objectID":"/python-basic/:6:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"拷贝 ","date":"2022-07-08","objectID":"/python-basic/:7:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"可变类型和不可变类型 python 里的类型分为可变类型和不可变类型两类 常见的基本类型，例如整型、字符串类型、浮点型，这些类型都是不可变类型。不可变类型类似于其他语言中的值类型，如果对象 a 赋值给对象 b，并且要修改 b，python 就会先把内存复制一份再修改，也就是说，修改 a 不会影响 b，是一种 copy-on-write 机制。 可变类型一般是容器类型，例如 list、dict、tuple 等。可变类型类似于其它语言中的引用类型，对象 a 给对象 b 赋值时传递的是引用，修改 b 中的数据会导致同时修改 a 和 b ","date":"2022-07-08","objectID":"/python-basic/:7:1","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"深拷贝和浅拷贝 深拷贝和浅拷贝特指标准库 copy 模块中的 copy 和 deepcopy。 copy 被称为浅拷贝，只拷贝第一层数据，如果第一层某个数据是一个 list，那只会把这个 list 的引用拷贝过来 deepcopy 被称为深拷贝，是一种递归拷贝 ","date":"2022-07-08","objectID":"/python-basic/:7:2","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"不同语言中的拷贝和引用 像 python、golang、java 等上层语言对拷贝和引用的处理和 C++不同。 在这些上层语言中，一般都会区分引用类型和值类型，对于值类型，=操作符往往执行的是拷贝操作，对于引用类型，=操作符往往会执行传递引用操作，引用类型的拷贝往往需要一个专门的操作，例如 python 中是copy，java 中是clone。 而在 C++中，=操作符无论对什么对象都是赋值/拷贝操作，如果想传引用，必须在引用变量初始化的时候对其传递引用，并且要指定被传值的变量是引用类型（利用\u0026）。这就导致了，在 C++中，引用变量一旦创建就不能修改引用指向，后续做的所有=操作都是对引用对象的拷贝/赋值操作 ","date":"2022-07-08","objectID":"/python-basic/:7:3","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"lambda 表达式 lambda x: x**2 ","date":"2022-07-08","objectID":"/python-basic/:8:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"常用方法 常用方法： 动态规划，把问题转化为子问题的求解，在子问题求解完成的基础上即可得到问题的解，重点在于（1）问题的建模，（2）求出正确的递推方程，（3）搞清楚基本问题的解 双指针，重点在于搞清楚什么时候移动哪个指针 二分 回溯（DFS） 分治 常用辅助工具：排序，map，堆，栈，队列 ","date":"2022-07-06","objectID":"/algorithm-problem/:1:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 4.寻找两个正序数组的中位数 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数 ","date":"2022-07-06","objectID":"/algorithm-problem/:2:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"方法1-归并法 方法1，按归并的思路，每次排除一个数，直到找到中位数为止。时间复杂度O(m+n) ","date":"2022-07-06","objectID":"/algorithm-problem/:2:1","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"方法2-改良的归并法 方法1是一种比较符合直觉的方法，更进一步，我们考虑每次多排除一些数，以提高算法的执行速度。 寻找中位数问题可以视为寻找第k大数问题的特殊情况，现在设中位数是第k大的数为Kth，我们每次比较k/2个数，就能每次排除掉k/2个数。随着被排除的数逐渐增多，k会逐渐变小，当k变为1的时候，比较最后一次，就找到了Kth。由于k每次缩小一半，时间复杂度为O(log(m+n)) 这里面有一个关键问题，为什么比较步长是k/2？ 为了解释这个问题，先看一个例子， A：1，2，3，8 B：4，5，6，7 有递增序列A和B，现在我们想找到第4大的数（即4），如果将比较步长设置为4，即直接比较7和8，会导致4,5,6,7全都被排除掉，最后无法找到4。所以我们必须设置合理的比较步长，来避免这种情况。 下面说明为什么是k/2 在对位于比较点的两个数做比较后，我们会将较小数及其之前的数排除掉。为了保证一定能够排除较小数及其之前的数，我们必须保证Kth不在被排除的数中，换言之，我们一定不能让位于比较点的两个数都大于Kth。 假设有以下两个序列 A：a0,a1,...,am B: b0,b1,...,bn 假设比较步长为p，位于比较点的两个数是ap，bp，现在对Kth所在位置分情况讨论 ap和bp都在Kth之前 ap在Kth之前，bp在Kth之后（即Kth∈[b0,bp]） ap在Kth之后（即Kth∈[a0,ap]），bp在Kth之前 情况1不做讨论，排除哪个都行。 情况2和情况3是等价的，现在假设Kth∈[a0,ap]，即a0 \u003c= kth \u003c= ap，如果我们想排除[b0,bp]，就必须保证bp \u003c= Kth \u003c= ap，即不能让位于比较点的两个数都大于等于Kth 当比较步长p为k/2时，[a0,ap]和[b0,bp]加起来一共k个数，如果ap和bp都大于Kth，[a0,ap]和[b0,bp]加起来一定会超过k个数，前后矛盾。所以当比较步长为k/2时必不可能出现比较点的两个数都大于Kth这个情况，反之当比较步长大于k/2时，被比较的两个子序列的数字量大于k，就有可能出现这个情况。 相应的，如果有三个有序数列，比较步长最长为k/3，有四个序列，比较步长最长为k/4，以此类推。 ","date":"2022-07-06","objectID":"/algorithm-problem/:2:2","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"方法3-二分法 方法2是将问题转化为求第K大的数，而方法3是利用了中位数的以下性质： 中位数两边的数个数相等 中位数左边最大的数小于右边最小的数、 具体方法是分别将序列1和序列2一分为2，将左序列1+左序列2视为左半部分，将右序列1+右序列2视为右半部分，保证左半部分的数字个数等于右半部分的数字个数，并且左半部分的最大值大于右半部分的最小值。 那如何找到切分位置？在较短序列上进行二分搜索即可 ","date":"2022-07-06","objectID":"/algorithm-problem/:2:3","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 10.正则表达式匹配 给你一个字符串s和一个字符规律p，请你来实现一个支持'.‘和’*‘的正则表达式匹配。 ‘.‘匹配任意单个字符 ‘*‘匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。 用动态规划求解 将问题转化为求f[i][j]的问题，f[i][j]指字符串s的前i个字符和模式p的前j个字符是否匹配。 以下是该问题的求解方程 1. 当p[j-1]不是'*'时， 如果p[j-1]和s[i-1]匹配， f[i][j] = f[i-1][j-1] 否则 f[i][j] = false 2. 当p[j-1]是'*'时（要看'*'前面那个字符）， 如果p[j-2]不和s[i-1]匹配(字母和'*'的组合被干掉)， f[i][j] = f[i][j-2] 否则，既可以字母和'*'的组合被干掉也可以s[i-1]被干掉 f[i][j] = f[i][j-2] or f[i-1][j] 当s和p都为空时，视为匹配，即f[0][0]=True。p为空，s为空时，一定不匹配，即f[0][x]=False。而s为空，p不为空时，不一定匹配，例如p为a*a*时，可以和空串形成匹配，因此在循环时，i要从0开始，j可以从1开始。 ","date":"2022-07-06","objectID":"/algorithm-problem/:3:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 5.求最长回文子串 给你一个字符串s，找到s中最长的回文子串。 示例 1： 输入：s = “babad” 输出：“bab” （“aba” 同样是符合题意的答案。） 使用动态规划求解 将问题转换为求f[i][j]的问题，f[i][j]是指s的子串s[i,j]是否为回文串，求f[i][j]之前要先求出f[i+1][j-1] ","date":"2022-07-06","objectID":"/algorithm-problem/:4:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 11.盛水最多的容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 用双指针法求解，双指针的初始位置位于数组两端，不断向中间逼近，每次移动高度较低的指针（移动指针会导致容器底部变小，为了寻找更大的容积，就要舍弃较低的边，保留较高的边） ","date":"2022-07-06","objectID":"/algorithm-problem/:5:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 15.三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 三数之和要求对组合去重，这个问题和两数之和有所不同，在两数之和问题中，每个数只能属于一个组合，所以，要对组合去重，只要给已经构成组合的数打标记即可，不用对组合打标记。但是对三数之和问题不能采用这种去重方法，因为一个数可以属于多个组合，如果要采用打标记这种方式，必须对组合打标记，不能对数打标记。 因此，通过打标记去重在三数之和问题中不可行 采用排序+双指针的方法，可以在O(n^2)的时间复杂度内完成求解 ","date":"2022-07-06","objectID":"/algorithm-problem/:6:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 23.合并K个升序链表 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 设链表个数为k，节点总数为n 方法1，从k个链表的开头各拿出一个节点，从这k个节点中选取一个最小的链接到大链表中，利用堆选取最小元素，堆操作的时间复杂度是O(logk)，一共n个节点，总的时间复杂度为O(nlogk) 方法2，对k个链表进行两两归并，归并次数是logk，归并的时间复杂度是O(n)，总的时间复杂度是O(nlogk) 方法2的归并策略是尽量降低归并次数，还有另外一种归并策略是尽量降低比较次数，具体方法是每次选取长度最短的两个序列进行归并，但是由于本题是对链表进行归并，无法快速获取序列长度，因此无法采用这种策略 ","date":"2022-07-06","objectID":"/algorithm-problem/:7:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 31.下一个排列 给你一个整数数组 nums，找出nums 的下一个排列。 必须原地修改，只允许使用额外常数空间。 思路 如果序列最后两个元素是正序，直接交换这两个元素即可 在剩下的情况中，每个排列都可以分成前后两个子序列a，b，并且子序列b是一个倒序序列 例如， [1,2,5,4,3] = a+b = [1,2]+[5,4,3] 此时子序列b自己没有下一个排列，要想为nums找到下一个排列，必须把a的最后一个元素和b中的一个元素交换，这个元素必须刚好大于a。交换后，子序列b仍然是一个倒序序列，将b翻转，就完成了求解 两次遍历，一次翻转，时间复杂度为O(n)，第二次遍历可以改成二分查找，但是总的时间复杂度仍然是O(n) ","date":"2022-07-06","objectID":"/algorithm-problem/:8:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["游戏","编程"],"content":"参考 unity manual unity-essentials系列教程 ","date":"2022-06-26","objectID":"/unity-note/:1:0","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["游戏","编程"],"content":"本文约定 粗体代表术语 ","date":"2022-06-26","objectID":"/unity-note/:2:0","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["游戏","编程"],"content":"编辑器操作 ","date":"2022-06-26","objectID":"/unity-note/:3:0","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["游戏","编程"],"content":"场景视图导航 pan（移动视图）：使用“手”工具，按住鼠标左键拖动视图 zoom（放缩）：使用鼠标滚轮或按住alt和鼠标右键拖动 orbit（环绕物体）：按住alt和鼠标左键拖动 focus（聚焦）：按F聚焦到一个对象 flythrough mode（飞越模式）：飞越模式是指第一人称视角，飞越模式的所有操作都需要按住鼠标右键 按住鼠标右键拖动来环顾四周 用wasd前进后退左移右移 用qe上升下降 按住shift移动得更快 ","date":"2022-06-26","objectID":"/unity-note/:3:1","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["游戏","编程"],"content":"场景视图工具 快捷键Q，移动相机 快捷键W，移动 快捷键E，旋转 快捷键R，拉伸 快捷键T，2D拉伸 快捷键Y，移动+旋转+拉伸 ","date":"2022-06-26","objectID":"/unity-note/:3:2","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["游戏","编程"],"content":"概念 primitive object（原始对象） Primitive object是基本3D形状的游戏对象，例如立方体（cube）和球体（sphere），可以将它们添加到场景中作为后续导入资源的占位对象。 如何在创建中创建：在hierarchy的空白处右键，选择3D object，选择一个原始对象 ","date":"2022-06-26","objectID":"/unity-note/:4:0","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["考编"],"content":"考点 操作系统 网络基础 组成原理/体系结构 数据库 office windows 软件工程 编程语言(c、java) 数据结构 基础算法 安全 ","date":"2022-06-21","objectID":"/kaobian-cs/:1:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"背题 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"1. 软件可维护性 决定因素：可理解性、可测试性、可修改性、可移植性、可重用性 提高方法： 使用先进的软件开发工具（版本管理，测试工具，调试工具） 明确软件的质量目标和优先级 进行质量保证审查 选择可维护的程序设计语言 详细的设计文档、结构文档、代码文档、维护文档、接口文档（改善可理解性） 良好的软件设计（模块化、高内聚、低耦合、可测试） ","date":"2022-06-21","objectID":"/kaobian-cs/:2:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"2. 网络接入方法 拨号接入 普通电话线（普通 MODEM）拨号接入 ISDN 线路拨号接入 宽带 ADSL 拨号接入 专线接入 Cable-MODEM（线缆调制解调器）是利用现成的有线电视（CATV）网接入 光纤接入 局域网接入 无线接入 电力宽带上网 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:2","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"3. 网络攻击 网络攻击：DOS/DDOS 攻击、SQL 注入、XSS 攻击（JS 注入）、会话劫持、DNS 劫持、暴力破解密码、电子邮件攻击、恶意软件/病毒/木马攻击 防范网络攻击：系统升级，安全补丁，强密码，防火墙，杀毒软件，扫描下载程序，不点击可疑邮件 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:3","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"4. B/S架构 浏览器/服务器架构：略 好处：容易运维，使用方便 存在的问题：数据安全问题，处理负载问题，耗时问题，灵活性问题 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:4","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"windows win7 开机时进入安全模式按 f8 ","date":"2022-06-21","objectID":"/kaobian-cs/:3:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据库 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据库的特征 持久存储 数据结构化，有组织，按一定数据模型组织、描述和存储 数据可共享 数据冗余度低 数据独立性高，易扩展。数据独立性分为逻辑独立性和物理独立性 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据库管理系统（DBMS） 位于操作系统之上，管理数据库，提供数据定义、数据操纵、数据控制、数据查询四种功能，并对应有以下语言供用户使用 DDL，数据定义语言（建库、建表等） DML，数据操纵语言（增、删、改） DCL，数据控制语言 DQL，数据查询语言 此外还负责网络通信，保障数据安全性和完整性，事务控制，并发控制等 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:2","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据库系统结构 三级模式：外模式、模式和内模式 二级映射：外模式-模式映射、模式-内模式映射 外模式，又称子模式或用户模式，对应用户级，用户使用外模式描述语言来定义用户的数据记录，或者使用 DML 对数据记录做描述。 模式，又称概念模式或逻辑模式，对应于概念级，是所有用户的公共数据视图，使用 DDL 来描述。 内模式，又称存储模式，对应于物理级，描述了数据在存储介质上的物理结构。 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:3","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据模型 数据模型分为概念数据模型、逻辑数据模型、物理数据模型 概念数据模型是从用户视角描述数据，反映客观世界的联系和规则 E-R 图（实体-联系图）是一种概念模型，用实体、属性和联系来描述客观世界，联系也称关系，分为一对一、一对多、多对多。实体用矩形表示，属性用椭圆形表示，关系用菱形表示。 逻辑数据模型由数据结构、数据操作和完整性约束构成 数据库支持的逻辑数据模型有层次模型、网状模型、关系模型和面向对象模型。 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:4","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"关系型数据库 关系数据模型，是一种用二维表结构来表示实体和实体间关系的模型 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:5","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"关系规范化理论 关系规范化理论是一种用来指导如何设计关系型数据库的理论，规范化用形式更简洁、结构更规范的关系模式取代原有关系模式，其目的是为了解决不合理的关系模式设计导致的数据冗余、操作异常（增删改异常）等问题。 完整的关系模式是一个五元组 R(U,D,Dom,F)，R 是关系，U 是属性集，D 是属性的域，Dom 是属性到域的映射，F 为属性的数据依赖集 关系模型可以简化为一个三元组 R(U,F) 数据依赖是关系模式的重点，包括函数依赖、多值依赖和连接依赖 函数依赖 对于 R(U)，设 X 和 Y 是 U 的两个子集，如果对任意一个 X，有唯一的 Y 与之对应，则这个依赖是函数依赖，称为“X 函数确定 Y”或“Y 函数依赖 X”，记为X-\u003eY，X 为决定因素，Y 为依赖因素。例如，确定了学号，就能确定姓名、性别等。 函数依赖有三种情形 平凡函数依赖和非平凡函数依赖 如果 Y 是 X 的子集，Y 对 X 就是平凡函数依赖，否则是非平凡函数依赖。 完全函数依赖和部分函数依赖 如果 X 的任何一个真子集都不能决定 Y，Y 对 X 就是完全函数依赖，否则是部分函数依赖。 传递函数依赖 如果 X-\u003eY，Y-\u003eZ，且不存在 Y-\u003eX，那么 Z 对 X 传递依赖。 码/键 码/键 表中的一个或几个属性，用来标识该表的每一行或与另一个表产生联系 超码/超键 去掉一个属性，还是码 候选码/候选键 最小的码（属性集完全函数依赖于该码） 主码/主键 从候选码中选一个 主属性 候选码中的属性是主属性 规范化 不同的规范化程度可用范式来衡量。目前有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、BC 范式（BCNF）、第四范式（4NF）和第五范式（5NF）。 第一范式，关系 R 的每个属性都不可分解，都是原子的 第二范式，关系 R 满足第一范式，且所有非主属性都完全函数依赖于任意候选码 第三范式，关系 R 满足第二范式，所有非主属性都不传递函数依赖于任何候选码 BCNF 范式，基于满足第一范式的基础之上，是对第三范式的改进 BCNF 范式，关系 R 满足第一范式，对任何非平凡依赖 X-\u003eY（Y!-\u003eX），X 都包含码，这意味着 （1）所有非主属性都完全函数依赖于每个候选码 （2）所有主属性都完全函数依赖于每个不包含它的候选码 （3）没有任何属性完全函数依赖于非码的任何一组属性 数据库设计普遍采用的是基于 3NF 的设计方法 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:6","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"事务 事务是用户定义的一个操作系列，具有原子性，要么都完成，要么都不完成。事务可以是一条 SQL 语句，也可以是一组 SQL 语句 事务的 ACID 特性：原子性、一致性、隔离性、持久性 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:7","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"网络 CSMA/CD 协议，发送数据前先侦听总线的忙/闲状态，发送数据的同时要进行冲突检测 接入因特网的方式 拨号接入 普通电话线（普通 MODEM）拨号接入 ISDN 线路拨号接入 宽带 ADSL 拨号接入 专线接入 Cable-MODEM（线缆调制解调器）是利用现成的有线电视（CATV）网接入 光纤接入 局域网接入 无线接入 电力宽带上网 网络攻击：DOS/DDOS 攻击、SQL 注入、XSS 攻击（JS 注入）、会话劫持、DNS 劫持、暴力破解密码、电子邮件攻击、恶意软件/病毒/木马攻击 防范网络攻击：系统升级，安全补丁，强密码，防火墙，杀毒软件，扫描下载程序，不点击可疑邮件 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"服务访问点 SAP 服务访问点 SAP 是指上下两层协议实体之间的逻辑接口（某一层的 SAP 是其对上层的访问接口），例如网络层的 SAP 是 IP 地址 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"物理层设备 光纤，光纤只能单向传输 中继器，集线器 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:2","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据链路层设备 网桥，交换机 网卡，网卡工作在物理层和数据链路层的 MAC 子层 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:3","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"交换机和集线器的区别 集线器工作在物理层，不涉及网络协议层面的工作，只能以广播模式转发数据 交换机工作在数据链路层，可以根据报文中的 MAC 地址对数据做针对性的转发 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:4","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"MAC 和 LLC 数据链路层有两个子层，逻辑链路控制层（LLC）和介质访问控制层（MAC），LLC 层位于 MAC 层之上。 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:5","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"虚电路和数据报 虚电路和数据报是分组交换的两种方式（分组就是包，是网络层的概念），目前因特网用的就是数据报方式。 数据报方式为网络层提供无连接服务，每个分组都包含源地址和目的地址，每个分组独立路由和转发，不保证分组按顺序到达，不保证可靠传输。 虚电路方式为网络层提供面向连接的服务，建立连接后分组只包含一个虚电路号作为标识，同一条虚电路的分组按同一条路由转发，保证分组的有序到达，保证可靠传输。 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:6","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"Internet、Intranet 和 Extranet Internet 是英特网，Intranet 是企业内部网，Extranet 是外联网 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:7","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"操作系统 操作系统的发展：单道批处理系统，多道批处理系统，分时系统，实时系统，通用操作系统 ","date":"2022-06-21","objectID":"/kaobian-cs/:6:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"程序是怎么控制计算机的 要点： 程序是指令和数据的有序集合，执行时被装载到内存中 cpu 执行指令的过程，取值，译码，执行，取下一条指令，循环往复 ","date":"2022-06-21","objectID":"/kaobian-cs/:6:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件工程 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件生命周期 问题定义及可行性分析 需求分析 总体设计 详细设计 软件编码及测试 软件维护 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件生命周期模型 瀑布模型 各阶段具有顺序性和依赖性 每个阶段都必须完成规定的文档，并对文档进行评审，合格后才能进入下一个阶段 快速原型模型 需求分析阶段只进行初步的需求分析 快速设计开发出原型供用户测试评定，根据改进意见丰富细化软件，直至用户满意，最后再完整地实现软件 增量模型 每次发布一个增量，第一个增量是核心产品，用户对每个增量的反馈将成为下一个增量的新特性 将瀑布模型中的流程反复迭代 螺旋模型 项目流程：制定计划、风险分析、实施工程、客户评估，这个过程反复迭代 由风险驱动 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:2","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"需求分析 略 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:3","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件设计 模块化，高内聚低耦合 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:4","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件编码 略 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:5","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件测试 白盒测试，测试者完全了解程序的结构和处理过程，根据程序的内部逻辑设计测试用例，检查逻辑通路是否符合预期 逻辑覆盖测试 语句覆盖 判定覆盖/分支覆盖，覆盖每个判定分支 条件覆盖，覆盖判定条件的每个取值 条件组合覆盖，覆盖所有判定条件的所有取值组合 点覆盖 边覆盖 路径覆盖 控制结构测试 基本路径测试 条件测试 循环测试 黑盒测试，测试者不关心程序的内部结构，而是根据功能来设计测试用例，检查程序的功能是否符合要求 等价划分 边界值分析 错误推测 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:6","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件质量 功能性、可靠性、可使用性、效率、可维护性、可移植性、重用性 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:7","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件可维护性 决定因素：可理解性、可测试性、可修改性、可移植性、可重用性 提高方法： 使用先进的软件开发工具（版本管理，测试工具，调试工具） 明确软件的质量目标和优先级 进行质量保证审查 选择可维护的程序设计语言 详细的设计文档、结构文档、代码文档、维护文档、接口文档（改善可理解性） 良好的软件设计（模块化、高内聚、低耦合、可测试） ","date":"2022-06-21","objectID":"/kaobian-cs/:7:8","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"office 快捷键 保存、搜索（略） 打开文件：ctrl+o 新建文件：ctrl+n 打印：ctrl+p 退出操作 双击左上角 左/右键单击左上角，选关闭 右键单击标题栏中间，选关闭 单击右上角红叉 文件-\u003e关闭 alt+f4 ","date":"2022-06-21","objectID":"/kaobian-cs/:8:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"word 两种编辑方式，插入和改写（使用 insert 键调整） 查找和替换，开始-\u003e编辑-\u003e替换，或者开始-\u003e编辑-\u003e查找-\u003e高级查找 缩进方式，左缩进，右缩进，首行缩进，悬挂缩进 标尺的作用，定位、对齐和缩进等 在快速选择区三击，可选择整篇文章 ","date":"2022-06-21","objectID":"/kaobian-cs/:9:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"excel 一个 excel 文件最多有 255 个工作表 工作簿是指大的 excel 文档，工作表是指里面的 sheet1、sheet2 公式以等号开头 ","date":"2022-06-21","objectID":"/kaobian-cs/:10:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"公式与函数 单元格引用 绝对引用和相对引用，列表或行标前面带$符时为绝对引用，不带时为相对引用 引用一个单元格，A1 引用运算符 引用一个单元格区域，A1:B3 引用多个单元格区域，(A1:B3,C1:D3) 引用两个单元格的相交区域，(A1:B3 C1:D3) 运算符优先级：- \u003e % \u003e ^ \u003e (*、/) \u003e (+、-) \u003e \u0026 \u003e 比较 ","date":"2022-06-21","objectID":"/kaobian-cs/:10:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"powerpoint 播放快捷键：f5 ","date":"2022-06-21","objectID":"/kaobian-cs/:11:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"模板 人们通常说的模板是指别人做好的 ppt 文件，我们拿到后可以在其基础上做修改 ppt 提供了和模板相关的两种功能，母版和主题 母版用来定义一些可复用的版式。（操作：视图-\u003e幻灯片母版） 主题比母版高级，每个主题里面都包含一套母版，还另外做了统一的配色、字体、效果等。主题做好后会导出成 thmx 文件（操作：设计-\u003e主题） 官方提供的模板，官方的模板是以 pot/potx 格式提供的，官方的模板可以直接在新建文件界面搜索和选择 ","date":"2022-06-21","objectID":"/kaobian-cs/:11:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["编程"],"content":"一、数字签名 数字签名的作用是保证数据的完整性和保密性 数据完整性通过对数据做摘要保证 数据的保密性通过对数据和摘要做公钥加密保证，接收人只能用发送人提供的公钥才能解密消息，用其他人提供的公钥无法解密消息 具体的交互流程是 发送人对消息做加密和摘要，生成数字签名和加密信息，并将签名和信息一起发送给接收人 接收人收到消息后，使用发送人的公钥校验数字签名，校验通过后，即可证明消息的完整性 接收人对消息进行解密，查看消息，对消息做出答复，并用发送人的公钥对答复加密，回复给发送人 ","date":"2022-06-18","objectID":"/digital-signatures-certificates/:1:0","tags":["信息安全"],"title":"数字签名和数字证书","uri":"/digital-signatures-certificates/"},{"categories":["编程"],"content":"二、数字证书 在使用数字签名的过程中存在一个问题，即接收人无法判断发送人的公钥是否可信，换言之，发送人提供的公钥有可能被篡改或伪造。数字证书就是为了解决公钥的可信性问题而被发明出来的。 具体的做法是，由一个权威的证书颁发机构（CA）使用它自己的公钥对发送人的公钥做一个数字签名，并将这个数字签名作为证书颁发给发送人，发送人给接收人发送消息时，将证书一并附上，由接收人去验证。CA会为其自己的公钥颁发一个根证书，提前提供给用户，用户从根证书中获取到CA的公钥，对CA颁发的证书进行验证。 简单来说，用户先从根证书中拿到CA的公钥，再利用CA的公钥从服务器证书中拿到服务器的公钥，然后再用服务器公钥和服务器通信。 ","date":"2022-06-18","objectID":"/digital-signatures-certificates/:2:0","tags":["信息安全"],"title":"数字签名和数字证书","uri":"/digital-signatures-certificates/"},{"categories":["编程"],"content":"三、https协议 ","date":"2022-06-18","objectID":"/digital-signatures-certificates/:3:0","tags":["信息安全"],"title":"数字签名和数字证书","uri":"/digital-signatures-certificates/"},{"categories":["编程"],"content":"https和http的区别 https在http的基础上增加了SSL/TLS协议，SSL/TLS依靠证书验证服务器身份，并对浏览器和服务器之间的通信进行加密 https使用443端口，http使用80端口 ","date":"2022-06-18","objectID":"/digital-signatures-certificates/:3:1","tags":["信息安全"],"title":"数字签名和数字证书","uri":"/digital-signatures-certificates/"},{"categories":["编程"],"content":"SSL/TLS SSL，Secure Sockets Layer TLS，Transport Layer Security SSL/TLS是对因特网上的数据传输进行身份验证和加密的协议，SSL/TLS是对ssl和tls的统称，tls更先进，更安全的ssl，正在逐渐取代ssl SSL/TLS有多个版本，使用How’s My SSL 工具查看你的浏览器使用的是哪个SSL/TLS版本 SSL/TLS的握手过程 客户端和服务器互相告知各自支持的SSL/TLS版本，加密算法和压缩算法 客户端验证服务器证书，并获得服务器公钥 双方通过协商生成会话秘钥（会话秘钥是一个对称秘钥，对称加密比公钥加密快） 双方使用会话秘钥进行加密通信 ","date":"2022-06-18","objectID":"/digital-signatures-certificates/:3:2","tags":["信息安全"],"title":"数字签名和数字证书","uri":"/digital-signatures-certificates/"},{"categories":["考编"],"content":"解题原则 言语理解与表达 片段阅读 选主旨题：重点在于弄清楚逻辑，尤其要会识别选项的“无中生有”问题 语句表达 排语序题：排除法很有效；最好能识别出前后句搭配 填横线题： 填空题很多时候考的是语法问题，并不是逻辑问题，不要被某些参考资料的解析所迷惑 不懂的古诗词别瞎选 逻辑填空：主要使用排除法；不懂的词别瞎选，而且多半是错的 判断推理 图形推理：图推题还是得靠平时多练，靠直觉做题 定义判断： 有时候靠仅靠常识就可以快速解决问题，尤其是对于一些非常专业的定义 类比推理：多刷题 逻辑判断： 支持/否定论点题： 有时候论点不明显，必须要找出论点 有时候会有多个论点，这种时候排除法很有用 有时候会有多个选项表达的是同一个意思，此时可以同时排除 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:1:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"图推技巧 元素组成相同 -\u003e 位置规律 元素组成相似 -\u003e 看样式（颜色、求交/求和） 元素组成不相似 -\u003e看属性 属性 -\u003e 曲线/直线、对称、封闭/开放、 属性无规律 -\u003e 看数量关系（面数、边数、笔画、平行线对数） 折纸题要注意不能将图案折到内部 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:2:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"数学计算公式 溶液问题： 浓度=溶质/溶液=溶质/（溶质+溶剂） 两溶液混合后溶质不变 钟表问题： 表盘12大格，每格30度 时针转速为30°/小时、0.5°/分，分针转速为6°/分。分针每分钟比时针快5.5° 时针和分针一昼夜（24h）重合22次，垂直44次，180° 22次 剪绳计数： 绳子的段数总是比切口数多1 一段绳子对折N次，从中剪M刀，绳子被剪成（M*2^N+1）段 方阵问题： M*N的实心方阵，外圈比内圈多8人 组合数： A(m,n) = n!/(m-n)! C(m,n) = n!/(m-n)!m! 环形排列： n个人排成一圈，有A(n,n)/n种排法。（由于首尾相接的缘故，123456和612345是等价的） n个珍珠串成一条项链，有A(n,n)/2n种排法。（除了首尾相接以外，由于可以正反翻面的缘故，1234和4321是等价的，即正序和倒序也是等价的） 摸球问题 从装有n种球的口袋中，至少要摸出(m-1)n+1个球，才能保证其中有m个球是同一种球，假设每种球足够多。（最坏的情况下，前(m-1)n次摸出m-1副球，再多模一个，无论如何也能有m个一样的 从装有n种球的口袋中，最多摸出(m-1)n个球使得任意m个球不是同一种球，假设每种球足够多。（和上面的问题是一个道理） 经济利润问题 售价是实际出售价格 定价是期望价格 最大公约数gcd(a,b) 辗转相除法，gcd(a,b) = gcd(b,a%b) 最小公倍数lcm(a,b) lcm(a,b) = a*b/gcd(a,b) 余数计算 余同取余：x%7=1,x%6=1,x%5=1 =\u003e x=210n+1 和同加和：x%7=1,x%6=2,x%5=3 =\u003e x=210n+8 差同减差：x%7=3,x%6=2,x%5=1 =\u003e x=210n-4 数列求和 等差数列项数 = (末项-首项)/公差+1 等差数列求和 = (首项+末项)*项数/2 等差数列对称性：如果m+n=i+j,那么am+an=ai+aj 等比数列求和 = a1(1-q^n)/(1-q) N支队伍比赛问题 淘汰赛（决出冠亚军），共比N-1场 淘汰赛（决出前四名），共比N场 单循环赛（任意两个队比一场），共比C(2,N)场 双循环赛（任意两个队比两场），共比A(2,N)场 过河爬井问题 M个人过河，船上能拉N个人，需要a个人划船，则过河需要(M-a)/(N-a)次 M米深的井，每天上爬a米，下落b米，则出井需要的天数为(M-a)/(a-b)+1 空瓶换酒问题 M个空瓶换N瓶酒，x个空瓶最多可以喝到xN/(M-N)瓶酒。（默认可以借瓶换瓶） ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:3:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"速算技巧 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:4:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"求解对象 基期、现期、增长量、增长率 平均值、比重 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:4:1","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"选项差距 差距大： 四个选项首位均不同 首位相同，第二位的差大于首位 差距小： 存在首位相同的选项，且选项的第二位差小于等于首位。 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:4:2","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"运算技巧 直除 应用场景：多位数除法（三位数以上） 方法：分母保留2位或3位有效数字 选项差距大，四舍五入保留2位；选项差距小，四舍五入保留3位； 多位数求和 应用场景：123.4+567.8+901.2 方法：先对各个位求和，从百位求起，然后将各个位的求和结果错位相加 尾数求和 应用场景：多个多位数相加，选项精确到了最后一位并且尾数各不相同 方法：只对尾数求和 增长量计算-假设法 应用场景：现期15048，同比增长率20.5%，求现期和基期的差 方法：先假设一个基期（通常假设一个整数），求出增量；对余量，重复这个过程。适用于选项差距小的情况 增长量计算-百分数化简为分数 适用于选项差距大、增长率绝对值大于等于5%的情况 $$ \\frac{1}{3}=0.333,\\frac{1}{6}=0.167,\\frac{1}{7}=0.143 $$ $$ \\frac{1}{8}=0.125,\\frac{1}{9}=0.111,\\frac{1}{11}=0.091 $$ $$ \\frac{1}{12}=0.083,\\frac{1}{13}=0.077,\\frac{1}{14}=0.071 $$ $$ \\frac{1}{15}=0.067,\\frac{1}{16}=0.0625,\\frac{1}{17}=0.059 $$ $$ \\frac{1}{18}=0.0555,\\frac{1}{19}=0.0526 $$ 增长量计算-基期近似 方法：用现期近似基期，然后乘以增长率得出增长量。适用于选项差距大、增长率绝对值小于5%的情况 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:4:3","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["编程"],"content":"unix时间戳 unix时间戳是相对于UTC时间\"1970年1月1日 00:00:00\"所经过的秒数。由于是相对于UTC时间，各时区的计算机在同一时刻获取到的时间戳都是相同的。 unix时间戳不存在时区问题，因此在传递时间参数的时候，传时间戳明显比传格式化的时间字符串更方便，更明确 ","date":"2022-06-08","objectID":"/time/:1:0","tags":null,"title":"计算机中的时间","uri":"/time/"},{"categories":["编程"],"content":"2038年问题 相当一部分unix操作系统使用32位有符号整型保存时间戳，因此时间戳的值最大也只有2147483647，换算成UTC时间为\"2038-01-19 03:14:07\"，一旦超过这个时间，这些系统的时间戳就会变成一个无效值，可能会导致程序出错，这就是2038年问题。 这有点类似于千年虫问题，2000年以前，很多计算机程序由于程序设计有问题，在时间超过2000年1月1日零点之后，程序会因为无法正确处理时间导致处理出错或程序崩溃（例如有些程序只用年份的后两位表示年份，导致2000年会被误认为是1900年） ","date":"2022-06-08","objectID":"/time/:2:0","tags":null,"title":"计算机中的时间","uri":"/time/"},{"categories":["编程"],"content":"参考《Go程序设计语言》 ","date":"2022-04-26","objectID":"/go-gopl/:0:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"一、程序结构 go程序使用驼峰式命名风格 零值，变量的初始值。数字是0，字符串是\"\"，布尔值是false，接口（interface）和引用类型（slice、指针、map、通道、函数）是nil，数组和结构体的零值是其所有元素或成员的零值 短变量声明，a,b := f()，a和b中至少有一个得是新变量，不能全是已经声明的变量 一个例外，如果a,b是在外层作用域声明的，:=会将它们声明为新变量 指针。函数返回局部变量的地址是安全的（见 6.变量的生命周期） new函数，new函数创建一个新值并返回其地址 变量的生命周期通过其是否可达确定（变量可以在其初次声明的作用域之外存活），编译器根据变量生命周期确定变量在栈上还是堆上分配，而不是根据声明变量的时候使用的是var还是new 多重赋值，例如a,b := 1,\"xxx\"或x,y = y,x，后者用来交换变量的值 类型转换，var a T = T(b)，每个类型都会提供T(x)将x的值转换为T（前提是允许这种转换） 导出的标识符才能在包外被访问到，导出的标识符以大写字母开头 包初始化，从初始化包级别变量开始，优先按照依赖顺序初始化变量，然后按照声明顺序初始化变量 init函数，可以有任意个，在程序启动时按照声明顺序自动执行 包的初始化按导入顺序进行，依赖顺序优先（类似包级别变量初始化） ","date":"2022-04-26","objectID":"/go-gopl/:1:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"二、基本数据 ","date":"2022-04-26","objectID":"/go-gopl/:2:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"2.1 整型 int8、int16、int32、int64、uint8、uint16、uint32、uint64 int和uint，在不同平台上大小不同（通常是32位或64位） rune，等价于int32，表示一个unicode码点 byte，等价于uint8，表示一个原始的字节 uintptr，可以存放一个指针，用于底层编程 golang中%运算结果的正负号总是和被除数一致 位运算。\u0026是与运算（AND），|是或运算（OR），^是异或和非运算（XOR，NOT），\u0026^是与非运算（AND NOT），\u003c\u003c是左移，\u003e\u003e是右移 1和a做异或等价于对a取反，即1^a = ^a（这里的1和a是单独的一位） 与非运算的作用是按右操作数的位分布清空左操作数中的对应位 右移操作\u003e\u003e 有符号数右移按符号位填补空位（因为移的是补码，补码补1就等于原码补0） 右移操作x\u003e\u003en等价于x/2^n，向下取整（朝负无穷方向取整，例如-5»1结果为-3） ","date":"2022-04-26","objectID":"/go-gopl/:2:1","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"2.2 浮点型 两种浮点型，float32和float64 math包给出了浮点型的极限值，例如math.MaxFloat32 特殊值：正无穷、负无穷、无意义（+Inf、-Inf、NaN）。超出极限值的数和除以零的商归为正负无穷，0/0或sqrt(-1)为无意义 ","date":"2022-04-26","objectID":"/go-gopl/:2:2","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"2.3 复数 两种复数，complex64，complex128 写法：3.14i、1+2i 可以使用==和!=判断是否等值 ","date":"2022-04-26","objectID":"/go-gopl/:2:3","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"2.4 布尔 逻辑运算的短路行为，如果运算符左边的操作数能直接确定最终结果，则右边的操作数不会计算在内 \u0026\u0026比||优先级高，助记技巧：\u0026\u0026是逻辑乘法，||是逻辑加法 ","date":"2022-04-26","objectID":"/go-gopl/:2:4","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"2.5 字符串 len函数返回的是字节数，不是字符数 生成子串操作s[i:j]取的是字节，不是字符。 下标访问操作s[i]访问的也是第i个字节，不是字符 range循环i,r := range \"xxx\"中的i表示字节序号，r是字符（rune） 字符串可以通过==或\u003c比较，比较运算按字节进行，结果服从其字典序排序 字符串值无法改变（字符串值所包含的字节序列永不可变），只能将一个新字符串赋值给字符串变量（例如，s+=\"xxx\"只是将+=运算新生成的字符串赋值给了s，并没有改变s原有的字符串值）。这么设计的好处是： 两个字符串变量能够安全地共用同一段底层内存 字符串拷贝的开销小 字符串字面量 转义。除了常见的'\\n'等转义字符以外，'\\xhh'用16进制数hh表示这个字节，'\\ooo'用八进制数ooo表示这个字节，这两者都表示单字节 原生字符串字面量用反引号`...`书写。原生字符串中转义不起作用，可以包含换行，字符串内容和书写内容完全一致。 utf-8 utf-8是go的默认编码 unicode字符有两种表示形式，\\uhhhh表示16位码点，\\Uhhhhhhhh表示32位码点，区别是小写的u和大写的U 以下字符串是等价的，注意：直接用16进制转义（\\x）书写的字符串是\"世界\"经utf-8编码后的实际字节，而\\u和\\U后面跟的是unicode码点，并不是实际的utf-8字节 \"世界\" \"\\xe4\\xb8\\x96\\xe7\\x95\\x8c\" \"\\u4e16\\u754c\" \"\\U00004e16\\U0000754c\" utf-8编码规则（只有\"xxx\"部分才是unicode码点信息） 0xxxxxxx 110xxxxx 10xxxxxx 1110xxxx 10xxxxxx 10xxxxxx 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 使用函数utf8.RuneCountInString(s)计算字符串中的字符数量 utf-8解码器在遇到一个不合理的字节时，会用一个专门的unicode符号\\uFFFD作为替换 byte和rune的区别，rune保存的是unicode码点，并不是utf-8编码后的字节，因此，[]byte转换为[]rune之后，使用fmt.Printf(\"%x\",s)输出的结果并不一样 整型转字符串时，将整型视为unicode码点（rune）处理。遇到无效整型时，用专门的替换字符取代（\\uFFFD） 字面量'A'是rune类型 ","date":"2022-04-26","objectID":"/go-gopl/:2:5","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"事务（transaction）的目的是要保证一连串数据操作的原子性，并能够支持操作回滚 ","date":"2022-04-20","objectID":"/db-transaction/:0:0","tags":["数据库"],"title":"数据库事务","uri":"/db-transaction/"},{"categories":["编程"],"content":"事务的并发问题 脏读：当前事务可以读取到其他事务未提交的数据 不可重复读：当前事务前后两次使用相同的查询语句查到了不同的数据，原因是在事务执行过程中，有其他事务对这批数据做了增删改操作。如果当前事务的两次读操作分别发生在其他事务开始前和提交后，读到的数据不一致，这就不算脏读，属于不可重复读问题。 幻读：事务进行读操作发现数据不存在，试图插入数据，但是插入失败，或者事务发现数据存在，试图更新数据，但更新失败，原因是事务读数据后，有其他事务对数据做了增删操作。即使数据库能够保证不发生脏读和不可重复读,仍有可能发生幻读，现象是每次读数据结果都是不存在，但就是不能插入数据，或者是每次读数据结果都是存在，但就是更新不了。 ","date":"2022-04-20","objectID":"/db-transaction/:1:0","tags":["数据库"],"title":"数据库事务","uri":"/db-transaction/"},{"categories":["编程"],"content":"参考《mysql必知必会》 ","date":"2021-12-10","objectID":"/mysql-crash-course/:0:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"一、基本概念 模式（schema）：这个概念比较模糊，一个比较常见的定义是，schema是指数据库对象的集合，其中包括表、视图、存储过程、索引等。schema通常是指数据库或表的布局和结构等信息。 主键（primary key）：主键定义在表的一列上，用来唯一地标识每一行，因此主键的值不能重复，每一行对应的主键值都是唯一的。 主键有几个使用习惯，（1）不更新主键，（2）一般把主键定义在自增id列上 外键（foreign key）：外键是表中的一个字段，对应另一个表的主键。 可伸缩性（scale），一个设计良好的数据库能够良好应对数据量的增加，我们把这种情况称为数据库的可伸缩性好，可伸缩性离不开外键的使用。 检索性能可能会受多种因素影响：检索操作（子查询、联表查询…），数据量，是否有索引或键 子句（clause）：SQL由子句构成，例如from、order by等。 完全限定列名：表名.列名，video.md5 ","date":"2021-12-10","objectID":"/mysql-crash-course/:1:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"二、mysql工具 mysql安装包中自带一个命令行工具mysql，这是一个运行在命令行的mysql客户端。 命令用;或\\g结束，\\G可以使横向表格纵向输出 输入help或\\h查看帮助 输入quit或exit退出 mysql默认端口是3306 ","date":"2021-12-10","objectID":"/mysql-crash-course/:2:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"三、使用mysql 一些关于数据库和表的命令： 选择数据库：use xxx; 查看（show） 所有数据库：show databases; 所有表：show tables; 表的列：show columns from xxx; 和desc xxx;作用相同 服务器状态：show status; 权限：show grants; 数据库和表的创建语句：show create database/table xxx; 服务器错误和告警：show errors/warnings; help show ","date":"2021-12-10","objectID":"/mysql-crash-course/:3:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"四、检索（select） ","date":"2021-12-10","objectID":"/mysql-crash-course/:4:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"简单select selectfield1fromtable_hello;selectfield1,field2,field3fromtable_hello;select*fromtable_hello; 字段前面可以加上表名，例如 selecttable_hello.field1fromtable_hello; ","date":"2021-12-10","objectID":"/mysql-crash-course/:4:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"distinct selectdistinctfieldfromtable_hello;selectdistinctfield1,field2fromtable_hello; 功能： 只检索单个字段时，列出字段所有可能的取值 检索多个字段时，列出两个字段取值的笛卡尔积 ","date":"2021-12-10","objectID":"/mysql-crash-course/:4:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"limit 返回前n行 selectfieldfromtable_hellolimitn; 返回m行，从第n行开始（行号从0开始） selectfieldfromtable_hellolimitn,m;-- 或 selectfieldfromtable_hellolimitmoffsetn; ","date":"2021-12-10","objectID":"/mysql-crash-course/:4:3","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"排序（order by子句） 按单个列或多个列排序 selectfield1fromtable_helloorderbyfield2;selectfield1fromtable_helloorderbyfield2limit5;selectfield1fromtable_helloorderbyfield1,field2; limit要放在order by后面（先排序、再选行） 按多个列排序时，先按前面的列排，值相同时，再按后面的列排 同时使用order by和limit时，order by在前，limit在后 排序方向（升序/降序） 升序（asc）：默认是升序 降序（desc）：order by field2 desc desc只对一个列有效，对多个列排序时，必须在想降序排的列后面都加上desc，例如： selectfield1fromtable_helloorderbyfield1desc,field2; ","date":"2021-12-10","objectID":"/mysql-crash-course/:4:4","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"五、过滤条件（where） 操作符： =、!=(也可以用\u003c\u003e表示不等于) \u003c、\u003c=、\u003e、\u003e= between，检索字段值位于一个范围内的数据 is null，检查字段值为null的数据 and、or，and优先级高于or，可以用括号调整优先级 in，后面跟着一个值列表，例如(1,3,5) not，对后面的所有条件取反 like，利用通配符匹配 regexp，利用正则表达式，匹配 between例子： -- 查找值为2~4的数据 select*fromtable_videowheremaudit_statusbetween2and4;-- 或 select*fromtable_videowheremaudit_timebetween\"2022-01-02 00:00:00\"and\"2022-01-03 00:00:00\"; not例子： select*fromtable_videowheremaudit_statusnotin(2,3);-- 或 select*fromtable_videowheremaudit_timebetween\"2022-01-02 00:00:00\"and\"2022-01-03 00:00:00\"; ","date":"2021-12-10","objectID":"/mysql-crash-course/:5:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"通配符 通过like关键字使用通配符匹配 %，匹配任意字符出现任意次数（包括0次） _，下划线，匹配一个任意字符（出现一次，不多不少） ","date":"2021-12-10","objectID":"/mysql-crash-course/:5:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"正则表达式 mysql仅支持正则表达式的一个很小的子集 正则表达式是本身是字符串，因此使用转义字符时要先转义一次\\，所以最终使用转义字符的时候，总是要写\\\\ mysql使用[[:\u003c:]]和[[:\u003e:]]匹配单词的开头和结尾，类似\\b ","date":"2021-12-10","objectID":"/mysql-crash-course/:5:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"六、计算字段（临时生成的字段） 计算字段在select语句中创建（计算字段是指经过计算后得到的临时字段） ","date":"2021-12-10","objectID":"/mysql-crash-course/:6:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1. 拼接字段 concat() 很多dbms使用+或||拼接字段，mysql必须使用concat()函数 例如，select concat(name, '(', status, ')') from table_user order by name limit 3; 将字段name和status拼接成name(status)的形式，会产生以下输出： +--------------------------------+ | concat(name, '(', status, ')') | +--------------------------------+ | 000007e(2) | | 00000b0(4) | | 0000253(2) | +--------------------------------+ 可以使用ltrim()、rtrim()、trim()删除数据左侧、右侧和两侧的空白符 可以使用as关键字为新字段赋予别名，例如select concat(name, '(', status, ')') as new_name ... ","date":"2021-12-10","objectID":"/mysql-crash-course/:6:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2. 算术计算 包括加减乘除和圆括号 select field1*field2 as new_name from ... ","date":"2021-12-10","objectID":"/mysql-crash-course/:6:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"七、数据处理 使用函数进行数据处理 文本处理函数： 去除空白符：trim、ltrim、rtrim 大小写转换：upper、lower 字符串长度：length 定位子串起始下标：locate 查找子串：substring 从左边或右边起获取子字符串：left、right 获取字符串的发音：soundex 日期和时间处理函数： 时间和日期计算（加减天数，或加减时分秒）： adddate, date_add, subdate, date_sub addtime, subtime datediff 格式化：date_format(date,format)，参数date是合法的日期时间，format是日期/时间的输出格式, 例如： mysql\u003eSELECTDATE_FORMAT('1997-10-04 22:23:00','%H %k %I %r %T %S %w');'22 22 10 10:23:00 PM 22:23:00 00 6' 获得当前日期/时间：now, curdate, curtime 返回一个日期时间的特定部分：date, day, dayofweek, hour, minute, month, second, time, year 数值处理 cos, sin, tan, pi abs, exp, sqrt, mod, rand ","date":"2021-12-10","objectID":"/mysql-crash-course/:7:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"八、汇总数据（数据聚合，aggregate） 上面的介绍的数据处理函数是对单条数据的处理。数据聚合是要对表中多条数据进行汇总，比如计算行数，求均值等。 聚集函数运行在整个表上，返回单个值，常用聚集函数有： avg: 计算均值。select avg(price) as avg_price where id=1003 count: 计数。count(*)计算行数，无论行中是否有null值。count(column)对特定列有值的行计数，略过null值。 max、min: 返回指定列中的最大值和最小值 sum: 返回指定列的和。也可以对计算字段求和，例如select sum(price*quantity) as total_price 字段前面可以带参数，select avg(PARAM field) as tmp，参数要放在PARAM的位置，默认参数是all，另外一种参数是distinct，它们的区别是，all对全部行进行聚集，distinct对该列的每个取值只统计一次。 可以在单条语句中执行多个聚集计算，select avg(f1) as tmp1, min(f2) as tmp2... ","date":"2021-12-10","objectID":"/mysql-crash-course/:8:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1.对数据分组（group by） 假设有表staff id name dept salary edlevel hiredate 1 张三 rd 2000 3 2009-10-11 2 李四 rd 2500 3 2009-10-01 3 王五 qa 2600 5 2010-10-02 4 王六 qa 2300 4 2010-10-03 5 马七 qa 2100 4 2010-10-06 6 赵八 pm 3000 5 2010-10-05 7 钱九 pm 3100 7 2010-10-07 8 孙十 pm 3500 7 2010-10-06 执行以下sql SELECTdept,edlevel,MAX(salary)ASmaxsalFROMstaffWHEREhiredate\u003e'2010-01-01'ORDERBYdept,edlevel; 结果 dept edlevel maxsal qa 4 2300 qa 5 2600 pm 5 3000 pm 7 3500 group by用于对数据进行分组，如果检索字段中有聚集函数的话，group by按分组聚集，而不是按整个结果集聚集。规则如下： group by必须位于where和order by之间 group by后面可以跟多个列或表达式（但不能是聚集函数），如果是表达式，select后面必须也有这个表达式 除了聚集函数以外，select后面跟着的每一列都得写到group by后面 group by后面跟的每个列必须都写到select后面 如果select语句中同时有字段和聚集函数，则sql中必须使用group by group by按分组列的笛卡尔积展示结果，也意味着能够利用group by对分组列去重，这也是为什么select中的列group by都要有，因为如果select中有一列group by中没有，比如select a,b from xxx group by a;，当a的同一个取值对应多个b的取值时，group by就没办法按笛卡尔积展示分组结果了（不可能在同一行同时展示b的多个取值） ","date":"2021-12-10","objectID":"/mysql-crash-course/:8:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2.过滤分组（having） having类似where，where对行进行过滤，having对分组进行过滤，例如： selectcust_id,count(*)asordersfromproductsgroupbycust_idhavingcount(*)\u003e=2; having和where的区别是，where在分组前过滤，having在分组后过滤 ","date":"2021-12-10","objectID":"/mysql-crash-course/:8:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"九、select子句顺序 select - from - where - group by - having - order by - limit ","date":"2021-12-10","objectID":"/mysql-crash-course/:9:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十、子查询（select嵌套） 涉及到多个表时可能会用到子查询。子查询嵌套太多会导致性能问题。 例一：利用子查询进行过滤 selectcust_idfromorderswhereorder_numin(selectorder_numfromorderitemswhereprod_id=\"TNT2\"); 应该保证where中的列和子查询中select的列保持一致 例二：将子查询作为字段 selectcust_name,(selectcount(*)fromorderswhereorders.cust_id=customers.cust_id)asordersfromcustomers; 该子查询对从customers表中检索出的每行一次（即，先检索customers表，对检索出的每一行，执行子查询）。这种子查询被称为相关子查询（correlated subquery） ","date":"2021-12-10","objectID":"/mysql-crash-course/:10:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十一、联结表（联表，join） 数据库设计中经常需要配合使用多张互相关联的业务表，目的是降低冗余和解耦 联结是sql执行过程中建立的，表定义中并不存在联结 例一，使用where子句建立联结，如果没有联结条件，会返回笛卡尔积 selectvend_name,prod_name,prod_pricefromvendors,productswherevendors.vend_id=products.vend_idorderbyvend_name,prod_name; 例一这种联结也被称为内部联结，也可以写为 selectvend_name,prod_name,prod_pricefromvendorsINNERJOINproductsONvendors.vend_id=products.vend_id; 例二，联结多个表 selectvend_name,prod_name,prod_price,quantityfromorderitems,vendors,productswherevendors.vend_id=products.vend_idandorderitems.prod_id=products.prod_idandorder_num=20005; ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1.内部联结（等值联结） 见上例 ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2.自联结 表别名：as关键字同样可以给表指定别名 例子：根据某产品id找出生产该产品的厂家生产的其他产品 selectp1.prod_id,p1.prod_namefromproductsasp1,productsasp2wherep1.vend_id=p2.vend_idandp2.prod_id='DTNTR'; ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"3.自然联结 自然联结是指检索结果中没有重复的列(不是行)，可以使用通配符让系统自动去掉重复的列，一般是对某个表使用通配符，然后手动指定其他表中的列，例如： selectc.*,o.order_num,o.order_dateoi.prod_id,oi.quantity,oi.item_pricefromcustomersasc,ordersaso,orderitemsasoiwherec.cust_id=o.cust_idandoi.order_num=o.order_numandprod_id='FB'; ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:3","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"4.外部联结 与内部联结不同，外部联结的执行结果中包含没有产生关联的行。例如，下面这个sql想按客户id（cust_id）建立关联，检索出客户和订单的关系，并要求结果中包含没有订单的客户。 selectcustomers.cust_id,orders.order_numfromcustomersLEFTOUTERJOINordersONcustomers.cust_id=orders.cust_id 关键字： left outer join：left要求结果中包含outer join左边表中的无关联行 right outer join：结果中包含右边表中的无关联行 ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:4","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"5.联结中带聚集函数 selectcustomers.cust_name,customers.cust_id,count(orders.order_num)asnum_ordfromcustomersleftouterjoinordersoncustomers.cust_id=orders.cust_idgroupbycustomers.cust_id; 以上sql的作用是：获得所有客户的订单数，包括哪些没有订单的客户 ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:5","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十二、组合查询（union） 同时执行多个select，并将结果作为单个查询结果集返回。例如 selectvend_id,prod_id,prod_pricefromproductswhereprod_id\u003c=5unionselectvend_id,prod_id,prod_pricefromproductswherevend_idin(1001,1002); union的规则： union中的每个查询必须包含相同的列、表达式或聚集函数 union会自动对返回的行去重，如果不想去重，要使用union all 只能有一个order by，必须放在最后一个select之后。 ","date":"2021-12-10","objectID":"/mysql-crash-course/:12:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十三、全文本搜索 mysql通过建立全文索引（倒排索引）来支持全文搜索。 建表时指定全文检索： createtabledemo{...some_wordstextnull,...fulltext(some_words)}engine=MyISAM; 使用函数 match 和 against 进行全文搜索，match 指定要匹配的列，against 指定要使用的搜索表达式。例如 selectnode_textfromproductnodeswherematch(node_text)against('rabbit'); 搜索不区分大小写。搜索结果默认以匹配接近程度进行排序。 match和against的计算结果实际上是一个匹配等级值，表示匹配的接近程度，例如 selectnode_text,match(node_text)against('rabbit')asmatchrankfromproductnodes; 查询扩展：放宽搜索范围，搜索结果中可能不包含指定的检索词，例如select node_text, match(node_text) against('rabbit' with query expansion) as matchrank from productnodes; 布尔文本搜索：against('xxx' in boolean mode)，性能较差，可以不需要fulltext索引。可以指定要匹配的词，要排斥的词，匹配优先级等。 ","date":"2021-12-10","objectID":"/mysql-crash-course/:13:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十四、数据的插入、删除和更新（增删改） ","date":"2021-12-10","objectID":"/mysql-crash-course/:14:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1.插入 简单写法：insert into customers values(null,'xxx','xxx',null);，各个列必须以它们在表定义中的顺序填充 复杂写法：指定要插入的列 insertintocustomers(name,address,city)values('123','asd',null); 可以给多组value，例如，values('xxx','xxx'),('222',NULL); 插入检索出的数据，例如，insert into table1(xx,xx,xx) select xx,xx,xx from table2 where...; ","date":"2021-12-10","objectID":"/mysql-crash-course/:14:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2.更新 更新操作一定要带上条件，否则就会更新全表 updatetablenamesetcust_email='xxxx',cust_name='sss'wherecust_id=2345; 可以在update语句中使用子查询 ignore关键字：update默认的逻辑是只要有一行数据更新失败就失败，ignore可以跳过更新失败的行，继续更新其他行 ","date":"2021-12-10","objectID":"/mysql-crash-course/:14:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"3.删除 删除操作一定要带上条件，否则就会删除表中的所有数据 delete from customers where cust_id = 1234; 删除全表：truncate table tablename，实际上是直接把表删除后再新建一个表 ","date":"2021-12-10","objectID":"/mysql-crash-course/:14:3","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十五、创建和操作表 ","date":"2021-12-10","objectID":"/mysql-crash-course/:15:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1.创建表 查看数据库和表的创建语句：show create database/table xxx; create语句： CREATETABLEifnotexists`video`(`id`bigint(20)unsignedNOTNULLAUTO_INCREMENTCOMMENT'自增id',`file`varchar(64)NOTNULLDEFAULT''COMMENT'文件名',`maudit_status`tinyint(4)unsignedNOTNULLDEFAULT'0'COMMENT'status of machine audit',`source_url`varchar(510)NOTNULLDEFAULT''COMMENT'原始url',`create_time`timestampNOTNULLDEFAULT'0000-00-00 00:00:00'COMMENT'创建时间',`maudit_result`varchar(4096)NOTNULLDEFAULT''COMMENT'result of machine audit',PRIMARYKEY(`id`),UNIQUEKEY`object_name`(`file`),KEY`idx_src_create_time`(`src_create_time`),)ENGINE=InnoDBAUTO_INCREMENT=1DEFAULTCHARSET=utf8COMMENT='视频表'; 规则： 主键可以是多个列，例如，PRIMARY KEY (id1,id2) 每个表只允许一列auto_increment，并且该列必须能被索引（一般是把这列设置为主键） 不允许使用函数作为默认值，只能用常量 外键不允许跨引擎 ","date":"2021-12-10","objectID":"/mysql-crash-course/:15:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2.修改表 altertablexxxaddphone_numchar(20);--增加列 altertablexxxdropcolumnphone_num;--删除列 altertablexxxaddconstraintxxx_fkforeignkey(vend_id)referencesvendors(id);--添加一个外键约束（在vend_id这一列上，添加一个名为xxx_fk的外键约束） ALTERTABLEstudentsDROPFOREIGNKEYfk_class_id;-- 删除外键约束 droptablexxx;--删除表 renametablexxxtoxxx2;--重命名表 ","date":"2021-12-10","objectID":"/mysql-crash-course/:15:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十六、视图 视图是虚拟的表，它只是把查询封装了一下，里面并不包含数据，因此使用视图时要注意性能问题。可以利用视图简化复杂的联结查询 视图操作： create view, drop view, create or replace view show create view xxx, 查看创建视图的语句 ","date":"2021-12-10","objectID":"/mysql-crash-course/:16:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十七、存储过程 存储过程把一系列操作封装在一起。可以在存储过程中加入事务。 createprocedurexxx()beginselectxxxfromxxx;end; 如果是在mysql命令行客户端使用该语句，要对命令结束符做临时修改，例如: delimiter//createprocedurexxx()beginselectxxxfromxxx;end//delimiter; 执行存储过程：call xxx(); 删除存储过程：drop procedure (if exists) xxx; 查看存储过程创建语句：show create procedure xxx; 查看存储过程信息：show procedure status (like 'procedure_name'); ","date":"2021-12-10","objectID":"/mysql-crash-course/:17:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1.参数和变量 所有mysql变量都必须以@开头 定义一个用户变量：set @num=1;或set @num:=1; 定义存储过程时带参数： -- in/out/inout分别对应输入变量、输出变量和输入输出变量 createprocedurexxx(invalue1int,outvalue2decimal(8,2),inoutvalue3boolean)comment'This is a comment'beginselectxxxintovalue2from...;end; 执行存储过程： callxxx(20,@v2,@v3); 获取存储过程的输出： select@v2,@v3; 可以在存储过程中写逻辑： declarexxxintdefault6;declarexxx2booleandefaultfalse;ifxxx2then...endif; ","date":"2021-12-10","objectID":"/mysql-crash-course/:17:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2.游标 mysql游标只能用于存储过程和函数。游标可以用来从select返回的结果集中一行一行地取数据。 ","date":"2021-12-10","objectID":"/mysql-crash-course/:17:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"3.触发器 触发器可以让mysql在某个表发生更改时自动执行某个动作。触发器可以响应delete、insert或update语句。 ","date":"2021-12-10","objectID":"/mysql-crash-course/:17:3","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十八、事务 一些概念： 事务（transaction）：是指一组sql语句 回滚（rollback）：只能在事务内部使用 提交（commit）：做最终的写入操作 保留点（savepoint）：事务处理中设置的临时占位符，可以回滚到保留点，而不是整个事务 starttransaction;...rollback;...savepointxx;...rollbacktoxx;...commit; ","date":"2021-12-10","objectID":"/mysql-crash-course/:18:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十九、用户及权限管理 数据库mysql.user表中有所有的用户信息 createuserxxxidentifiedby'password';renameuserxxxtoxxx2;dropuserxxx;showgrantsforxxx;--显示用户权限 grantselectondb.*toxxx;--grant授予权限 revokeselectondb.*toxxx;--revoke撤销权限 setpasswordforxxx=Password('123456');--改密码 ","date":"2021-12-10","objectID":"/mysql-crash-course/:19:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"二十、数据库维护 数据备份 命令行工具：mysqldump、mysqlhotcopy 命令：backup table、select into outfile、restore table、flush tables 检查状态 analyse table、check table 日志 错误日志：data/hostname.err，命令行参数 查询日志：data/hostname.log，记录所有mysql活动 二进制日志：data/hostname-bin，记录数据更新语句 慢查询日志：data/hostname-slow.log，记录执行缓慢的查询 ","date":"2021-12-10","objectID":"/mysql-crash-course/:20:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"二十一、改善性能 使用explain语句让mysql解释它如何执行某个select语句 join、union和子查询的性能不一定谁高谁低，需要具体问题具体分析 不要用select * 使用多条select语句和union来代替or条件 索引提升查询性能，但是会降低插入、删除和更新的性能 like很慢 … ","date":"2021-12-10","objectID":"/mysql-crash-course/:21:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"参考MDN css入门教程 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:0:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"一、导入 css 1、导入外部样式： \u003clink rel=\"stylesheet\" href=\"styles.css\" /\u003e 2、内部样式 使用 style 元素 \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eMy CSS experiment\u003c/title\u003e \u003cstyle\u003e h1 { color: blue; background-color: yellow; border: 1px solid black; } p { color: red; } \u003c/style\u003e \u003c/head\u003e ... \u003c/html\u003e 3、内联样式 使用 style 属性 \u003ch1 style=\"color: blue;background-color: yellow;border: 1px solid black;\"\u003e Hello World! \u003c/h1\u003e ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:1:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"语法 1、选择器+大括号，属性:值; h1 { color: red; font-size: 5em; } 2、函数 width: calc(90% - 30px); 3、@规则 @import：导入样式表 @media：媒体查询（当条件成立时才应用样式） 4、速记属性 允许在一行中设置多个属性值，如 padding、border 等，例如： padding: 10px 15px 15px 5px; /* 等价于 */ padding-top: 10px; padding-right: 15px; padding-bottom: 15px; padding-left: 5px; background: red url(bg-graphic.png) /* 等价于 */ background-color: red; background-image: url(bg-graphic.png); ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:2:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"选择器和选择符 选择器 例子 元素 h1 id #onething 类 .manythings、a.manythings、.classA.classB 伪类 a:link、*:link、:link 属性 a[title]、a[href=\"https://example.com\"]、a[attr~=v]、a[attr|=v]、a[attr]、[attr^=value]、[attr$=value]、[attr*=value]、[attr=value i]（结尾加个 i 代表按大小写不敏感匹配） 伪元素 p::first-line 通用选择器 * 注： 多个选择器连在一起写代表“与”的关系。 伪类代表元素的状态，伪元素是一种虚拟的元素。参考：常见伪类和伪元素 运算符 例子 空格：后代选择器 article p \u003e：子代选择器 article \u003e p +：相邻兄弟选择器 h1 + p ~：通用兄弟选择器 h1 ~ p ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:3:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"继承 继承：有些父元素上的 css 属性可以被子元素继承，有些不能。 使用 inherit、initial、unset、revert 这四个属性值控制继承，例如 .my-class-1 a { color: inherit; } 属性 all 可以用来代表所有属性 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:4:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"层叠 多个相同权重的规则应用到同一个元素时，后面的覆盖前面的 选择器具有优先级，优先级计算公式 千位：style 属性（内联属性）得一分 百位：id 选择器得一分 十位：类选择器、属性选择器、伪类选择器得一分 个位：元素选择器、伪元素选择器得一份 通用选择器 (*)，组合符 (+, \u003e, ~, ' ‘)，和否定伪类 (:not) 不会影响优先级。 计算时不允许进位，无论多少个低位选择器的权重叠加，都不会超过一个高位选择器。 !important：优先级高于其他所有 当浏览器遇到无法解析的 css 时（比如 css 拼写错误）这个 css 会被忽略。 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:5:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"盒子 块级盒子（Block Box）： 盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间 会换行 可以设置宽高（width 和 height） padding、margin 和 border 会把周围的元素推开 内联盒子（Inline Box）： 不会换行 宽高不起作用（width 和 height） 垂直方向的 padding、margin 和 border 不会把其他 inline 盒子推开 水平方向的 padding、margin 和 border 会把其他 inline 盒子推开 盒子的显示类型： 外部显示类型：决定盒子在它的父元素内是如何布局的，display 值为 inline 或 block 内部显示类型：决定盒子内部元素如何布局，display 值为 flex、grid 等。默认为正常文档流（inline 是 inline，block 是 block） 其他类型： inline-flex：外部显示类型为 inline，内部显示类型为 flex inline-block：不换行的 block，能设置高宽、margin 和 padding，能把周围推开 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:6:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"盒模型 完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。 盒模型组成：content、padding、border、margin 标准盒模型：width 和 height 设置的是 content。box-sizing: content-box; 替代（IE）盒模型：width 和 height 设置的是总长宽。box-sizing: border-box; 外边距折叠：如果两个元素相邻，它们之间的距离不是两个元素的 margin 之和，而是取两个元素 margin 的较大值 margin 可以为负值。padding 不可以为负 属性写法（去掉后缀就是简写）：{margin/border/padding}-{top/right/bottom/left}-{width/style/color} ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:7:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"背景和边框 背景（background）: background-image 属性可以有多个图片，图片会叠在一起显示 {background}-{color/image/repeat/size/position/attachment} 可以设置渐变（gradient）背景 边框（border）: {border}-{width/style/color/radius} ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:8:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"文本方向与逻辑属性 writing-mode: horizontal-tb、vertical-rl、vertical-lr 逻辑属性是为了解决文本方向变化时盒子的高宽等属性不能正确变化的问题，例如 inline-size 对应 width block-size 对应 height 内外边距、边框也有对应的逻辑属性 属性值也有对应的逻辑属性值 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:9:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"处理内容溢出 内容溢出 overflow:visible/hidden/scroll/auto overflow-x overflow-y 文本换行 word-break overflow-wraps hyphens ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:10:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"值和单位 参考：CSS 的值与单位 css 值可以使用关键字和值。关键字是指 red、top 等。 数值类型：integer、number、dimension、\u003cpercentage\u003e、\u003clength\u003e 长度（length） 绝对单位：px 相对单位：rem 百分比（percentage） 百分比通常是相对于父元素 颜色（\u003ccolor\u003e） RGB 和 RGBA：RGBA 颜色在 RGB 的基础上增加了一个透明度值，与 opacity 属性不同，opacity 使得元素和它里面的所有东西都不透明，而 RGBA 颜色只让指定的颜色不透明。（可以用 RBGA 颜色来增加一层滤镜） HSL 和 HSLA：RGB 是红绿蓝，HSL 是色调、饱和度和亮度 图片（\u003cimage\u003e）和渐变（\u003cgradient\u003e） 位置（\u003cposition\u003e） 标识符，标识符就是指上面提到的 css 关键字 字符串，例如content: \"This is a string\" 函数，例如 rgb()、url()、calc()等 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:11:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"尺寸 原始尺寸/固有尺寸： 例如图像本身的尺寸 空 div 没有尺寸，高度为 0，宽度由于其是块级元素会扩展到和父元素一样宽。 用百分数设置尺寸时： 对于 width 和 height，是相对于父元素宽度的百分比 对于内外边距，不论是左右边距还是上下边距，都是相对于 inline-size（即宽度）的百分比 min-和 max-尺寸： 如果盒子内容会变化，用 min-和 max-设置最小或最大尺寸，盒子尺寸就会随内容自动变化 这个技术就是用来使图片（\u003cimage\u003e）可响应的，可响应是指图片随设备尺寸自动缩放。 视口尺寸： vw 和 vh ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:12:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"替换元素和表单 替换元素：指图像和视频元素，css 不能影响其内部布局 调整大小，object-fit: cover/contain/fill; 在 flex 和 grid 布局中，元素会被拉伸，而图像不会 表单的样式在不同浏览器上不太统一，需要额外设置 css 样式保证其初始样式一致，已经有一些工具帮开发人员完成了这个工作，例如 Normalize.css。 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:13:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"字体 web 安全字体：可以在任何一种操作系统上找到的字体。参考：cssfontstack 五种字体的大类型： serif，有衬线字体，衬线是指字体笔画尾端的小装饰，常见于印刷体字体 sans-serif，无衬线字体 monospace，等宽字体，通常用于代码 cursive，手写体 fantasy，用来装饰的字体 使用上面这五种字体时，由浏览器决定具体使用什么字体 常见属性属性名： font-family/size/style/weight/transform/decoration color text-shadow text-align line-height letter-spacing word-spacing web 字体：访问时和页面一起下载，本不需要本地事先有这种字体 @font-face { font-family: \"myFont\"; src: url(\"myFont.ttf\"); } 注意： 有些字体有版权，不能随便用 不同浏览器支持的字体格式可能不同，常见的格式有.ttf, .woff, .woff2 等 在线字体服务，例如 google fonts，可以从第三方站点导入字体，例如用\u003clink\u003e或@import导入字体，不需要开发人员自己提供字体 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:14:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"布局 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"正常布局流 正常布局流是指默认的布局。 块元素的布局方向垂直于书写方向 内联元素的布局方向和书写方向一致 默认的，块元素的宽度是其父元素的 100%，高度与其内容高度一致。内联元素的 height 和 width 与内容一致。 外边距叠加 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:1","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"flexbox（弹性盒子） display:flex flexbox 用于创建横向或纵向的一维布局，里面的子元素被称为 flex 项，flex 有以下特点： 默认方向是横向（父元素 flex-direction:row） 元素会被拉伸到和最高的元素相同（父元素 align-items:stretch） 所有 flex 项都默认从容器的开始位置进行排列，排列成一行后，在尾部留下一片空白。 概念： 主轴是指沿着 flex 项放置方向的轴，交叉轴是指垂直方向的轴 设置了 display:flex 的父元素被称为 flex 容器，里面的子元素被称为 flex 项 方向： flex-direction:row/column/row-reverse/column-reverse，设置主轴方向，-reverse 代表反向排列元素 flex-wrap: wrap，允许换行 flex-flow：以上两项的缩写 动态尺寸： flex:1，无单位的数字代表一个比例，其所占宽度=(1/所有 flex 项所占比例之和)*屏幕宽度 flex:1 200px，该 flex 项至少占 200px，剩余空间按比例分配 flex-grow、flex-basis，分别是以上两个的全写 flex-shrink：指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。 对齐： align-items 控制 flex 项在交叉轴上的位置 justify-content 控制 flex 项在主轴上的位置，其值包括 flex-start、flex-end、flex-around、flex-between 排序：使用 order 属性，默认值是 0，值越大，越往后排 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:2","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"grid（网格） display:grid 默认只有一列，创建多个列： grid-template-columns: 200px 200px 200px; 用fr单位创建多个列，grid-template-columns: 2fr 1fr 1fr，fr定义了一个比例，有点类似于flexbox不带单位的尺寸 grid-template-columns: 300px 2fr 1fr，剩下的两列会根据除去300px后的可用空间按比例分配 使用repeat函数重复生成列 在网格系统中，行和列之间的间隙被称为 gutter（沟槽），如何修改gutter： grid-column/row-gap 显式网格和隐式网格，隐式网格是指浏览器会自动将多出来的内容放到新的行/列里面去： 参数默认是auto，大小会根据放入的内容自动调整 grid-auto-rows/columns，指定显式网格的大小 动态行列尺寸： 使用minmax函数设置行列尺寸，minmax函数可以设置一个取值范围，例如minmax(100px, auto)，下面是一个例子 .container { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); grid-auto-rows: minmax(100px, auto); grid-gap: 20px; } 利用分隔线放置内容 我们的网格有许多分隔线，第一条线的起始点与文档书写模式相关。在英文中，第一条列分隔线（即网格边缘线）在网格的最左边而第一条行分隔线在网格的最上面。 grid-column/row-start/end gird-column/row：同时指定开始线和结束线，要使用/符号分开，例如：grid-column: 1 / 3; 利用grid-template-areas和grid-area放置内容 对于某个横跨多个格子的元素，重复写上那个元素grid-area属性定义的区域名字 所有名字只能出现在一个连续的区域，不能在不同的位置出现 一个连续的区域必须是一个矩形 使用.符号让一个格子留空 .container { display: grid; grid-template-areas: \"header header\" \"sidebar content\" \"footer footer\"; grid-template-columns: 1fr 3fr; grid-gap: 20px; } header { grid-area: header; } article { grid-area: content; } aside { grid-area: sidebar; } footer { grid-area: footer; } ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:3","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"浮动（float） 略 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:4","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"定位（position） 静态定位：position: static;，默认值，将元素放入文档布局流中的正常位置 相对定位：position: relative;，使用top, bottom, left, 和 right定位 绝对定位：position: absolute;，绝对定位的元素不再存在于正常文档布局流中，它在自己的层独立于一切。绝对定位元素相对于其“包含元素定位”。哪个元素是绝对定位元素的“包含元素”取决于绝对定位元素的父元素的position属性 如果父元素都是static，绝对定位元素会被包含在初始快容器中（\u003chtml\u003e元素外面，根据浏览器视口定位） 如何修改绝对定位元素的相对元素？把它的一个父元素设置为相对定位（position: relative）就好了。 z-index：如果有多个绝对定位元素，用z-index指定它们的堆叠顺序（z是指z轴，假设网页有高度）。z-index默认值是0，数字大的在上面，小的在下面。 固定定位：position: fixed;，固定定位固定元素相对于浏览器视口本身。 /*让一个固定定位元素顶部居中*/ h1 { position: fixed; top: 0; margin: 0 auto; /*使用auto居中*/ width: 500px; background: white; padding: 10px; } position: sticky;：相对定位和固定定位的混合体，被定位的元素一开始表现得像相对定位一样，直到它滚动到某个阈值点（例如，距视口顶部1​​0px）后它就变得固定了。 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:5","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"多列布局 通过这两个属性开启多列布局，column-count 或者 column-width column-count属性创建指定列数，由浏览器计算每一列分配多少空间。 column-width属性指定列宽，由浏览器计算创建几列。 用 column-gap 改变列间间隙。 用 column-rule 在列间加入一条分割线。column-rule 是 column-rule-color 和 column-rule-style的缩写，接受和 border 一样的单位。 禁止内容折断：break-inside: avoid 或 page-break-inside: avoid ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:6","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"响应式布局 媒体查询：当满足指定条件时css才会被应用，例如 @media screen and (min-width: 800px) { .container { margin: 1em 2em; } } 断点：媒体查询，以及样式改变时的点，被叫做断点（breakpoints），通常是一个阈值。 现代布局方式，多栏布局，弹性盒子和网格默认是响应式的。 视口元标签： \u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1\"\u003e，它告诉移动端浏览器，应该将视口宽度设定为设备的宽度，将文档放大到其预期大小的100%。如果不加这个，用断点和媒体查询实现的响应式设计不会生效，因为视口大小还是PC端的大小 initial-scale：设定了页面的初始缩放，我们设定为1。 height：特别为视口设定一个高度。 阻止用户缩放 minimum-scale：设定最小缩放级别。 maximum-scale：设定最大缩放级别。 user-scalable：如果设为no的话阻止缩放。 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:7","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"媒体查询 @media media-type and (media-feature-rule) { /* CSS rules go here */ } 它由以下部分组成： 一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）； 它的值可以是：all、print、screen、speech 一个媒体表达式，是一个被包含的CSS生效所需的规则或者测试； min-width、max-width、width等 一组CSS规则，会在测试通过且媒体类型正确的时候应用。 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:8","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"}]