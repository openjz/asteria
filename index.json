[{"categories":["编程"],"content":"注：以下使用 a % b 表示取余和取模运算 ","date":"2022-09-20","objectID":"/15.remainder-and-modulo/:0:0","tags":["golang","python"],"title":"取余和取模的区别","uri":"/15.remainder-and-modulo/"},{"categories":["编程"],"content":"如果a和b都是正数，取余和取模没区别 例如，对于2 % 7，取余和取模的结果都是2，对于9 % 7，取余和取模的结果也都是2 ","date":"2022-09-20","objectID":"/15.remainder-and-modulo/:1:0","tags":["golang","python"],"title":"取余和取模的区别","uri":"/15.remainder-and-modulo/"},{"categories":["编程"],"content":"取余运算 例如， 12 / 7 = 1 … 5，即，12 % 7 = 5 12 / -7 = -1 … 5，即，12 % -7 = 5 -12 / 7 = -1 … -5，即，-12 % 7 = -5 -12 / -7 = 1 … -5，即，-12 % -7 = -5 不难看出，余数和被除数的符号永远相等 取余运算强调的是余量 ","date":"2022-09-20","objectID":"/15.remainder-and-modulo/:2:0","tags":["golang","python"],"title":"取余和取模的区别","uri":"/15.remainder-and-modulo/"},{"categories":["编程"],"content":"取模运算 取模运算强调的是，对于一个取值范围有限的计量系统，随便拿一个数过来，它在这个计量系统里对应的是几 例如，一个时钟的取值范围是0~11，一共12个数，即这个时钟的模为12。如果我们把时针顺时针走看作正，逆时针走看作负，那么，-3点相当于时针从0点开始，逆时针走三个点，就等同于9点，21点相当于时针从9点开始，顺时针转了一整圈，还是等同于9点，而9点本身就是9点，也就是说 -3 对 12取模的结果是9，即 -3 % 12=9 9 对 12取模的结果是9，即 9 % 12=9 21 对 12取模的结果是9，即 21 % 12=9 当模为负数时，同样有 3 % -12 = -9 -9 % -12 = -9 -21 % -12 = -9 ","date":"2022-09-20","objectID":"/15.remainder-and-modulo/:3:0","tags":["golang","python"],"title":"取余和取模的区别","uri":"/15.remainder-and-modulo/"},{"categories":["编程"],"content":"计算公式 如果把取余和取模整理成计算公式 那么 a % b = a - floor(a/b)×b，其中floor表示向下取整 对于取余运算，floor是向0取整 对于取模运算，floor是向负无穷取整 当a和b都是正数或都是负数的时候，它们相除的结果都是正数，向0取整和向负无穷取整是等价的，所以取余和取模的结果是一样的 当a和b符号不同时，取余和取模就不同了 ","date":"2022-09-20","objectID":"/15.remainder-and-modulo/:4:0","tags":["golang","python"],"title":"取余和取模的区别","uri":"/15.remainder-and-modulo/"},{"categories":["编程"],"content":"不同语言处理不一样 在很多编程语言里都有取余或取模运算，运算符一般是%，有的语言里%是取余操作，有的语言里%是取模操作 注意不要混淆类型转换和向下取整，例如在python中，int(-5/3)是从float向int的类型转换，是直接将尾数丢掉，结果是-1，而向下取整是一个算数操作，而-5//3才是向下取整。其他语言同理。 ","date":"2022-09-20","objectID":"/15.remainder-and-modulo/:5:0","tags":["golang","python"],"title":"取余和取模的区别","uri":"/15.remainder-and-modulo/"},{"categories":["编程"],"content":"golang 在golang中，向下取整操作是向0取整，因此，go中的%操作是取余操作 fmt.Println(math.Floor(-5,3)) //输出-1 fmt.Println(-5 % 3) //输出-2 ","date":"2022-09-20","objectID":"/15.remainder-and-modulo/:5:1","tags":["golang","python"],"title":"取余和取模的区别","uri":"/15.remainder-and-modulo/"},{"categories":["编程"],"content":"python 在python中，向下取整操作是向负无穷取整，因此，python中的%操作是取模操作 print(-5//3) # 输出-2 print(-5 % 3) # 输出1 ","date":"2022-09-20","objectID":"/15.remainder-and-modulo/:5:2","tags":["golang","python"],"title":"取余和取模的区别","uri":"/15.remainder-and-modulo/"},{"categories":["编程"],"content":"之前一直有几个疑惑，比如， 一个线程终止后，它创建的其他线程如果没执行完，会跟着终止还是继续执行？ main函数返回后，其他没执行完的线程会终止吗？ 主线程终止后，子线程如果没执行完会跟着终止吗？ ","date":"2022-09-16","objectID":"/14.threadexit/:0:0","tags":["操作系统"],"title":"线程什么时候终止","uri":"/14.threadexit/"},{"categories":["编程"],"content":"结论：进程退出才会导致线程立即终止 通常来说，线程没有“主线程”和“子线程”的概念，进程内的所有线程地位是平等的，没有父子、主从等依赖关系。 如果一个线程创建了其他线程，这个线程终止后，被其创建的线程可以继续执行，main线程也一样，它的终止也不会影响到其他线程的执行。 但是当进程退出的时候，进程内的所有线程都会被立即终止。 之所以会产生上面的疑惑，是因为混淆了线程退出和进程退出，在有些语言里main函数返回会导致进程退出，这会让人误以为其他线程的终止是由main线程终止导致的，实际上是由进程退出导致的。 至于进程什么时候退出，不同语言处理不太一样。 ","date":"2022-09-16","objectID":"/14.threadexit/:1:0","tags":["操作系统"],"title":"线程什么时候终止","uri":"/14.threadexit/"},{"categories":["编程"],"content":"c（pthread） 在c语言中，main函数通过return语句返回后会导致进程退出，进程中的所有线程会被立即终止。 如果在main函数中调用pthread_exit()，只会导致main线程被终止，其他线程则不受影响，因为进程并没有退出。（在其他线程中调用pthread_cancel()终止main线程也一样） ","date":"2022-09-16","objectID":"/14.threadexit/:2:0","tags":["操作系统"],"title":"线程什么时候终止","uri":"/14.threadexit/"},{"categories":["编程"],"content":"java java中的线程分为两类，普通线程和守护线程（daemon），所有线程运行在一个jvm进程中，只有当jvm进程中没有普通进程时，jvm进程才会退出，不管是不是存在守护线程。 main线程是一个普通线程，当jvm进程中没有其他普通线程时，jvm进程会在main函数执行完毕后退出，但是如果jvm进程中还有其他普通线程没执行完，即使main函数先返回，jvm进程也不会退出，会等所有普通线程都执行完才会退出。 ","date":"2022-09-16","objectID":"/14.threadexit/:3:0","tags":["操作系统"],"title":"线程什么时候终止","uri":"/14.threadexit/"},{"categories":["编程"],"content":"golang go的协程调度和线程类似，协程之间没有主从的概念，创建协程终止不会影响被创建协程的执行。 main函数返回后进程退出，所有协程被终止 ","date":"2022-09-16","objectID":"/14.threadexit/:4:0","tags":["操作系统"],"title":"线程什么时候终止","uri":"/14.threadexit/"},{"categories":["考编"],"content":"一、软件工程 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:1:0","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"1.1 软件可维护性 决定因素：可理解性、可测试性、可修改性、可移植性、可重用性 提高方法： 使用先进的软件开发工具（版本管理，测试工具，调试工具） 明确软件的质量目标和优先级 进行质量保证审查 选择可维护的程序设计语言 详细的设计文档、结构文档、代码文档、维护文档、接口文档（改善可理解性） 良好的软件设计（模块化、高内聚、低耦合、可测试） ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:1:1","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"1.2 软件可行性分析的目的是什么 可行性分析的目的是用最小的代价在尽可能短的时间内确定该项目是否能够开发，是否值得开发，其本质是要进行一次简化的、压缩的需求分析和设计过程，要在较高层次上以较抽象的方式进行需求分析和设计 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:1:2","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"二、网络 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:2:0","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"2.1 网络接入方法 拨号接入 普通电话线（普通 MODEM）拨号接入 ISDN 线路拨号接入 宽带 ADSL 拨号接入 专线接入 Cable-MODEM（线缆调制解调器）是利用现成的有线电视（CATV）网接入 光纤接入 局域网接入 无线接入 电力宽带上网 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:2:1","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"2.2 B/S 架构 浏览器/服务器架构：略 好处：容易运维，使用方便 存在的问题：数据安全问题，处理负载问题，耗时问题，灵活性问题 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:2:2","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"2.3 IPv6 技术介绍 IPv6 的全称是 Internet Protocol Version 6，译为“互联网协议版本 6”，是 IETF（互联网工程任务组）设计的用于替代现行 IP 协议（IPv4）的下一代 IP 协议 为何要提出 IPv6 技术（和 IPv4 相比的优势，解决了什么问题）: IPv4 地址长度 32 位，IPv6 地址长度 128 位。解决了 IPv4 地址空间不足的问题，可以做到为每台设备分配一个唯一的 IP 地址。 IPv6 的路由表更小，提高了路由器转发数据包的速度 IPv6 更安全，IPv6 可以在网络层对数据加密和校验，在网络层就可以保证数据传输的安全性和完整性。 IPv6 允许对协议进行扩充 IPv6 增强了对组播的支持和对流的控制，对提升多媒体服务的质量有很大好处 IPv6 加入了对自动配置的支持（是对 DHCP 协议的改进和扩充），提高网络管理效率，降低网络管理成本 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:2:3","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"2.4 计算机网络类别和特点 按覆盖范围分类，分为：WAN（广域网，覆盖范围几十到几千公里，是因特网的核心），MAN（城域网），LAN，PAN（覆盖范围只有几米），CAN，SAN 等 按使用对象分类，分为：公网，私网 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:2:4","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"2.5 如何在计算机网络中实现资源共享 要点 条件，路由，交换机，DHCP 等等 局域网 将某一台计算机的目录设置为局域网共享，获奖这台计算机连接的打印机设置为共享 将网络打印机，网络硬盘组等设备作为独立的设备接入局域网，实现资源共享 远程登陆 公网 去中心化的对等网络 p2p 中心化的资源共享服务，http 服务，ftp 服务等 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:2:5","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"2.6 简述 OSI 七层模型 物理层：建立、维护、断开物理连接，二进制数据的实际传输，有相关物理协议 数据链路层：逻辑连接，主机间通信、硬件地址寻址，数据差错校验，局域网通信协议，PPPoE、CSMA/CD 网络层：主机利用网络地址通信，以网络地址为标识（例如 IP 地址），网络地址寻址、路由、转发，维护路由表，有相关网络协议、IPv4、IPv6 传输层：进程级别的通信，连接，以“主机:端口号”（套接字）作为标识，有 TCP/UDP 协议 会话层：创建、管理、终止会话 表示层：数据格式化、加密、压缩 应用层：负责网络应用级别的通信，HTTP、HTTPS、SSH、FTP ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:2:6","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"2.7 星型网络优缺点 优点： 结构简单、容易实现和维护 节点易扩展 可靠性高，坏一个节点不会导致全网瘫痪 易扩展 传输速度快 缺点： 中央节点负载高，易成为瓶颈 中心节点故障，整个网络故障 线路利用率低 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:2:7","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"三、体系结构、组成原理 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:3:0","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"3.1 计算机软件系统的分类和功能 要点 分为系统软件和应用软件 系统软件包括操作系统、语言处理系统（编译系统）、数据库管理系统 应用软件是为了解决实际问题，面向某个具体的领域而设计的软件。应用软件分为通用软件和专用软件 电子邮件、web 浏览器、办公软件、图像处理、音视频处理、科学计算软件，工业控制软件 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:3:1","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"四、操作系统 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:4:0","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"4.1 什么是死锁、死锁的四个必要条件、如何解决死锁 略 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:4:1","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"五、数据库 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:5:0","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"5.1 数据库优化 数据库方面 建集群，多台机器多台服务同时 I/O 开启查询缓存 表优化 选择更好的存储引擎 对经常在条件、分组子句中出现的列建索引 按照数据范式优化表设计，合理拆分表，降低冗余 分区 分库分表（横向/纵向） 优化字段设计，尽量使用简单/小的数据类型，整形优于字符串，尽量使用定长类型，索引字段越小越好 SQL 语句优化 使用连接查询代替子查询 限制查询字段 限制查询条数 限制使用子查询、联表查询 尽量减少字符串匹配，尤其是正则表达式匹配和 like 匹配 配合慢查询日志优化 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:5:1","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"5.2 什么是事务及事务的特性 事务是用户定义的一个操作序列，具有原子性，要么都完成，要么都不完成。事务可以是一条 SQL 语句，也可以是一组 SQL 语句 事务的 ACID 特性：原子性、一致性、隔离性、持久性 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:5:2","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"5.3 什么是视图 视图是一种虚拟的表，它只有表定义，而不包含具体的数据。 在 SQL 中，视图是基于 SQL 语句的结果集的可视化表，实际上是一条 select 语句，这个语句返回的结果集被视为一个表。 视图中的数据并不属于视图本身，而是属于基本的表。用户对视图进行操作时，系统根据视图的定义去操作与视图相关联的基本表 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:5:3","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"六、信息安全 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:6:0","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"6.1 网络攻击类型、如何防范网络攻击 网络攻击类型 获取信息类：木马程序、恶意抓包（sniffer）、恶意爬虫、端口扫描 网络攻击类： 破解口令（密码）、破解加密数据 后门软件攻击，提前在用户电脑安装后门服务端程序 电子邮件攻击，大量发送垃圾邮件，占用用户邮箱容量，占用邮箱网络带宽 DDos攻击 SQL注入 XSS攻击（跨站点脚本攻击），包括html注入、js注入等 病毒程序 流量劫持（DNS劫持、DHCP欺骗、MAC地址欺骗） 防范网络攻击：系统升级，安全补丁，强密码，防火墙，杀毒软件，扫描下载程序，不点击可疑邮件 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:6:1","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"6.2 信息安全技术包括什么 网络攻防、密码学、信息隐藏、病毒技术 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:6:2","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"6.3 防火墙技术 按发展分类 第一代防火墙，包过滤防火墙，简单访问控制、包过滤、包转发 第二代防火墙，代理防火墙，代理内外网之间的通信 第三代防火墙，状态监控防火墙，能对网络各层的数据包进行监控和检测 第四代防火墙，实现UTM（统一威胁管理） 第五代防火墙（下一代防火墙） 防火墙能干嘛 网络隔离（内外网隔离）、访问控制、包过滤/包转发、网络审计、网络流量审查、防病毒、防网络攻击、网络地址转换NAT、VPN功能、设备黑白名单 保护内部网络、限制内网对外网的访问 其他 分布式防火墙 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:6:3","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"6.4 数字证书、签名、SSL 略 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:6:4","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"其他 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:7:0","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"1. 中间件 中间件（middleware），分布式系统基础软件，位于应用服务/软件和系统服务（操作系统、数据库）之间，主要解决分布式环境下数据传输、数据访问、应用调度、系统构建和系统集成、流程管理等问题，能够实现系统之间的互联互通，提高系统资源利用率 中间件可分为 基础中间件，交易中间件、消息中间件等，用于节点间、应用与服务之间互联互通。基础中间件是构建分布式应用的基础。 集成中间件，用于异构系统（不同的数据库系统、业务应用系统等）之间的互联互通、数据共享、业务流程协调统一等功能，并构建灵活可扩展的分布式企业应用 行业领域应用平台，为满足特定行业、企业需要，便于快速方便地构建应用，而在原有基础中间件、集成中间件的基础上开发的中间件。所提供的服务与特定行业相关 中间件有： 分布式存储、分布式计算 消息中间件 网络代理（负载均衡、数据接入、访问控制、数据转发和路由、安全认证） cdn 缓存 容器编排 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:7:1","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"2. 分布式 CAP 定理 一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。 一致性：分布式系统中同一个数据的所有副本，在同一时刻完全相同 可用性：分布式系统对外提供的服务一直可用，即使某些节点发生了故障 分区容错性：（一个更好的翻译是分区容忍性）当分布式系统出现分区故障的时候，仍能对外提供服务 分区：在分布式系统中，某些节点之间出现了网络不通的状态，导致整个系统被切分成若干个孤立的网络，而这些网络内部通信是正常的，这就是分区。 对于分布式系统来说，分区是无法避免的问题，分布式系统必须能够满足分区容错性，因此，分布式系统需要在一致性和可用性之间二选一 强一致性：对同一个数据的访问在任何时候都是一致的 弱一致性：只能尽量达到对数据的访问是一致的，不保证完全一致 最终一致性：保证能在一段时间以后，同一个数据能达到完全一致 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:7:2","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["考编"],"content":"3. 什么是元宇宙 ","date":"2022-08-27","objectID":"/kaobian-cs-jianda/:7:3","tags":[],"title":"事业编计算机简答题","uri":"/kaobian-cs-jianda/"},{"categories":["编程"],"content":"group by…having 和 where 的区别 mysql 先对数据按照 where 子句过滤，然后在对返回的结果分组，最后对分组后的数据按照 having 子句过滤。 where 是对行过滤，而 having 是对分组过滤，所以可以在 having 子句后面使用聚集函数，而在 where 子句后面使用聚集函数是没有意义的。 ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:1:0","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"join…on 和 where 的区别 在联结查询中，join…on…子句和 where 子句是可以一起出现的，要想弄清楚它们的区别，首先要清楚联结查询的过程。联结查询时要先根据联结条件对两张表做笛卡尔积，生成一个大表，然后再对这个大表做过滤，最终得到查询结果。 join…on 和 where 的区别在于，join…on…子句是在联结时生效，而 where 子句是在联结后生效。 因此，当联结是外部联结（联结子句是 left join 或 right join）时，由于外部联结会将左表或右表中没有建立联结的行都返回，所以 on 后面的条件不会去掉那些不符合条件的行，而 where 子句是严格的，会将不等值的行都去掉。 而当联结是内部联结（等值联结）的时候，联结子句（join…on…）只会返回等值的行，这时写在 on 后面的条件和 where 子句中的条件是等价的，因此，使用内部联结的时候，完全可以用 where 子句代替 join…on… ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:2:0","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"窗口函数 参考mysql-8.0-documentation-window-functions ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:3:0","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"介绍 窗口函数是 mysql 8.0 加入的功能，目的是为了满足分组统计场景的查询需求。 我们使用 SQL 语句查数据时通常会有一些统计分析的需求（例如聚合和排序），一般有以下三类统计场景： 简单统计 按条件查出数据后，对返回数据整体做统计操作，这种统计使用select...from...where...order by配合聚合函数即可完成。 分组聚合 按条件查出数据后，对数据分组，然后对每个分组做聚合操作，每个分组返回一条数据即可，这种统计使用group by即可完成。 分组统计 很多时候我们既想分组，又想对分组聚合，又想把分组内部的数据全部返回，而不是每个分组只返回一个数据，这时光用group by是不能完成任务的，为了解决问题，我们经常要写一堆复杂的自联结，不仅 SQL 难以读懂，而且查询效率也很低下。 窗口函数的引入就是为了方便解决上述第三种查询场景，我们可以使用窗口函数对分组内部的数据做统计，然后把统计后的数据全部返回，并且可以按排序为每行计算出一个序号，方便我们使用序号对数据做二次过滤 对于窗口函数来说，“窗口”的概念非常重要。窗口函数会对组内的每条记录执行统计，这需要给窗口函数规定一个统计范围（例如统计范围是从当前行的前一行到当前行的后一行），我们把这个统计范围称为窗口，有的窗口函数的窗口是固定的，有的是滑动的，需要用户指定 ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:3:1","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"用法 以下是窗口函数的用法 -- 简单写法（把窗口函数返回的行序号作为新的一列new_col） selectwindow_function()over(partitionxxxorderbyxxx)asnew_col-- 上面也可以把分组条件拆成单独的window语句 selectwindow_function()overwasnew_colfromxxxwindowwas(partitionxxxorderbyxxx) 窗口函数的完整语法如下 window_function_name(expression)OVER([partition_defintion][order_definition][frame_definition]) window_function_name(expression) 是窗口函数，over()为窗口函数指定了分组规则，如果里面什么都不写就是在整个表上运行窗口函数 partition子句定义了按哪些列分组，order by子句定义了按哪些列排序，frame子句定义了一个滑动窗口，分为按行定义和按范围定义 窗口函数只能用在 select 列表和 order by 子句里。mysql 是对 where、group by、having 子句返回的结果上进行窗口函数的处理，处理顺序在 order by、limit、select distinct 之前 frame语法 -- frame_units是窗口类型，frame_extent是窗口范围 frame_unitsframe_extent-- frame_units有两种，ROWS和RANGE，分别是按行指定范围和直接指定范围 frame_units:{ROWS|RANGE}-- 对于ROWS，也有两种，只指定开始行（结尾行默认是当前行），和同时指定开始和结束行 frame_extent:{frame_start|frame_between}frame_between:BETWEENframe_startANDframe_endframe_start,frame_end:{CURRENTROW-- 当前行 |UNBOUNDEDPRECEDING-- 分组第一行 |UNBOUNDEDFOLLOWING-- 分组最后一行 |exprPRECEDING-- 当前行之前的expr行，例如10 PRECEDING的意思是当前行之前的10行 |exprFOLLOWING-- 当前行之后的expr行 } ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:3:2","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"常用窗口函数 以下是常用窗口函数（不是全部） 函数 功能 row_number() 返回分组内排序后的行号 rank() 返回排序后的序号，如果有并列的行，它们行号相同，行号是并列组前面的总记录数+1 dense_rank() 返回分组内排序后的序号，如果有并列的行，它们行号相同，行号是上一个并列组的序号+1 first_value(expr)/last_value(expr) 返回窗口中的第一个行或最后一个行，并对其做表达式计算 lag(expr,N,default) 返回分组内位于当前行之前N行（这里是指上方）的行，default是指如果没有之前N行返回的值，N和default的默认值分别为1和null lead(expr,N,default) 返回分组内位于当前行之后N行（下方）的行。（这里的之前之后是指遍历顺序） nth_value(expr,N) 返回窗口内的第n行 ntile(n) 将组内行平均分成n个桶，返回每个行所属的桶号 以下是row_number、rank和dense_rank的区别 +------+------------+------+------------+ | val | row_number | rank | dense_rank | +------+------------+------+------------+ | 1 | 1 | 1 | 1 | | 1 | 2 | 1 | 1 | | 2 | 3 | 3 | 2 | | 3 | 4 | 4 | 3 | | 3 | 5 | 4 | 3 | | 3 | 6 | 4 | 3 | | 4 | 7 | 7 | 4 | | 4 | 8 | 7 | 4 | | 5 | 9 | 9 | 5 | +------+------------+------+------------+ ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:3:3","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"其他 ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:4:0","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"case 函数 case 函数可以用在 select 子句里，并将其结果命名为一个字段，还可以按这个字段分组，比如以下 sql selectcasewhenage\u003e=25then\"25岁及以上\"else\"25岁以下\"endasage_cut,count(id)asnumberfromuser_profilegroupbyage_cut; 这个 sql 返回的结果如下所示 age_cut,number 25岁以下,4 25岁及以上,3 case 函数有两种写法，第一种， CASE\u003c表达式\u003eWHEN\u003c值1\u003eTHEN\u003c操作\u003eWHEN\u003c值2\u003eTHEN\u003c操作\u003e...ELSE\u003c操作\u003eENDCASE; 第二种（有点类似于 golang 的 switch 语句）， CASEWHEN\u003c条件1\u003eTHEN\u003c操作\u003eWHEN\u003c条件2\u003eTHEN\u003c操作\u003e...ELSE\u003c操作\u003eENDCASE; ","date":"2022-07-28","objectID":"/13.mysql-complex-sql/:4:1","tags":["mysql","数据库","sql"],"title":"mysql中的复杂查询","uri":"/13.mysql-complex-sql/"},{"categories":["编程"],"content":"IP地址的发展 最开始将IP地址分为ABCDE五类地址，后来为了不浪费IP地址资源提出了划分子网，发明了子网掩码，再后来又（在可变长子网掩码VLSM的基础上）提出了无分类域间路由CIDR（Classless Inter-Domain Routing），提出了变长网络前缀，进一步提高了IP地址利用率 在最初的五类IP编址方法中，IP地址是两级编址，由网络号+主机号构成。划分子网被提出后，IP地址变为了三级编址，即网络号+子网号+主机号。到了CIDR出现以后，就不再使用之前的IP地址分类和划分子网的概念了，而是使用长度可变的网络前缀代替了网络号和子网号，写的时候使用“斜线记法”，即在IP地址后面加一个斜线“/”，然后写上网络前缀所占的位数。 CIDR实际上已经没有子网的概念，但仍然使用掩码这一称呼，IP地址从三级（网络号+子网号+主机号）又变回了两级（网络号+主机号） ","date":"2022-07-15","objectID":"/ip-address/:1:0","tags":["网络"],"title":"关于IP地址的发展","uri":"/ip-address/"},{"categories":["编程"],"content":"最初的五类IP地址 一个IPv4地址共四个字节，由网络号和主机号组成。IPv4地址分为A、B、C、D、E五类 网络号全0代表本网络，因此，A、B、C类地址分别有一个网络号不能使用（0.0.0.0/8，128.0.0.0/16，192.0.0.0/24）。但是随着后来子网和CIDR的出现，IP地址分类已经没有意义，128.0.0.0/16已经被分配出去了，192.0.0.0/24暂时还保留在IANA手中，以后或许会分配出去，只有0.0.0.0/8这个网络号被0.0.0.0占用，代表未指定地址 此处参考 知乎tckidd的回答 RFC790-Assigned numbers ，RFC790中给出了具体的IP地址划分 RFC791-Internet Protocol ，RFC791中规定了全0表示本网络 RFC3330-Special-Use IPv4 Addresses ，RFC3330声明了128.0.0.0/16和192.0.0.0/24不再保留 主机号全1表示本网络中的所有主机，因此主机号全1的IP地址是一个广播地址。主机号全0时这个IP地址就是网络号。 特殊地址： 环回地址（loopback），127.0.0.1，等价于localhost和本机ip。（实际上整个127.0.0.0/8网段都是环回地址） 地址0.0.0.0代表未指定地址，一般用于默认地址，相当于占位符 0.0.0.0/8中除0.0.0.0以外的其他地址用于表示本网络中的特定主机 主机号全0 主机号全1 A类网络号占一个字节，由0开头。其中，全0的网络号被0.0.0.0/8占用，全1的网络号被环回地址占用，因此A类网络号范围是1~126。 B类网络号占两个字节，由10开头（范围是128.0.0.0/16~191.255.0.0/16） C类网络号占三个字节，由110开头 D类IP地址是多播地址，由1110开头 E类IP地址保留，由11110开头 A、B、C三类地址都各自划分出一块区域作为私有地址 A类私有地址，10.0.0.0~10.255.255.255 B类私有地址，172.16.0.0~172.31.255.255 C类私有地址，192.168.0.0~192.168.255.255 ","date":"2022-07-15","objectID":"/ip-address/:2:0","tags":["网络"],"title":"关于IP地址的发展","uri":"/ip-address/"},{"categories":["编程"],"content":"格式化输入输出 参考https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#formatted-string-literals print(\"demo1: {0}{1}{2}\".format(\"hello\", 2, 3)) print(\"demo2: %s%d%d\" % (\"hello\", 2, 3)) ","date":"2022-07-08","objectID":"/python-basic/:1:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"for 循环 n = [1,2,3,4] # 正序 for v in n: ... for i in range(10): ... # 倒序 for v in reversed(n): ... for i in range(10,-1,-1): #从10到0，步长为-1，第三个参数为步长 ... ","date":"2022-07-08","objectID":"/python-basic/:2:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"列表推导式 # 创建一个长度为10的数组，每个元素的值为下标的平方 squares = [x**2 for x in range(10)] ","date":"2022-07-08","objectID":"/python-basic/:3:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"创建数组 # 1维数组 array1d = [0]*(len(s)) array1d_2 = [0 for i in range(len(s))] # 2维数组 array2d = [[0]*(len(s)) for i in range(len(s))] array2d = [[0 for i in range(4)] for i in range(len(s))] # 唯独不能这么写：array2d = [[0]*4]*5，因为*操作对于引用类型来说是传递引用操作，这等于把一维数组的引用复制了5份 ","date":"2022-07-08","objectID":"/python-basic/:4:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"list ","date":"2022-07-08","objectID":"/python-basic/:5:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"翻转 n = [1,2,3] n.reverse() # 原地翻转 reversed(n) # 返回一个翻转后的迭代器，原序列不变 ","date":"2022-07-08","objectID":"/python-basic/:5:1","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"迭代器和生成器 迭代器 n = [1,2,3,4] # 获取迭代器 it = iter(n) # 通过迭代器访问数据 while True: try: print(next(it)) except StopIteration: break # 遍历迭代器 it = iter(n) for i in it: print(i) 生成器是一种特殊的迭代器，作用是一边迭代一边生成数据 # 1. 创建生成器 # （1）生成器表达式（类似列表推导式） b = (i for i in range(5)) # （2）生成器函数 def gen1(): yield 1 yield \"hello\" yield 3 def gen2(n): for i in range(n): yield i b = gen1() c = gen2(4) # 2. 遍历生成器 while True: try: print(next(b)) # 0 except StopIteration: break ","date":"2022-07-08","objectID":"/python-basic/:6:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"拷贝 ","date":"2022-07-08","objectID":"/python-basic/:7:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"可变类型和不可变类型 python 里的类型分为可变类型和不可变类型两类 常见的基本类型，例如整型、字符串类型、浮点型，这些类型都是不可变类型。不可变类型类似于其他语言中的值类型，如果对象 a 赋值给对象 b，并且要修改 b，python 就会先把内存复制一份再修改，也就是说，修改 a 不会影响 b，是一种 copy-on-write 机制。 可变类型一般是容器类型，例如 list、dict、tuple 等。可变类型类似于其它语言中的引用类型，对象 a 给对象 b 赋值时传递的是引用，修改 b 中的数据会导致同时修改 a 和 b ","date":"2022-07-08","objectID":"/python-basic/:7:1","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"深拷贝和浅拷贝 深拷贝和浅拷贝特指标准库 copy 模块中的 copy 和 deepcopy。 copy 被称为浅拷贝，只拷贝第一层数据，如果第一层某个数据是一个 list，那只会把这个 list 的引用拷贝过来 deepcopy 被称为深拷贝，是一种递归拷贝 ","date":"2022-07-08","objectID":"/python-basic/:7:2","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"不同语言中的拷贝和引用 像 python、golang、java 等上层语言对拷贝和引用的处理和 C++不同。 在这些上层语言中，一般都会区分引用类型和值类型，对于值类型，=操作符往往执行的是拷贝操作，对于引用类型，=操作符往往会执行传递引用操作，引用类型的拷贝往往需要一个专门的操作，例如 python 中是copy，java 中是clone。 而在 C++中，=操作符无论对什么对象都是赋值/拷贝操作，如果想传引用，必须在引用变量初始化的时候对其传递引用，并且要指定被传值的变量是引用类型（利用\u0026）。这就导致了，在 C++中，引用变量一旦创建就不能修改引用指向，后续做的所有=操作都是对引用对象的拷贝/赋值操作 ","date":"2022-07-08","objectID":"/python-basic/:7:3","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"lambda 表达式 lambda x: x**2 ","date":"2022-07-08","objectID":"/python-basic/:8:0","tags":["python"],"title":"Python 基础","uri":"/python-basic/"},{"categories":["编程"],"content":"常用方法 常用方法： 动态规划，把问题转化为子问题的求解，在子问题求解完成的基础上即可得到问题的解，重点在于（1）问题的建模，（2）求出正确的递推方程，（3）搞清楚基本问题的解 双指针，重点在于搞清楚什么时候移动哪个指针 二分 回溯（DFS） 分治 常用辅助工具：排序，map，堆，栈，队列 ","date":"2022-07-06","objectID":"/algorithm-problem/:1:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 4.寻找两个正序数组的中位数 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数 ","date":"2022-07-06","objectID":"/algorithm-problem/:2:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"方法1-归并法 方法1，按归并的思路，每次排除一个数，直到找到中位数为止。时间复杂度O(m+n) ","date":"2022-07-06","objectID":"/algorithm-problem/:2:1","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"方法2-改良的归并法 方法1是一种比较符合直觉的方法，更进一步，我们考虑每次多排除一些数，以提高算法的执行速度。 寻找中位数问题可以视为寻找第k大数问题的特殊情况，现在设中位数是第k大的数为Kth，我们每次比较k/2个数，就能每次排除掉k/2个数。随着被排除的数逐渐增多，k会逐渐变小，当k变为1的时候，比较最后一次，就找到了Kth。由于k每次缩小一半，时间复杂度为O(log(m+n)) 这里面有一个关键问题，为什么比较步长是k/2？ 为了解释这个问题，先看一个例子， A：1，2，3，8 B：4，5，6，7 有递增序列A和B，现在我们想找到第4大的数（即4），如果将比较步长设置为4，即直接比较7和8，会导致4,5,6,7全都被排除掉，最后无法找到4。所以我们必须设置合理的比较步长，来避免这种情况。 下面说明为什么是k/2 在对位于比较点的两个数做比较后，我们会将较小数及其之前的数排除掉。为了保证一定能够排除较小数及其之前的数，我们必须保证Kth不在被排除的数中，换言之，我们一定不能让位于比较点的两个数都大于Kth。 假设有以下两个序列 A：a0,a1,...,am B: b0,b1,...,bn 假设比较步长为p，位于比较点的两个数是ap，bp，现在对Kth所在位置分情况讨论 ap和bp都在Kth之前 ap在Kth之前，bp在Kth之后（即Kth∈[b0,bp]） ap在Kth之后（即Kth∈[a0,ap]），bp在Kth之前 情况1不做讨论，排除哪个都行。 情况2和情况3是等价的，现在假设Kth∈[a0,ap]，即a0 \u003c= kth \u003c= ap，如果我们想排除[b0,bp]，就必须保证bp \u003c= Kth \u003c= ap，即不能让位于比较点的两个数都大于等于Kth 当比较步长p为k/2时，[a0,ap]和[b0,bp]加起来一共k个数，如果ap和bp都大于Kth，[a0,ap]和[b0,bp]加起来一定会超过k个数，前后矛盾。所以当比较步长为k/2时必不可能出现比较点的两个数都大于Kth这个情况，反之当比较步长大于k/2时，被比较的两个子序列的数字量大于k，就有可能出现这个情况。 相应的，如果有三个有序数列，比较步长最长为k/3，有四个序列，比较步长最长为k/4，以此类推。 ","date":"2022-07-06","objectID":"/algorithm-problem/:2:2","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"方法3-二分法 方法2是将问题转化为求第K大的数，而方法3是利用了中位数的以下性质： 中位数两边的数个数相等 中位数左边最大的数小于右边最小的数、 具体方法是分别将序列1和序列2一分为2，将左序列1+左序列2视为左半部分，将右序列1+右序列2视为右半部分，保证左半部分的数字个数等于右半部分的数字个数，并且左半部分的最大值大于右半部分的最小值。 那如何找到切分位置？在较短序列上进行二分搜索即可 ","date":"2022-07-06","objectID":"/algorithm-problem/:2:3","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 10.正则表达式匹配 给你一个字符串s和一个字符规律p，请你来实现一个支持'.‘和’*‘的正则表达式匹配。 ‘.‘匹配任意单个字符 ‘*‘匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。 用动态规划求解 将问题转化为求f[i][j]的问题，f[i][j]指字符串s的前i个字符和模式p的前j个字符是否匹配。 以下是该问题的求解方程 1. 当p[j-1]不是'*'时， 如果p[j-1]和s[i-1]匹配， f[i][j] = f[i-1][j-1] 否则 f[i][j] = false 2. 当p[j-1]是'*'时（要看'*'前面那个字符）， 如果p[j-2]不和s[i-1]匹配(字母和'*'的组合被干掉)， f[i][j] = f[i][j-2] 否则，既可以字母和'*'的组合被干掉也可以s[i-1]被干掉 f[i][j] = f[i][j-2] or f[i-1][j] 当s和p都为空时，视为匹配，即f[0][0]=True。p为空，s为空时，一定不匹配，即f[0][x]=False。而s为空，p不为空时，不一定匹配，例如p为a*a*时，可以和空串形成匹配，因此在循环时，i要从0开始，j可以从1开始。 ","date":"2022-07-06","objectID":"/algorithm-problem/:3:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 5.求最长回文子串 给你一个字符串s，找到s中最长的回文子串。 示例 1： 输入：s = “babad” 输出：“bab” （“aba” 同样是符合题意的答案。） 使用动态规划求解 将问题转换为求f[i][j]的问题，f[i][j]是指s的子串s[i,j]是否为回文串，求f[i][j]之前要先求出f[i+1][j-1] ","date":"2022-07-06","objectID":"/algorithm-problem/:4:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 11.盛水最多的容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 用双指针法求解，双指针的初始位置位于数组两端，不断向中间逼近，每次移动高度较低的指针（移动指针会导致容器底部变小，为了寻找更大的容积，就要舍弃较低的边，保留较高的边） ","date":"2022-07-06","objectID":"/algorithm-problem/:5:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 15.三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 三数之和要求对组合去重，这个问题和两数之和有所不同，在两数之和问题中，每个数只能属于一个组合，所以，要对组合去重，只要给已经构成组合的数打标记即可，不用对组合打标记。但是对三数之和问题不能采用这种去重方法，因为一个数可以属于多个组合，如果要采用打标记这种方式，必须对组合打标记，不能对数打标记。 因此，通过打标记去重在三数之和问题中不可行 采用排序+双指针的方法，可以在O(n^2)的时间复杂度内完成求解 ","date":"2022-07-06","objectID":"/algorithm-problem/:6:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 23.合并K个升序链表 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 设链表个数为k，节点总数为n 方法1，从k个链表的开头各拿出一个节点，从这k个节点中选取一个最小的链接到大链表中，利用堆选取最小元素，堆操作的时间复杂度是O(logk)，一共n个节点，总的时间复杂度为O(nlogk) 方法2，对k个链表进行两两归并，归并次数是logk，归并的时间复杂度是O(n)，总的时间复杂度是O(nlogk) 方法2的归并策略是尽量降低归并次数，还有另外一种归并策略是尽量降低比较次数，具体方法是每次选取长度最短的两个序列进行归并，但是由于本题是对链表进行归并，无法快速获取序列长度，因此无法采用这种策略 ","date":"2022-07-06","objectID":"/algorithm-problem/:7:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["编程"],"content":"leetcode 31.下一个排列 给你一个整数数组 nums，找出nums 的下一个排列。 必须原地修改，只允许使用额外常数空间。 思路 如果序列最后两个元素是正序，直接交换这两个元素即可 在剩下的情况中，每个排列都可以分成前后两个子序列a，b，并且子序列b是一个倒序序列 例如， [1,2,5,4,3] = a+b = [1,2]+[5,4,3] 此时子序列b自己没有下一个排列，要想为nums找到下一个排列，必须把a的最后一个元素和b中的一个元素交换，这个元素必须刚好大于a。交换后，子序列b仍然是一个倒序序列，将b翻转，就完成了求解 两次遍历，一次翻转，时间复杂度为O(n)，第二次遍历可以改成二分查找，但是总的时间复杂度仍然是O(n) ","date":"2022-07-06","objectID":"/algorithm-problem/:8:0","tags":["算法"],"title":"算法题","uri":"/algorithm-problem/"},{"categories":["游戏","编程"],"content":"参考 unity manual unity-essentials系列教程 ","date":"2022-06-26","objectID":"/unity-note/:1:0","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["游戏","编程"],"content":"本文约定 粗体代表术语 ","date":"2022-06-26","objectID":"/unity-note/:2:0","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["游戏","编程"],"content":"编辑器操作 ","date":"2022-06-26","objectID":"/unity-note/:3:0","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["游戏","编程"],"content":"场景视图导航 pan（移动视图）：使用“手”工具，按住鼠标左键拖动视图 zoom（放缩）：使用鼠标滚轮或按住alt和鼠标右键拖动 orbit（环绕物体）：按住alt和鼠标左键拖动 focus（聚焦）：按F聚焦到一个对象 flythrough mode（飞越模式）：飞越模式是指第一人称视角，飞越模式的所有操作都需要按住鼠标右键 按住鼠标右键拖动来环顾四周 用wasd前进后退左移右移 用qe上升下降 按住shift移动得更快 ","date":"2022-06-26","objectID":"/unity-note/:3:1","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["游戏","编程"],"content":"场景视图工具 快捷键Q，移动相机 快捷键W，移动 快捷键E，旋转 快捷键R，拉伸 快捷键T，2D拉伸 快捷键Y，移动+旋转+拉伸 ","date":"2022-06-26","objectID":"/unity-note/:3:2","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["游戏","编程"],"content":"概念 primitive object（原始对象） Primitive object是基本3D形状的游戏对象，例如立方体（cube）和球体（sphere），可以将它们添加到场景中作为后续导入资源的占位对象。 如何在创建中创建：在hierarchy的空白处右键，选择3D object，选择一个原始对象 ","date":"2022-06-26","objectID":"/unity-note/:4:0","tags":["unity"],"title":"Unity入门笔记","uri":"/unity-note/"},{"categories":["考编"],"content":"考点 组成原理、体系结构 网络 操作系统、windows 数据库 软件工程 安全 office 编程语言(c、java) 基础数据结构、算法 ","date":"2022-06-21","objectID":"/kaobian-cs/:1:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"组成原理 多媒体信息：文本，图片，音频，视频，动画… 计算机内部通常是并行传输，通信线路上通常是串行传输 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"编码 码距：两个码不同的二进制位数 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"RAID raid0：假设有 disk1、disk2、disk3、disk4 四块硬盘，数据被分为四份分别放在四块硬盘上 优点：硬盘空间利用率高、处理大文件速度快 缺点：一块硬盘损坏，所有数据均不可用 raid1：至少要有两块硬盘，一块硬盘存储，一块硬盘做备份 优点：提供数据冗余 缺点：可使用容量减半 raid2：在 raid0 基础上加入汉明码纠错 raid3：在 raid0 基础上增加一块硬盘专门做奇偶校验 raid4：不常见，略 raid5：和 raid0 类似，一个数据分为多份，分别存储到不同的硬盘上去，但会有另外一块硬盘专门存放这个数据的校验码，各个数据的存储是独立的，所有硬盘都可以作为存储盘和校验盘 优点：兼顾存储性能、数据安全、存储成本 缺点：有两块或两块以上硬盘损坏，数据就无法恢复、数据重建慢 raid6：在 raid5 的基础上加入双重校验 raid10/raid01：raid1 和 raid0 的结合 raid7：最优化的异步高 I/O 速率和高数据传输率，RAID7 不仅仅是一种技术，还是一种存储计算机，可完全独立于主机运行，不占用主机 CPU 资源 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:2","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"图灵和冯诺依曼 图灵，计算机科学之父，人工智能之父，计算机科学的奠基人 冯·诺依曼，现代计算机之父，博弈论之父，提出冯诺依曼结构 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:3","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"字符编码方案 输入码是指输入字符时的编码，例如五笔码、全拼码等 交换码是指逻辑上的编码标准，例如 unicode 就是一种交换码 内码是指字符在计算机内部实际的编码方案，例如 utf-8 就是一种内码 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:4","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"接口 SCSI 并行接口，支持热插拔 IEEE 1394 串行接口，传输速度快。最早由苹果公司为了取代 SCSI 提出。USB 和 IEEE 1394 是现今比较流行的两种外部总线标准 rs232：两排，共 9 针（一排 4 针，一排 5 针），全双工，距离短，速度慢 rs485：无固定接口，半双工，距离长，速度快 DVI 接口：三排 15 针 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:5","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"周期 指令周期：计算机执行一条指令需要的时间 CPU 周期/机器周期：一条指令的执行分为若干阶段，每个阶段的执行周期称为 CPU 周期或机器周期。（通常用一次方访存时间来衡量） 时钟周期：振荡周期，一个时钟滴答 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:6","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"内存-缓存映射 直接映射：一个内存块映射到固定的缓存块 半相联映射：一组内存块映射到固定的缓存块，块内部是任意映射 全相联映射：任意一个内存块映射到任意一个缓存块 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:7","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"总线 PCI 总线 以桥连接实现的 PCI 总线允许多条总线并行工作 系统中允许有多条 PCI 总线 基本传输机制是猝发式传输 同步时序协议和集中式仲裁策略 ","date":"2022-06-21","objectID":"/kaobian-cs/:2:8","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"windows 系统 windows 通配符：“*”用于匹配多个字符，“?”用于匹配单个字符 windows 中不能作为文件名的是：/\u003c\u003e?* fat 分区最大 2TB，最大文件 4GB ","date":"2022-06-21","objectID":"/kaobian-cs/:3:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"windows 快捷键 win7 开机时进入安全模式按 f8 切换语言，shift+alt 切换输入法，shift+ctrl 切换输入法的语言，shift 或 ctrl+空格 全半角状态转换，shift+空格 打开开始菜单，ctrl+esc 或 win ","date":"2022-06-21","objectID":"/kaobian-cs/:3:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据库 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据库的特征 持久存储（不属于基本特点，选择题不选） 数据结构化，有组织，按一定数据模型组织、描述和存储（数据冗余度低） 数据可共享 数据独立性高，易扩展。数据独立性分为逻辑独立性和物理独立性 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据库管理系统（DBMS） 位于操作系统之上，管理数据库，提供数据定义、数据操纵、数据控制、数据查询四种功能，并对应有以下语言供用户使用 DDL，数据定义语言（建库、建表等） DML，数据操纵语言（增、删、改） DCL，数据控制语言 DQL，数据查询语言 此外还负责网络通信，保障数据安全性和完整性，事务控制，并发控制等 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:2","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据库系统结构 三级模式：外模式、模式和内模式 二级映射：外模式-模式映射、模式-内模式映射 外模式，又称子模式或用户模式，对应用户级，用户使用外模式描述语言来定义用户的数据记录，或者使用 DML 对数据记录做描述。 模式，又称概念模式或逻辑模式，对应于概念级，是所有用户的公共数据视图，使用 DDL 来描述。 内模式，又称存储模式，对应于物理级，描述了数据在存储介质上的物理结构。 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:3","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据模型 数据模型分为概念数据模型、逻辑数据模型、物理数据模型 概念数据模型是从用户视角描述数据，反映客观世界的联系和规则 E-R 图（实体-联系图）是一种概念模型，用实体、属性和联系来描述客观世界，联系也称关系，分为一对一、一对多、多对多。实体用矩形表示，属性用椭圆形表示，关系用菱形表示。 逻辑数据模型由数据结构、数据操作和完整性约束构成 数据库支持的逻辑数据模型有层次模型、网状模型、关系模型和面向对象模型。 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:4","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"关系型数据库 关系数据模型，是一种用二维表结构来表示实体和实体间关系的模型 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:5","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"关系规范化理论 关系规范化理论是一种用来指导如何设计关系型数据库的理论，规范化用形式更简洁、结构更规范的关系模式取代原有关系模式，其目的是为了解决不合理的关系模式设计导致的数据冗余、操作异常（增删改异常）等问题。 完整的关系模式是一个五元组 R(U,D,Dom,F)，R 是关系，U 是属性集，D 是属性的域，Dom 是属性到域的映射，F 为属性的数据依赖集 关系模型可以简化为一个三元组 R(U,F) 数据依赖是关系模式的重点，包括函数依赖、多值依赖和连接依赖 函数依赖 对于 R(U)，设 X 和 Y 是 U 的两个子集，如果对任意一个 X，有唯一的 Y 与之对应，则这个依赖是函数依赖，称为“X 函数确定 Y”或“Y 函数依赖 X”，记为X-\u003eY，X 为决定因素，Y 为依赖因素。例如，确定了学号，就能确定姓名、性别等。 函数依赖有三种情形 平凡函数依赖和非平凡函数依赖 如果 Y 是 X 的子集，Y 对 X 就是平凡函数依赖，否则是非平凡函数依赖。 完全函数依赖和部分函数依赖 如果 X 的任何一个真子集都不能决定 Y，Y 对 X 就是完全函数依赖，否则是部分函数依赖。 传递函数依赖 如果 X-\u003eY，Y-\u003eZ，且不存在 Y-\u003eX，那么 Z 对 X 传递依赖。 码/键 码/键 表中的一个或几个属性，用来标识该表的每一行或与另一个表产生联系 超码/超键 去掉一个属性，还是码 候选码/候选键 最小的码（属性集完全函数依赖于该码） 主码/主键 从候选码中选一个 主属性 候选码中的属性是主属性 规范化 不同的规范化程度可用范式来衡量。目前有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、BC 范式（BCNF）、第四范式（4NF）和第五范式（5NF）。 第一范式，关系 R 的每个属性都不可分解，都是原子的 第二范式，关系 R 满足第一范式，且所有非主属性都完全函数依赖于任意候选码 第三范式，关系 R 满足第二范式，所有非主属性都不传递函数依赖于任何候选码 BCNF 范式，基于满足第一范式的基础之上，是对第三范式的改进 BCNF 范式，关系 R 满足第一范式，对任何非平凡依赖 X-\u003eY（Y!-\u003eX），X 都包含码，这意味着 （1）所有非主属性都完全函数依赖于每个候选码 （2）所有主属性都完全函数依赖于每个不包含它的候选码 （3）没有任何属性完全函数依赖于非码的任何一组属性 数据库设计普遍采用的是基于 3NF 的设计方法 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:6","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"事务 事务是用户定义的一个操作系列，具有原子性，要么都完成，要么都不完成。事务可以是一条 SQL 语句，也可以是一组 SQL 语句 事务的 ACID 特性：原子性、一致性、隔离性、持久性 ","date":"2022-06-21","objectID":"/kaobian-cs/:4:7","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"网络 计算机网络要求误码率低于 10^-6，如果达不到这个指标，就必须进行差错校验 按网络覆盖范围分类 WAN（wide area network），广域网 MAN（metropolitan area network），城域网 LAN（local area network），局域网，是一种点对点结构的网络 WLAN（wireless local area network），无线局域网 PAN（personal area network），个人区域网络（蓝牙、USB 等） CAN（campus area network），校园区域网络 SAN（storage area network），存储区域网络 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"服务访问点 SAP 服务访问点 SAP 是指上下两层协议实体之间的逻辑接口（某一层的 SAP 是其对上层的访问接口），例如网络层的 SAP 是 IP 地址 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"物理层 物理层设备： 光纤，光纤只能单向传输，光纤抗干扰和传输距离都比同轴电缆强 中继器，集线器 双绞线 既可以传输模拟信号，又可以传输数字信号 不仅适用点到点连接，也适用多点连接 计算机中的传输设备包括：双绞线、同轴电缆、光纤、无线传输介质（无线电波、微波、红外线、激光） 物理协议 电气特性：电压范围 功能特性：电平代表的含义 规程特性：事件顺序 机械特性：接口外形、形状、大小、引脚数 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:2","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"数据链路层 数据链路层设备： 网桥 交换机 网卡，网卡工作在物理层和数据链路层的 MAC 子层 数据链路层有两个子层，逻辑链路控制层（LLC）和介质访问控制层（MAC），LLC 层位于 MAC 层之上。 CSMA/CD 协议，发送数据前先侦听总线的忙/闲状态，发送数据的同时要进行冲突检测 以太网拓扑结构有很多种，主要是总线型，加入交换机后，变为星型拓扑。其他结构还有： 环型 树型 网状型 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:3","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"交换机和集线器的区别 集线器工作在物理层，不涉及网络协议层面的工作，只能以广播模式转发数据 交换机工作在数据链路层，可以根据报文中的 MAC 地址对数据做针对性的转发 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:4","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"网络层 虚电路和数据报 虚电路和数据报是分组交换的两种方式（分组就是包，是网络层的概念），目前因特网用的就是数据报方式。 数据报方式为网络层提供无连接服务，每个分组都包含源地址和目的地址，每个分组独立路由和转发，不保证分组按顺序到达，不保证可靠传输。 虚电路方式为网络层提供面向连接的服务，建立连接后分组只包含一个虚电路号作为标识，同一条虚电路的分组按同一条路由转发，保证分组的有序到达，保证可靠传输。 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:5","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"Internet、Intranet 和 Extranet Internet 是英特网，Intranet 是企业内部网，Extranet 是外联网 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:6","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"安全 文件型病毒主要感染 com 和 exe 文件 ","date":"2022-06-21","objectID":"/kaobian-cs/:5:7","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"操作系统 操作系统的发展：单道批处理系统，多道批处理系统，分时系统，实时系统，通用操作系统 ","date":"2022-06-21","objectID":"/kaobian-cs/:6:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"死锁 死锁是指多个进程并发执行时因争夺资源造成的互相等待现象。 死锁发生有四个必要条件 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到进程使用完成后释放该资源； 请求保持条件：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，而且该进程不会释放自己已经占有的资源； 不可剥夺条件：进程已获得的资源，只能自己释放，不可剥夺； 环路等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 如何解决： 把独占资源变为共享资源 资源一次性分配，从而解决请求保持的问题 资源可剥夺，当进程新的资源未得到满足时，释放已有的资源； 资源有序分配，对所有资源编号，进程请求资源时按资源递增顺序请求，释放则相反，破坏了环路等待条件。 一个著名死锁避免算法，银行家算法 ","date":"2022-06-21","objectID":"/kaobian-cs/:6:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件工程 项目管理三角形：范围、时间、成本 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件生命周期 软件计划阶段 问题定义 可行性分析 可行性分析的目的是用最小的代价在尽可能短的时间内确定该项目是否能够开发，是否值得开发，其本质是要进行一次简化的、压缩的需求分析和设计过程，要在较高层次上以较抽象的方式进行需求分析和设计，给出可行性分析报告 软件开发阶段 需求分析 软件概要设计 软件详细设计 软件编码 软件测试 软件运行阶段 软件运行与维护 软件开发模型 瀑布模型 也称生存周期模型或线性顺序模型，这种模型是将软件生命周期各个阶段活动依线性顺序连接。 各阶段具有顺序性和依赖性 具有推迟实现的特点 重视质量保证，每个阶段都必须完成规定的文档，并对文档进行评审。 缺点：不灵活，必须分析清楚需求才能能到预期结果 快速原型模型 需求分析阶段只进行初步的需求分析，快速设计开发出原型供用户测试评定，根据改进意见丰富细化软件，然后在给用户试用，反复改进，直至用户满意 增量模型 将瀑布模型和快速原型模型相结合，每次发布一个增量，第一个增量是核心产品，用户对每个增量的反馈将成为下一个增量的新特性 螺旋模型 螺旋模型是一种迭代模型，结合了瀑布模型与增量模型，它把开发过程分为几个螺旋周期，在每个周期中加入了风险分析 其他模型 喷泉模型，是一种比较典型的面向对象软件开发模型，适合面向对象的开发方法 基于构件的开发模型 统一过程（RUP）模型 基于形式化的开发模型 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件开发方法 程序设计可以分为面向过程设计和面向对象设计，软件工程也分为面向过程软件工程（即传统软件工程）和面向对象软件工程，面向过程软件工程是以结构化程序设计为基础，面向对象软件工程是以面向对象程序设计为基础。 结构化开发方法 结构化开发方法(Structured Developing Method)是现有的软件开发方法中最成熟，应用最广泛的方法。结构化开发方法由结构化分析方法(SA 方法)、结构化设计方法(SD 方法)及结构化程序设计方法(SP 方法)构成。 面向对象方法 基本概念：类、对象、实例、消息（一个函数调用）、方法… 面向对象建模得到的模型包含系统的 3 个要素：静态结构（对象模型）、交互次序（动态模型）和数据变换（功能模型）。 对象模型：描述数据结构（UML 图） 动态模型：描述交互和次序（状态图） 功能模型：功能模型作用在对象模型说明的数据上，同时还表示了对对象值的约束 对象的特点：标识唯一性、分类性/抽象性、多态性、封装性 面向对象的特点：封装、继承、多态 Jackson 方法 Jackson 方法是一种面向数据结构的开发方法。 JSP(JacksonStructure Programming）方法以数据结构为驱动，适合小规模项目。JSP 方法首先描述问题的输入/输出数据结构，分析其对应性，然后推出相应的程序结构，从而给出问题的软件过程描述。 JSD 方法是 JSP 方法的扩展，是一个完整的系统开发方法。首先建立现实世界的模型，再确定系统的功能需求，对需求的描述特别强调操作之间的时序性。它是以事件作为驱动的，是一种基于进程的开发方法，所以适用于时序特别较强的系统，包括数据处理系统和一些实时控制系统。 Jackson 图，描述数据元素彼此之间的逻辑关系，只有顺序、选择和重复三类。 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:2","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"面向过程的软件开发 一、结构化分析方法（SA） 结构化分析方法（Structured Analysis，SA），是面向数据流的需求分析方法。结构化分析就是使用数据流图、数据字典、结构化语言、判定树和判定表等工具，来建立一种新的称为结构化说明书的目标文档。 采用自顶向下逐层分解的分析策略，把一个复杂问题分解成若干小问题。分解可分层进行，在分解中要充分体现“抽象”的原则，上一层就是下一层的抽象。最高层的问题最抽象，而低层的较为具体。 结构化分析工具： 可划分成非形式化、半形式化和形式化三类，自然语言是非形式化的，数据流图是半形式化的，数学描述是形式化的 数据流图(Data Flow Diagram，DFD)，描述系统由哪几部分组成，各部分之间的联系，描述了系统数据的流动和处理过程。 数据字典。数据字典是关于数据的信息的集合，是对数据流图中包含的所有元素的定义的汇集。 结构化语言，判定树，判定表，用于描述数据流图中的不能被分解的每个基本加工处理逻辑 结构化语言，三种结构，顺序、循环、判定。简单的控制流（顺序执行和循环执行的动作）用结构化语言描述。存在多个条件复杂组合的判断问题，用判定树和判定表描述 判定树，又称决策树，易读 判定表，严格，可以先用判定表做底稿，在此基础上产生判定树 二、软件设计 模块是构成程序的基本构件，是能够独立完成一定功能的程序语句的集合，如高级语言中的过程、函数、子程序等。广义地说，面向对象方法学中的对象也是模块。在软件体系结构中，模块是可以组合、分解和更换的单元。 模块最重要的特征有两个：一是抽象，二是信息隐蔽和局部化 模块化是指解决一个复杂问题时自顶向下逐层把软件系统划分成若干模块的过程。 软件模块设计原则 高内聚低耦合 模块结构的深度、宽度、扇出和扇入应适当。（所有模块会构成树状结构，这些指标就是这棵模块树的指标） 模块的作用范围应该在控制范围内（作用范围是指该模块能影响的模块，控制范围是指从属于该模块的模块） 模块接口设计要简单，以便降低复杂程度和冗余度 设计功能可预测并能得到验证的模块 适当划分模块规模，以保持其独立性 三、 结构化设计方法（SD） 结构化设计方法是以数据流图为基础设计系统的软件结构。 数据流图分为变换型数据流图和事务型数据流图 四、 结构化程序设计方法（SP） 结构化程序设计所使用的结构有顺序、条件和重复三种 五、详细设计工具 过程设计语言（Process Design Language，PDL）也称为伪码（伪代码） ","date":"2022-06-21","objectID":"/kaobian-cs/:7:3","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"面向对象的软件开发 一、 面向对象基本概念 对象的两大要素：属性和操作 类是对具有相同属性和操作的相似对象的抽象 消息 封装是对象和类的一个基本特性 类与类之间的关系：继承、多态、关联、依赖、实现、聚集与组合 统一建模语言UML 二、面向对象的分析 面向对象分许，首要是建模，通常要建立四类模型 对象模型（静态模型），用类和对象表示，该模型主要关心系统中对象的结构、属性与操作，以及对象与对象之间关系的映射。对象模型是对客观世界的对象及对象彼此间的关系静态结构的描述。 类图和对象图 功能模型（用例模型），由用例和场景表示，反映用户对目标系统的需求，描述数据在系统中的变换过程及系统的功能。 用例图 动态行为模型（动态模型），由状态机图和交互图表示的，动态模型定义对象模型中对象的变化序列和生命周期，描述系统中不同对象类之间的交互。 顺序图（时序图）或通信图 状态图或活动图 物理实现模型，由构件图和部署图表示的。 面向对象建模 对象模型：描述数据结构（UML 图） 动态模型：描述交互和次序（状态图） 功能模型：功能模型作用在对象模型说明的数据上，同时还表示了对对象值的约束 对象的特点：标识唯一性、分类性/抽象性、多态性、封装性 面向对象的特点：封装、继承、多态 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:4","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件编码 表驱动法（Table-Driven Methods）是一种编程模式，从表里面查找信息而不使用逻辑语句（if 和 case） ，它的好处是消除代码里面到处出现的 if、else、swith 语句，让凌乱代码变得简明和清晰。逻辑越来越复杂，表驱动法就越有吸引力。 程序调试方法 简单调试，在程序中插入打印语句、运行程序、借助调试工具 归纳法，从特殊推断一般的方法，从线索出发，通过分析线索之间的关系找到问题 演绎法，从一般推特殊，设想可能的原因，用已有的数据排除不合理的假设 回溯法，确定发生错误的地方，沿着程序的控制流往回追溯 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:5","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件测试 测试阶段 单元测试：对最小最基本的软件设计模块进行验证，通常情况下是白盒的，主要针对程序设计、业务逻辑、代码风格进行测试，目的是尽早发现不易显现的错误 集成测试：将各模块按照程序结构图组合起来测试，目的是通过测试发现与模块接口有关的问题 增量集成：逐步集成，分为自顶向下的集成和自底向上的集成，自顶向下是从主模块开始，按照深度优先或广度优先的策略集成，自底向上是从系统结构图的最底层模块开始集成 非增量集成：一次将所有模块组合起来测试，一步到位 系统测试：基于系统整体需求的黑盒类测 回归测试：目的是判断代码修改有没有对软件已有功能引入新的问题 验收测试 alpha 测试：由用户在开发者的场所进行，内部测试，环境受控 beta 测试：由用户在用户场所进行，在开放环境测试，环境不受控，是软件发布前的最后测试 白盒测试，测试者完全了解程序的结构和处理过程，根据程序的内部逻辑设计测试用例，检查逻辑通路是否符合预期 逻辑覆盖测试的六个级别（发现错误的能力由弱到强） 语句覆盖，每条语句至少执行一次 判定覆盖（分支覆盖），覆盖每个判定分支（2和3是并列的） 条件覆盖，覆盖判定条件的每个取值 判定/条件覆盖，同时满足判定覆盖和条件覆盖 条件组合覆盖，覆盖所有判定条件的所有取值组合 路径覆盖，覆盖每条可能的路径 控制结构测试 基本路径测试 条件测试 循环测试 黑盒测试，测试者不关心程序的内部结构，而是根据功能来设计测试用例，检查程序的功能是否符合要求 等价类划分法，将系统的输入域划分为若干部分，从每个部分选取少量代表性数据进行测试。可分为有效等价类和无效等价类。 边界值分析法，优先选择不同等价类的边界值进行测试，因此该方法要和等价类划分法结合使用。 错误推测法，人们根据经验、直觉和简单的判断来推测程序中可能存在的各种错误，从而有针对性地设计测试用例。 因果图法，通过因果图获得判定表 判定表驱动分析法，判定表可以把复杂的逻辑组合表达的非常明确 正交实验设计法，从大量实验点中挑出适量有代表性的点进行测试 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:6","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件维护 软件可维护性的决定因素：可理解性、可测试性、可修改性、可移植性、可重用性 软件可维护性的提高方法： 使用先进的软件开发工具（版本管理，测试工具，调试工具） 明确软件的质量目标和优先级 进行质量保证审查 选择可维护的程序设计语言 详细的设计文档、结构文档、代码文档、维护文档、接口文档（改善可理解性） 良好的软件设计（模块化、高内聚、低耦合、可测试） ","date":"2022-06-21","objectID":"/kaobian-cs/:7:7","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"软件工程中的图 系统流程图，描述系统的功能模型，描绘现在系统和目标系统的概貌。一个系统可以包含人员、硬件、软件等多个子系统。系统流程图以黑盒子形式描述系统的主要成分（硬件设备、程序、文档及各类人工过程等）。表达的是信息在系统各部件之间流动情况。 以概括形式绘图时需要五种符号，加工或处理、输入输出、控制流向、连接或汇合（同于连接同一页的多个图）、换页连接（用于换页连接） 数据流图（DFD），描述系统的功能模型，用于 SA 方法和 SD 方法，描述系统由哪几部分组成，各部分之间的联系，描述了系统数据的流动和处理过程 四种成分，源点和终点、加工、数据存储、数据流 数据流图分为两种典型结构，变换型结构和事务型结构。 变换型结构由三部分组成：输入、变换（数据加工、中心变换)和输出。 事务型结构由三层组成：事务层、操作层和细节层。发出多条路径的数据流中枢被称为“事务中心”，要完成3项基本任务，接受事务（输入数据）、分析每个事务以确定其类型、根据事务类型选一条活动路径。 层次方框图，描述系统的数据模型，用于需求分析，由一个个矩形框构成树形结构，描述数据的层次结构 维纳图（Warnier-Orr），描述系统的数据模型，用于需求分析，和层次方框图类似，也是描述数据的层次结构，用大括号、异或符号和圆括号构建一个树状结构 IPO 图，用于需求分析，IPO 图是输入—处理—输出图（Input-Process-Output）的简称，是美国 IBM 公司发展完善起来的一种图形工具。 软件结构图（Structure Chart，SC），用于软件结构设计，用来表达软件的组成模块及其调用关系，是一种树状图。一般包括，模块、模块间调用关系、辅助符号 辅助符号，弧形箭头表示循环调用；菱形表示选择或者条件调用 层次图，用于软件结构设计，是一种由矩形框构成的树状图，表示模块之间的调用关系 HIPO 图（Hierarchy Plus Input-Process-Output），用于软件结构设计，是层次图加上输入—处理—输出图，是美国 IBM 公司发展起来的一种层次结构的描述工具 程序流程图，用于软件详细设计，使用三种基本控制结构描述程序执行流程。 盒图（N-S图），用于软件详细设计，也是顺序、选择、循环三种基本结构 PAD图，PAD（Problem Analysis Diagram）问题分析图是日本日立公司于1979年提出的一种算法描述工具。有六种基本结构。 用例图，用于面向对象分析中功能模型，包括包含关系（\u003c\u003cinclude»）、扩展关系（\u003c\u003cextend»）、泛化关系（三角形箭头）、使用关系（\u003c\u003cuse»） 对象和类图，用于面向对象分析中对象模型 顺序图（时序图），用于面向对象分析中动态模型 强调交互的时间顺序 通信图，用于面向对象分析中动态模型 强调交互的空间结构 状态图，用于面向对象分析中动态模型，活动图和状态图都是状态机的表现形式 活动图，活动图可以分区，分区后的图被称为泳道图，每个分区都是一个对象的负责范围，属于某个对象的负责的活动会被放到这个对象的分区 构件图，用于面向对象分析中物理实现模型，构件是指一个可装配的独立物理块，一般是一个文件 部署图，用于面向对象分析中物理实现模型 ","date":"2022-06-21","objectID":"/kaobian-cs/:7:8","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"信息安全 ","date":"2022-06-21","objectID":"/kaobian-cs/:8:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"office 快捷键 保存、搜索（略） 打开文件：ctrl+o 新建文件：ctrl+n 打印：ctrl+p 退出操作 双击左上角 左/右键单击左上角，选关闭 右键单击标题栏中间，选关闭 单击右上角红叉 文件-\u003e关闭 alt+f4 ","date":"2022-06-21","objectID":"/kaobian-cs/:9:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"word 两种编辑方式，插入和改写（使用 insert 键调整） 查找和替换，开始-\u003e编辑-\u003e替换，或者开始-\u003e编辑-\u003e查找-\u003e高级查找 缩进方式，左缩进，右缩进，首行缩进，悬挂缩进 标尺的作用，定位、对齐和缩进等。 小三角用来调整缩进（左缩进，右缩进，首行缩进），小方块用来设置制表位的对齐方式。 拖动标尺边界，可以设置页边距 在快速选择区三击，可选择整篇文章 ","date":"2022-06-21","objectID":"/kaobian-cs/:10:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"excel 一个 excel 文件最多有 255 个工作表 工作簿是指大的 excel 文档，工作表是指里面的 sheet1、sheet2 公式以等号开头 每个单元格最多可以容纳约 32000 个字符 ","date":"2022-06-21","objectID":"/kaobian-cs/:11:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"公式与函数 单元格引用 绝对引用和相对引用，列表或行标前面带$符时为绝对引用，不带时为相对引用 引用一个单元格，A1 引用运算符 引用一个单元格区域，A1:B3 引用多个单元格区域，(A1:B3,C1:D3) 引用两个单元格的相交区域，(A1:B3 C1:D3) 运算符优先级：- \u003e % \u003e ^ \u003e (*、/) \u003e (+、-) \u003e \u0026 \u003e 比较 ","date":"2022-06-21","objectID":"/kaobian-cs/:11:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"powerpoint 播放快捷键：f5 ","date":"2022-06-21","objectID":"/kaobian-cs/:12:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"模板 人们通常说的模板是指别人做好的 ppt 文件，我们拿到后可以在其基础上做修改 ppt 提供了和模板相关的两种功能，母版和主题 母版用来定义一些可复用的版式。（操作：视图-\u003e幻灯片母版） 主题比母版高级，每个主题里面都包含一套母版，还另外做了统一的配色、字体、效果等。主题做好后会导出成 thmx 文件（操作：设计-\u003e主题） 官方提供的模板，官方的模板是以 pot/potx 格式提供的，官方的模板可以直接在新建文件界面搜索和选择 ","date":"2022-06-21","objectID":"/kaobian-cs/:12:1","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"程序设计 结构化程序三种基本结构：顺序、分支、循环，goto 语句属于无条件跳转语句，属于非结构化程序 ","date":"2022-06-21","objectID":"/kaobian-cs/:13:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"c 程序基本结构 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cstring.h\u003e#include\u003cmath.h\u003e #define mydef 0 struct mystruct { int a; char *b; } int main() { return 0; } // 标准输入输出 int a; scanf(\"%d\",\u0026a); printf(\"%d\",a); // 按行 char * in = char[100]; char * out = \"123\"; char * res = gets(in); //返回字符串或NULL int res = puts(out); //返回长度或EOF //按字符 int res = getchar(); //返回字符或EOF int res = putchar(c);//返回字符或EOF // 文件操作 // 打开关闭文件 FILE * f = fopen(\"/data/input\",\"r\") //r读，w写，a追加 int status = fclose(f) // 读写字符 char * in = char[100]; char * out = \"123\"; char * res = fgets(in,10,f); //返回字符串或NULL int res = fputs(out,); //返回长度或EOF int res = fgetc(f); int res = fputc(c,f); // 读写块 char buffer[100]; char c[] = \"This is w3schools\"; int res = fread(buffer, strlen(c)+1,1,f) //参数：buffer，块大小，块个数，文件，返回读取长度 int res = fwrite(buffer, strlen(c)+1,1,f) //参数：buffer，块大小，块个数，文件，返回写入长度 //初始化结构体 struct mystruct mst = {1,NULL}; //数组 int a[5] = {2, 3, 4, 4, 7}; //指针 int *b = (int *)malloc(sizeof(int)*5); b = (int *)realloc(b, sizeof(int)*10); free(b) //字符串/内存操作 char *s1 = \"123\"; char *s2 = \"234\"; char *res = strcat(s1,s2); //s2拼接到s1的末尾 char *res = strncat(s1,s2,n); //把s2的前n个字符拼接到s1的末尾 int res = strcmp(s1,s2); //s1\u003es2，返回大于0，s1\u003cs2，返回小于0，s1=s2，返回等于0， int res = strncmp(s1,s2,n); //比较前n个字符 char *strcpy(char *dest, const char *src); char *strncpy(char *dest, const char *src, size_t n); int memcmp(const void *str1, const void *str2, size_t n) void *memcpy(void *dest, const void *src, size_t n) void *memmove(void *dest, const void *src, size_t n) void *memset(void *str, int c, size_t n) // math，操作数都是double b = exp(a) //e^x b = pow(x,y) //x^y b = sqrt(a) //平方根 b = log(a) //自然对数，基数为e b = log10(a) //基数为10 b = fabs(a) //绝对值 b = ceil(a) //向上取整 b = floor(a) //向下取整 b = sin/cos/tan(a) //三角函数 ","date":"2022-06-21","objectID":"/kaobian-cs/:14:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["考编"],"content":"java 程序基本结构 public class Hello{ public static void main(String []args){ System.out.println(\"Hello World\"); } } //import import java.util.Scanner; import java.lang.String; import java.lang.Integer; import java.lang.Double; import java.io.*; import java.io.FileWriter; import java.io.IOException; //标准输入输出 Scanner scan = new Scanner(System.in); if(scan.hasNext()){ //按单词输入 String str1 = scan.next(); } Scanner scan = new Scanner(System.in); if(scan.hasNextLine()){ //按行输入 String str2 = scan.nextLine(); } System.out.println(\"Hello World\"); //类型转换 String.valueOf(xxx) //万物转String //int和String互转 Integer.toString(xxx) //int、Integer转String Integer a = Integer(5) a.toString(xxx) //Integer转String Integer.valueOf(\"...\") //String转Integer Integer.valueOf(\"...\").intValue() //String转int Integer.parseInt(\"...\") //String转int //其他类型和String互转大同小异 //异常处理（捕获全部异常） try{}catch(Exception e){ System.out.println(\"Exception thrown :\" + e); } //序列化到文件 try{ FileOutputStream fileOut = new FileOutputStream(\"data/out\"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(e); out.close(); fileOut.close(); }catch(IOException e){ e.printStackTrace(); } //从文件反序列化 Employee e = null; try{ FileInputStream fileIn = new FileInputStream(\"/tmp/employee.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn); e = (Employee) in.readObject(); in.close(); fileIn.close(); }catch(IOException i){ i.printStackTrace(); return; }catch(ClassNotFoundException c){ c.printStackTrace(); return; } //读写文件 //写（FileWriter） try { FileWriter myWriter = new FileWriter(\"filename.txt\"); myWriter.write(\"Files in Java might be tricky, but it is fun enough!\"); myWriter.close(); } catch (IOException e) { e.printStackTrace(); } //读（Scanner） try { File myObj = new File(\"filename.txt\"); Scanner myReader = new Scanner(myObj); while (myReader.hasNextLine()) { String data = myReader.nextLine(); System.out.println(data); } myReader.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } //arraylist ArrayList\u003cInteger\u003e myNumbers = new ArrayList\u003cInteger\u003e(); myNumbers.add(33); myNumbers.remove(0); //按下标删 myNumbers.get(0); //按下标获取 myNumbers.size(); //获取大小 for(int i =0;i\u003cmyNumbers.size();++i){ myNumbers.get(i); } //hashmap HashMap\u003cInteger,String\u003e mymap = new HashMap\u003cInteger,String\u003e(); mymap.put(3,\"11\") mymap.get(3) mymap.remove(3) mymap.size() for (Map.Entry\u003cString, String\u003e entry : map.entrySet()) { String mapKey = entry.getKey(); String mapValue = entry.getValue(); System.out.println(mapKey + \"：\" + mapValue); } for (String key : map.keySet()) { System.out.println(key); } for (String value : map.values()) { System.out.println(value); } //String操作 String s2 = \"Hello\".substring(1, 4); // 开始和结束索引 String[] parts = str.split(\",\"); //切分 String res = String.join(\",\",parts); //拼接 s2.length(); //获取字符串长度 //math Math.abs(a) Math.max(a,b) Math.min(a,b) Math.ceil(a,b) Math.exp(a) Math.pow(a,b) Math.sqrt(a) Math.log(a) Math.log10(a) Math.sin/cos/tan(a) ","date":"2022-06-21","objectID":"/kaobian-cs/:15:0","tags":null,"title":"事业编计算机知识","uri":"/kaobian-cs/"},{"categories":["编程"],"content":"一、数字签名 数字签名的作用是保证数据的完整性和保密性 数据完整性通过对数据做摘要保证 数据的保密性通过对数据和摘要做公钥加密保证，接收人只能用发送人提供的公钥才能解密消息，用其他人提供的公钥无法解密消息 具体的交互流程是 发送人对消息做加密和摘要，生成数字签名和加密信息，并将签名和信息一起发送给接收人 接收人收到消息后，使用发送人的公钥校验数字签名，校验通过后，即可证明消息的完整性 接收人对消息进行解密，查看消息，对消息做出答复，并用发送人的公钥对答复加密，回复给发送人 ","date":"2022-06-18","objectID":"/digital-signatures-certificates/:1:0","tags":["信息安全"],"title":"数字签名和数字证书","uri":"/digital-signatures-certificates/"},{"categories":["编程"],"content":"二、数字证书 在使用数字签名的过程中存在一个问题，即接收人无法判断发送人的公钥是否可信，换言之，发送人提供的公钥有可能被篡改或伪造。数字证书就是为了解决公钥的可信性问题而被发明出来的。 具体的做法是，由一个权威的证书颁发机构（CA）使用它自己的公钥对发送人的公钥做一个数字签名，并将这个数字签名作为证书颁发给发送人，发送人给接收人发送消息时，将证书一并附上，由接收人去验证。CA会为其自己的公钥颁发一个根证书，提前提供给用户，用户从根证书中获取到CA的公钥，对CA颁发的证书进行验证。 简单来说，用户先从根证书中拿到CA的公钥，再利用CA的公钥从服务器证书中拿到服务器的公钥，然后再用服务器公钥和服务器通信。 ","date":"2022-06-18","objectID":"/digital-signatures-certificates/:2:0","tags":["信息安全"],"title":"数字签名和数字证书","uri":"/digital-signatures-certificates/"},{"categories":["编程"],"content":"三、https协议 ","date":"2022-06-18","objectID":"/digital-signatures-certificates/:3:0","tags":["信息安全"],"title":"数字签名和数字证书","uri":"/digital-signatures-certificates/"},{"categories":["编程"],"content":"https和http的区别 https在http的基础上增加了SSL/TLS协议，SSL/TLS依靠证书验证服务器身份，并对浏览器和服务器之间的通信进行加密 https使用443端口，http使用80端口 ","date":"2022-06-18","objectID":"/digital-signatures-certificates/:3:1","tags":["信息安全"],"title":"数字签名和数字证书","uri":"/digital-signatures-certificates/"},{"categories":["编程"],"content":"SSL/TLS SSL，Secure Sockets Layer TLS，Transport Layer Security SSL/TLS是对因特网上的数据传输进行身份验证和加密的协议，SSL/TLS是对ssl和tls的统称，tls更先进，更安全的ssl，正在逐渐取代ssl SSL/TLS有多个版本，使用How’s My SSL 工具查看你的浏览器使用的是哪个SSL/TLS版本 SSL/TLS的握手过程 客户端和服务器互相告知各自支持的SSL/TLS版本，加密算法和压缩算法 客户端验证服务器证书，并获得服务器公钥 双方通过协商生成会话秘钥（会话秘钥是一个对称秘钥，对称加密比公钥加密快） 双方使用会话秘钥进行加密通信 ","date":"2022-06-18","objectID":"/digital-signatures-certificates/:3:2","tags":["信息安全"],"title":"数字签名和数字证书","uri":"/digital-signatures-certificates/"},{"categories":["考编"],"content":"错题总结 数量关系 多 3 倍是指是原来的四倍 数学运算题，“每隔 19 天”指的是“每 20 天” 词语辨析： 乐不思蜀：在新环境中得到乐趣，不想回到原来的环境中 莫衷一是：大家没有一个统一的看法，没有定论 众说纷纭：大家各有各的说法，各有道理 鬼斧神工：形容人工，建筑雕塑艺术技巧高超，好像不是人工一样 巧夺天工：形容人工 藩篱：客观存在的屏障，中性词 樊篱：主观上、思想上的屏障，带贬义 包罗万象，形容内容丰富，不能形容气度与胸襟 左支右绌，力量不足，穷于应付 坚如磐石，形容坚定，不能改变，不可动摇，不是形容坚固 栉(zhi)风沐雨，形容经常在外面奔波劳碌 筚路蓝缕，形容创业艰苦 披荆斩棘，在前进的道路上清除障碍，克服困难 苦心孤诣，形容煞费苦心地钻研 不以为然，不认为别人是对的 不以为意，不在意 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:1:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"数推技巧 最常用的还是做差，幂次修正，和递推 递推（三个数居多，也有两个数和一个数）、两两分组、奇偶项、幂次修正（最大三次幂） 两两做差/和、商/积 分数通分 质数序列 四个数组成圆环（有中间的数凑中间的数，没有随缘） ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:2:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"数学计算公式 平均速度： 同一段路，两次以不同的速度走过，平均速度为 v=2s/(s/v1+s/v2) = 2v1v2/(v1+v2) 溶液问题： 浓度=溶质/溶液=溶质/（溶质+溶剂） 两溶液混合后溶质不变 钟表问题： 表盘 12 大格，每格 30 度 时针转速为 30°/小时、0.5°/分，分针转速为 6°/分。分针每分钟比时针快 5.5° 时针和分针一昼夜（24h）重合 22 次，垂直 44 次，180° 22 次 剪绳计数： 绳子的段数总是比切口数多 1 一段绳子对折 N 次，从中剪 M 刀，绳子被剪成（M*2^N+1）段 方阵问题： M*N 的实心方阵，外圈比内圈多 8 人 组合数： A(m,n) = n!/(m-n)! C(m,n) = n!/(m-n)!m! 环形排列： n 个人排成一圈，有A(n,n)/n种排法。（由于首尾相接的缘故，123456 和 612345 是等价的） n 个珍珠串成一条项链，有A(n,n)/2n种排法。（除了首尾相接以外，由于可以正反翻面的缘故，1234 和 4321 是等价的，即正序和倒序也是等价的） 摸球问题 从装有 n 种球的口袋中，至少要摸出(m-1)n+1 个球，才能保证其中有 m 个球是同一种球，假设每种球足够多。（最坏的情况下，前(m-1)n 次摸出 m-1 副球，再多模一个，无论如何也能有 m 个一样的 从装有 n 种球的口袋中，最多摸出(m-1)n 个球使得任意 m 个球不是同一种球，假设每种球足够多。（和上面的问题是一个道理） 经济利润问题 售价是实际出售价格 定价是期望价格 最大公约数 gcd(a,b) 辗转相除法，gcd(a,b) = gcd(b,a%b) 最小公倍数 lcm(a,b) lcm(a,b) = a*b/gcd(a,b) 余数计算 余同取余：x%7=1,x%6=1,x%5=1 =\u003e x=210n+1 和同加和：x%7=1,x%6=2,x%5=3 =\u003e x=210n+8 差同减差：x%7=3,x%6=2,x%5=1 =\u003e x=210n-4 数列求和 等差数列项数 = (末项-首项)/公差+1 等差数列求和 = (首项+末项)*项数/2 等差数列对称性：如果 m+n=i+j,那么 am+an=ai+aj 等比数列求和 = a1(1-q^n)/(1-q) N 支队伍比赛问题 淘汰赛（决出冠亚军），共比 N-1 场 淘汰赛（决出前四名），共比 N 场 单循环赛（任意两个队比一场），共比 C(2,N)场 双循环赛（任意两个队比两场），共比 A(2,N)场 过河爬井问题 M 个人过河，船上能拉 N 个人，需要 a 个人划船，则过河需要(M-a)/(N-a)次 M 米深的井，每天上爬 a 米，下落 b 米，则出井需要的天数为(M-a)/(a-b)+1 空瓶换酒问题 M 个空瓶换 N 瓶酒，x 个空瓶最多可以喝到 xN/(M-N)瓶酒。（默认可以借瓶换瓶） ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:3:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"速算技巧 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:4:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"求解对象 基期、现期、增长量、增长率 平均值、比重 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:4:1","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"选项差距 差距大： 四个选项首位均不同 首位相同，第二位的差大于首位 差距小： 存在首位相同的选项，且选项的第二位差小于等于首位。 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:4:2","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"运算技巧 直除 应用场景：多位数除法（三位数以上） 方法：分母保留 2 位或 3 位有效数字 选项差距大，四舍五入保留 2 位；选项差距小，四舍五入保留 3 位； 多位数求和 应用场景：123.4+567.8+901.2 方法：先对各个位求和，从百位求起，然后将各个位的求和结果错位相加 尾数求和 应用场景：多个多位数相加，选项精确到了最后一位并且尾数各不相同 方法：只对尾数求和 增长量计算-假设法 应用场景：现期 15048，同比增长率 20.5%，求现期和基期的差 方法：先假设一个基期（通常假设一个整数），求出增量；对余量，重复这个过程。适用于选项差距小的情况 增长量计算-百分数化简为分数 适用于选项差距大、增长率绝对值大于等于 5%的情况 $$ \\frac{1}{3}=0.333,\\frac{1}{6}=0.167,\\frac{1}{7}=0.143 $$ $$ \\frac{1}{8}=0.125,\\frac{1}{9}=0.111,\\frac{1}{11}=0.091 $$ $$ \\frac{1}{12}=0.083,\\frac{1}{13}=0.077,\\frac{1}{14}=0.071 $$ $$ \\frac{1}{15}=0.067,\\frac{1}{16}=0.0625,\\frac{1}{17}=0.059 $$ $$ \\frac{1}{18}=0.0555,\\frac{1}{19}=0.0526 $$ 增长量计算-基期近似 方法：用现期近似基期，然后乘以增长率得出增长量。适用于选项差距大、增长率绝对值小于 5%的情况 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:4:3","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"欣说言语笔记 做题原则： 理解为本，任何技巧都不能大过理解本身 注意做题节奏，不急不拖 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:5:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"片段阅读-选主旨、选标题 边读题干边勾画，提炼大意 选项一定要匹配中心思想 如果题目不严谨，选项择优，优先匹配核心，然后再匹配细节 需要区分全局重点还是局部重点 讨论的主体一定要明确 有时候无论如何都感觉到答案很玄学，这时不再是做题技巧的问题，而是理解的问题，遇到这种情况，不要纠结，尽可能排除更错误的选项，迅速结束该题 重点类型： 转折中心，重点在转折之后 因果中心，重点在引出的结论。 有时候选项会把结论以因果逻辑的形式表达出来，但是选项中有结论关键字，是可以选的。例如，“本文解释了…的原因” 一些总结词也属于因果词，例如，“总之”，“这意味着”，“这说明” 有时候就没有因果词，但上下文的意思是“A 导致了 B” 并列关系 显式：“同时”、“此外”、“另外”、“并且”、“一方面”、“另一方面”。分号分隔 隐式：没有分隔词 并列结构不分主次，不能片面，主旨是对两种情况的归纳 无中心，依靠提炼关键词和理解，合理利用下面的辅助方法 辅助方法 有转折中心，也有因果中心，选项里没有中心之后的重点，这时只能靠理解 “问题”-“分析问题”-“解决问题”是常见结构 A 推 B 句式，例如“只有 A，才有 B”（有时会省略“只有”），这时强调的是 A 的必要性，相应的句式有“A 是 B 的基础，前提，保障，途径，方法” 很多时候必要条件是以对策的形式出现的，引导词有“必须”、“需要”、“应该”、“应当”、“务必” 有时是“没有 A，就没有 B” 有时是“一旦/如果 A，后果很严重” 如果选项中出现了对策，要不要选：（1）如果文本里出现这个对策本身，可以选；（2）如果文本里出现对应的问题，可以选；（3）如果对策能解决问题，可以选；否则，不要选。 总分结构，文本剩余部分都是对中心句的解释 个人经验： 片段阅读题，稍微读得慢一点，做题时间就超过一分钟了，一定不能花太多时间精读，做题分三步 确定题型 快读阅读 一边阅读，一边利用技巧划分结构 一边阅读，一边概括大意 排除选项 牢记“找重点、提炼关键词”，所有技巧的目的都是这个，不能为了使用技巧偏离了初衷 可能有多个关键词，选项里得能体现出来。 有明确的中心结构时，关键字一定在中心句，就算前面说了一堆其他的，关键字也在中心句 易错：有时候前面论述了一堆，跟结论中的关键词关系不大，这种时候极容易选错，容易选择前面论述的东西，忽略结论中的关键字。例如，“量子力学巴拉巴拉…论述一堆，因此，这些基础研究成果巴拉巴拉”，这时关键字是“这些基础研究成果”，不是“量子力学” 一些观点句，可以通过它是不是作者的观点来判断它是否是重点句，例如它是引用别人的话 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:5:1","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"片段阅读-细节和归纳题 这类题重在对比，不太需要理解。选项和文本对比，选项和选项对比。 问题类型 “相符/不相符的是”、“正确/不正确的是”，考细节 “根据文字可以推出/可知”，考归纳 细节查找（查找原因、要素，查找目的、意义） 细节题 如果选项短，先看选项，然后放到文中定位 注意无中生有问题（比较关系、因果关系、主观臆断） 注意偷换要素问题（数量、时态、概念、概念范围、语气） 警惕绝对化表述 个人经验： 选最扯淡的那个选项或者最贴近文本的选项 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:5:2","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"语句表达-填句子 所填信息是“对上下文信息的重复”，根据上下文限定作答，切忌想当然 横线位置决定了句子的功能。 横线居中：承上启下。 横线居首位：总结文段，兼顾衔接句 个人经验： 一定注意不能脱离主题，不能擅自升华主题 很多时候，会出现多个选项感觉都能选，一定是有些选项只能承上，不能启下，或者反过来 有的时候，选择的关键还在于语法通不通，行文结构对不对，很多时候读得通顺也很重要 先看就近的句子，再看离得远的句子 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:5:3","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"语句表达-排序 不要根据首句在选项中的数量来排除 个人经验： 可以根据尾句排除 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:5:4","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"语句表达-推断下文 根据新话题推断下文（不一定是最后一句） 注意作者倾向、立场、情感偏向 上文有问题，下文要解决 上文提出观点+解释，下文主题还是这个观点 如果上文提出多个主体，已经说了一个，下文就要说另外的主体 个人经验： 一定注意不能脱离主题，不能擅自升华主题 上面的第三点，实际结构应该是“提出问题-分析问题-解决问题” 不要唯技巧，语感很重要 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:5:5","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"语句表达-逻辑填空 类似填句子 必须和语境匹配（有时可能不太合语感） 考察点 长相相近，语素不同，例如“繁琐”和“烦琐”，不是词错了，是就想这么考 表意相近，看程度轻重 感情倾向（褒、贬、中性） 口语、书面语 搭配：关系，例如动宾关系，修饰要适当 分析语境：最难判断的是并列关系，但是并列关系往往会有提示，不是在文本里，就是在选项里，出题人的意思是要参考已给出的一个词的意思选择另外一个。 识别：顿号、“和”、“与”、“以及” 两个句子句式一致 三个句式一致，不一定要在表面上完全一致，而且通常三个表达都不一样 注意有时候不一定是并列关系，而是递进关系或者其他关系，比如“并且”这个词 个人经验： 有时候，不通顺也得选，比如“中医药大有可为” ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:5:6","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"刘文超判断推理笔记 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:6:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"图形推理 元素组成相同——位置规律 平移 方向，步数 旋转、翻转 方向、角度 元素组成相似——样式规律 线条重复出现——加减同异 黑白运算（黑白色块数量不同时属于黑白运算） 元素组成不相同、不相似 属性（对称、曲直、开闭） 对称方向、数量 全曲、全直 全封闭、全开放 数量规律明显——数量规律（点、线、面、素、角） 点：只算交点、切点 线：直线不拐弯它就是一条直线，曲线没有折点它就是一条曲线 数量、平行、垂直 第一划和最后一划平行/垂直 笔画问题： （从一个点发射出奇数条线的点是奇点、端点和丁字形是奇点） 一笔画：线条之间联通、奇点数为 0 或 2 多笔画：笔画数=奇点数/2（奇点数一定是偶数个） 常见一笔画：日，好多个圆互相相交 常见多笔画：田 面数量：白的是面，黑的不是 元素：元素种类、元素个数、元素替换、部份数 部份数：出现粗线条、生活图形时，可以看部份数 角数量，只考内角 汉字常见考法：笔画数、线数量、面数、部份数 生活黑线条图形常见考法：部份数、面、属性（对称、开闭） 特殊规律：功能元素（点、箭头）、图形间关系（分离、相切、相交、包含） ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:6:1","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"类比推理 题型 A:B A:B:C A 对于()好比()对于 B 考点 语义关系（二次辨析：感情色彩、词语结构） 近义/反义 比喻、象征，例如“月亮：玉盘”、“松鹤：长寿” 逻辑关系 全同 矛盾和反对：矛盾是 A+B=全部，反对是 A+B!=全部但是 A 和 B 相互独立 包含：种属，组成 交叉 对应关系：原材料、工艺（物理/化学）、功能、属性、时间顺序、依据、因果、职业 语法 主谓 动宾 主宾 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:6:2","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"定义判断 选一个最符合或最不符合的答案 没有太好的方法 确定主体和客体 条件+结果 优先看概念句 多定义——问啥看啥 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:6:3","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"逻辑判断 翻译推理，最基础，最简单 前推后，如果 A 就 B，A-\u003eB，A 是 B 的充分条件，以下等价 只要，就 为了，一定/必须 所有，都 后推前，只有 A 才 B，B-\u003eA，A 是 B 的必要条件，以下等价 否…否… 除非…否则不… …是…的基础、假设、前提、关键、必要条件 且和或 或：否 1-\u003e推 1 组合排序，给出几组对象之间的关系 读一句题，排除一个答案（不通用） 推理起点：多次提到的对象（不是人） 涉及比较，使用符号 列表格（太慢了） 题干不确定时（例如题干中只有部分说法是真的），代入选项（太浪费时间了，遇到直接跳过） 日常结论（类似言语题），无逻辑词，问题是“能否推出？” 注意这类问题：逻辑错误、无中生有、扩大范围、绝对化表述、偷换概念等等问题 逻辑论证（演绎推理） 首先要找论点（别的不用看），看提问和选项，找关键词，找首尾句 加强型题型（“选择最不能加强结论的选项”这种问题也是加强型题型），以下是可以选的选项 在论点和论据之间搭桥（尤其是，能证明论点对论据的必要性的，或者论据对论点的充分性） 补充论据 削弱型题型（“最能质疑”、“最不能质疑”） 因果倒置型削弱（颠倒论证的因果关系，这种是很能削弱论证的） 另有他因型削弱 真假推理 找矛盾，矛盾必然一真一假；然后找反对关系； 矛盾关系主体要一致 四种矛盾关系 A\u0026B 的对立面是(!A||!B)，A||B 的对立面是（!A\u0026!B） A-\u003eB 的对立面是什么？A-\u003eB 等价于(!A||B)=true，而(!A||B)的对立面为(A\u0026\u0026!B)，例如，“如果王当教练，那么李当领队”，我说不同意，那么我的意思等价于“王当教练并且李不当领队”，这个逻辑看似很难理解，但是如果我们把上面的“如果…那么…”换成一种实证性表述，就会发现结论很符合知觉了，例如“如果有房子，那么必有地基”，我说不同意，那我的意思等价于“存在一种房子，并且这种房子没地基”，说白了，“我说不同意”这种题型是要给上面的推导关系找个反例出来 “所有人都…”的对立面是“有的人不…”，“有的人不…”包含“所有人都不” 两种反对关系 “所有都”和“所有都不”反对，但不能同真，必有一假 “有的是”和“有的不是”，但不能同假，必有一真 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:6:4","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"刘文超数量关系笔记 带入排除法 年龄问题 余数问题 多位数 不定方程 不会做的题 数字特性 奇偶特性，适用题型，知差求和、知和求差、2 倍类、平均分、不定方程 奇数+/-奇数=偶数、偶数+/-偶数=偶数、奇数+/-偶数=奇数 奇数 × 奇数=奇数、奇数 × 偶数=偶数、偶数 × 偶数=偶数 整数特性： 一个数能被 4 或 25 整除，末两位能被 4 或 25 整除就行 一个数能被 8 或 125 整除，末三位能被 8 或 125 整除就行 一个数能被 3 或 9 整除，各位数字之和能被 3 或 9 整除就行 倍数特性，适用题型，倍数、百分数、分数、比例、分组 普通倍数（y=7x+2） 因子倍数（y=abc） 比例倍数（男女比例为 7:4） 方程法，优先设所求量、设小不设大、设中间变量 a/b = c/d = (a+c)/(b+d) = (a-c)/(b-d) 不定方程 x+2y=4，快速解法 奇偶特性 因子倍数（有时可以推出其中某一项的倍数，例如 11x+7y=121，7y 一定是 11 的倍数） 尾数法，例如 3x+10y=41，10y 的尾数一定是 0，所以要求 3x 的尾数一定是 1 代入法 赋 0 法，例如题目要求 x+y+z 的值，这时可以给 x 赋零 工程问题 工作量 = 效率 × 时间 题型 给定时间型，a 需要干 5 天，b 需要干 7 天，两人一起干需要多久 给工作量赋值（天数的公倍数，不一定最小公倍数） 效率制约型，给定工作效率之比、效率提高 20%、给定工人数量、给出部分工程量的时间比 给效率赋值 行程问题 路程 = 速度 × 时间 相对速度型，流水行船，相遇追及 环形跑道问题，相遇和套圈（追及） 等距离平均速度，2v1v2/(v1+v2) 上下坡 往返 两端相遇，相遇第一次共走 S，第二次 3S，第 N 次(2N-1)S 排列组合问题 捆绑法-相邻问题，捆绑在一起的算一个单位，捆绑内部又有排列组合 插空法-不相邻问题，四棵柏树插入 7 棵完全相同的松树之间，柏树不能相邻 插板法-至少分一个，7 个相同的橘子分给四个小朋友，每人至少分一个，7 个橘子有 6 个插板位置，要插三个插板，一个位置只能插一个插板 错位排列，每个人都不能选自己的那道菜，D2=1，D3=2，D4=9，D5=44 概率问题 逆向计算（1-不满足条件的概率） n 个人随机分组，每组 m 个人，两个人分到同一组的概率为(m-1)/(n-1)，可以这么理解，其中一个选好位置以后，另外一个人选到同组位置的概率 经济利润问题 “定价”不是“售价” 利润率 = 利润/成本 “利润率下降 10 个百分点”是指“利润率-10%”，因为利润率本来就是个百分数，而不是利润率*0.9 列表法，把成本、售价、利润等列成表 分段计费，画数轴 最大值问题，当 a+b=n 且 a 和 b 相等时，ab 为最大值，反过来，当ab=n且a和b相等时，a+b为最小值。 最值问题 最不利构造，“至少摸出几个球，才能保证一定摸出一个白球” 最不利值+1 数列构造，5 个人分 100 个苹果，分的最少的人最多能分几个苹果 多集合反向构造，至少有多少人以上活动都不喜欢 容斥原理 两集合，公式法，画图法 A∪B = A+B-A∩B 三集合 A∪B∪C = A+B+C-A∩B-A∩C-B∩C+A∩B∩C A∪B∪C = A+B+C-只满足两个条件的-2*满足三个条件的 几何问题 弧长=nR，扇形面积=弧长×r/2，球面积=4piR^2，球体积=(4/3)piR^3，圆锥/棱锥体积=底面积×高/3 长度一定，面积最大的是圆，其次是正n边形，正方形比长方形面积大 30度角的直角三角形，三条边分别是1、根号3、2 相似三角形，面积之比=边长之比^2 一个图形，边长变为原来的n倍，面积是原来的n^2，体积是原来的n^3 几何构造 年龄问题 方程法、带入排除法 溶液问题 浓度=溶质重量/总重量 牛吃草 一边吃，一边长；一边放水，一边注水； 循环周期问题 a % b = n，最后一天可以视为n 星期日期问题 四年一闰，四百年一闰，普通百年闰不了 闰年366天 比赛问题 淘汰赛，每场比赛淘汰一队，每轮比赛淘汰一半。奇数个队比赛，就会有一队轮空，直接晋级 单循环赛，每支队伍和其他队伍比一场，比赛场次C(N,2) 单循环赛可以通过画图解决 双循环赛，每支队伍和其他队伍比两场，比赛场次A(N,2) 统筹优化问题（规划最优方案） 枚举法、逻辑推断 钟表问题，追及问题 时针和分钟重合几次 = 分针追上时针的次数，时针一天走2圈，分针一天走24圈，所以，一天重合22次，垂直44次，分针速度为6度/min，时针速度为0.5度/min 植树问题 线上植树，棵数 = 长度/间隔+1 环上植树，棵数 = 长度/间隔 剪绳问题，剪N刀，能得到N+1段 函数问题 数列问题 平均数 等差数列通项公式、求和，和= 中位数×项数，和 = 平均数×项数 天平问题 称几次问题，直接选最小 称N次，可以从3^N个物品中选出有差异的瑕疵品（每次把物品分成三份，就可以确定瑕疵品在哪一堆，按这个方法递归处理），求log(3,N)、向上取整即可 空瓶换酒问题（默认可以借瓶换瓶） 可以这么理解，啤酒= 瓶+酒，n个空瓶换一个啤酒就等同于n-1个空瓶换一个不带瓶的酒 方阵问题 相邻两层人数差8 拿牌问题 一副牌，两个人轮流拿牌，谁能拿到最后一张谁赢，怎么拿 假设每次可以拿1、2、3、4张牌，剩五张牌的时候，A先拿，B就一定能赢，所以只要牌数是5的倍数并且A先拿B就一定能赢 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:7:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["考编"],"content":"刘文超资料分析笔记 统计术语 ","date":"2022-06-15","objectID":"/kaobian-xingce-tips/:8:0","tags":["行测"],"title":"行测技巧","uri":"/kaobian-xingce-tips/"},{"categories":["编程"],"content":"unix时间戳 unix时间戳是相对于UTC时间\"1970年1月1日 00:00:00\"所经过的秒数。由于是相对于UTC时间，各时区的计算机在同一时刻获取到的时间戳都是相同的。 unix时间戳不存在时区问题，因此在传递时间参数的时候，传时间戳明显比传格式化的时间字符串更方便，更明确 ","date":"2022-06-08","objectID":"/time/:1:0","tags":null,"title":"计算机中的时间","uri":"/time/"},{"categories":["编程"],"content":"2038年问题 相当一部分unix操作系统使用32位有符号整型保存时间戳，因此时间戳的值最大也只有2147483647，换算成UTC时间为\"2038-01-19 03:14:07\"，一旦超过这个时间，这些系统的时间戳就会变成一个无效值，可能会导致程序出错，这就是2038年问题。 这有点类似于千年虫问题，2000年以前，很多计算机程序由于程序设计有问题，在时间超过2000年1月1日零点之后，程序会因为无法正确处理时间导致处理出错或程序崩溃（例如有些程序只用年份的后两位表示年份，导致2000年会被误认为是1900年） ","date":"2022-06-08","objectID":"/time/:2:0","tags":null,"title":"计算机中的时间","uri":"/time/"},{"categories":["编程"],"content":"参考《Go 程序设计语言》 看本文前最好先看 google 的a tour of go ","date":"2022-04-26","objectID":"/go-gopl/:0:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"一、程序结构 go 程序使用驼峰式命名风格 零值，变量的初始值。数字是 0，字符串是\"\"，布尔值是 false，接口（interface）和引用类型（slice、指针、map、通道、函数）是 nil，数组和结构体的零值是其所有元素或成员的零值 注意，零值也是有类型的，nil 也是 短变量声明，a,b := f()，a 和 b 中至少有一个得是新变量，不能全是已经声明的变量 一个例外，如果 a,b 是在外层作用域声明的，:=会将它们声明为新变量 指针。函数返回局部变量的地址是安全的（见 6.变量的生命周期） new 函数，new 函数创建一个新值并返回其地址 变量的生命周期通过其是否可达确定（变量可以在其初次声明的作用域之外存活），编译器根据变量生命周期确定变量在栈上还是堆上分配，而不是根据声明变量的时候使用的是 var 还是 new 多重赋值，例如a,b := 1,\"xxx\"或x,y = y,x，后者用来交换变量的值 类型转换，var a T = T(b)，每个类型都会提供T(x)将 x 的值转换为 T（前提是允许这种转换） 导出的标识符才能在包外被访问到，导出的标识符以大写字母开头 包变量初始化，从初始化包级别变量开始，优先按照依赖顺序初始化变量，然后按照声明顺序初始化变量 init 函数，可以有任意个，在程序启动时按照声明顺序自动执行 包的初始化按导入顺序进行，依赖顺序优先（类似包级别变量初始化） ","date":"2022-04-26","objectID":"/go-gopl/:1:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"二、基本数据 ","date":"2022-04-26","objectID":"/go-gopl/:2:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"2.1 整型 int8、int16、int32、int64、uint8、uint16、uint32、uint64 int 和 uint，在不同平台上大小不同（通常是 32 位或 64 位） rune，等价于 int32，表示一个 unicode 码点 byte，等价于 uint8，表示一个原始的字节 uintptr，可以存放一个指针，用于底层编程 golang 中%运算结果的正负号总是和被除数一致（取余，不是取模） 位运算。\u0026是与运算（AND），|是或运算（OR），^是异或运算和非运算（XOR，NOT），\u0026^是与非运算（AND NOT），\u003c\u003c是左移，\u003e\u003e是右移 1 和 a 做异或等价于对 a 取反，即 1^a = ^a（这里的 1 和 a 是单独的一位） 与非运算的作用是按右操作数的位分布清空左操作数中的对应位 右移操作\u003e\u003e 有符号数左移是逻辑移位，符号位参与移位，低位补 0 有符号数右移是算术移位按符号位填补空位（因为移的是补码，补码补 1 就等于原码补 0） 无符号数都是逻辑移位 右移操作x\u003e\u003en等价于x/2^n，向下取整（朝负无穷方向取整，例如-5»1 结果为-3） ","date":"2022-04-26","objectID":"/go-gopl/:2:1","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"2.2 浮点型 两种浮点型，float32 和 float64 math 包给出了浮点型的极限值，例如math.MaxFloat32 特殊值：正无穷、负无穷、无意义（+Inf、-Inf、NaN）。超出极限值的数和除以零的商归为正负无穷，0/0 或 sqrt(-1)为无意义 ","date":"2022-04-26","objectID":"/go-gopl/:2:2","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"2.3 复数 两种复数，complex64，complex128 写法：3.14i、1+2i 可以使用==和!=判断是否等值 ","date":"2022-04-26","objectID":"/go-gopl/:2:3","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"2.4 布尔 逻辑运算的短路行为，如果运算符左边的操作数能直接确定最终结果，则右边的操作数不会计算在内 \u0026\u0026比||优先级高，助记技巧：\u0026\u0026是逻辑乘法，||是逻辑加法 ","date":"2022-04-26","objectID":"/go-gopl/:2:4","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"2.5 字符串 len 函数返回的是字节数，不是字符数 生成子串操作s[i:j]取的是字节，不是字符。 下标访问操作s[i]访问的也是第 i 个字节，不是字符 range 循环i,r := range \"xxx\"中的 i 表示字节序号，r 是字符（rune） 字符串可以通过==、\u003c等比较运算符比较，比较运算按字节进行，结果服从其字典序排序 字符串值无法改变（字符串值所包含的字节序列永不可变），只能将一个新字符串赋值给字符串变量（例如，s+=\"xxx\"只是将+=运算新生成的字符串赋值给了 s，并没有改变 s 原有的字符串值）。这么设计的好处是： 两个字符串变量能够安全地共用同一段底层内存 字符串拷贝的开销小 字符串字面量 转义。除了常见的'\\n'等转义字符以外，'\\xhh'用 16 进制数hh表示这个字节，'\\ooo'用八进制数ooo表示这个字节，这两者都表示单字节 原生字符串字面量用反引号`...`书写。原生字符串中转义不起作用，可以包含换行，字符串内容和书写内容完全一致。 utf-8 utf-8 是 go 的默认编码 unicode 字符有两种表示形式，'\\uhhhh'表示 16 位码点，'\\Uhhhhhhhh'表示 32 位码点，区别是小写的 u 和大写的 U 以下字符串是等价的，注意：直接用 16 进制转义（\\x）书写的字符串是\"世界\"经 utf-8 编码后的实际字节，而\\u 和\\U 后面跟的是 unicode 码点，并不是实际的 utf-8 字节 \"世界\" \"\\xe4\\xb8\\x96\\xe7\\x95\\x8c\" \"\\u4e16\\u754c\" \"\\U00004e16\\U0000754c\" utf-8 编码规则（只有\"xxx\"部分才是 unicode 码点信息） 0xxxxxxx 110xxxxx 10xxxxxx 1110xxxx 10xxxxxx 10xxxxxx 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 使用函数utf8.RuneCountInString(s)计算字符串中的字符数量 utf-8 解码器在遇到一个不合理的字节时，会用一个专门的 unicode 符号\\uFFFD作为替换 byte 和 rune 的区别，rune 保存的是 unicode 码点，并不是 utf-8 编码后的字节，因此，字符串转换为[]rune之后，使用fmt.Printf(\"%x\",s)输出的结果并不一样 string、[]byte、[]rune之间可以相互转换，byte、rune可以转换为 string 字面量'A'是 rune 类型 四个标准包：strings、bytes、strconv、unicode strings 包提供了字符串操作函数 bytes 包提供了字节 slice 操作函数、可变字符串类型 bytes.Buffer strconv 包主要用于 string 和其他类型的转换 unicode 包用于判别文字符号值 ","date":"2022-04-26","objectID":"/go-gopl/:2:5","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"2.6 常量 常量是在编译阶段确定值的数据类型，因此常量可以出现在涉及到类型声明的地方（例如数组长度） 常量生成器 iota，用于创建一系列连续的常量值，从 0 开始取值，逐项加 1。iota 可以用在表达式里。 无类型常量，无类型常量可以有比基本类型更高的精度，至少 256 位（可以超过基本类型的最值） ","date":"2022-04-26","objectID":"/go-gopl/:2:6","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"三、复合数据类型 数组、slice、map、结构体 ","date":"2022-04-26","objectID":"/go-gopl/:3:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"3.1 数组 var a [3]int = [3]int{1,2,3}，也可以a := [...]int{1,2,3} 使用len(a)获取数组长度 初始化时可以同时指定索引，例如a := [...]string{2:\"hello\",3:\"world\"} 如果数组元素类型可比较，则数组也是可比较的，只能用==和!= 传数组参数时不是传引用，而是值传递，拷贝一份副本 数组长度不可变 ","date":"2022-04-26","objectID":"/go-gopl/:3:1","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"3.2 slice slice 是一种可变长度的序列。slice 是一种轻量的数据结构，底层是个数组。 slice 有三个属性，指针、长度和容量，长度是指 slice 的元素个数，长度小于等于容量。容量是从起始元素到底层数组的最后一个元素见元素的个数。使用len和cap获取长度和容量。 一个底层数组可以对应多个 slice，slice 的范围可以相互重叠。 slice 之间无法比较，可以用 bytes.Equal 比较两个字节 slice slice 值为 nil 时，长度和容量都为 0，也有不为 nil 但是长度和容量都是 0 的 slice，例如[]int{}、make([]int,3)[3:] make([]T,len)、make([]T,len,cap) append 可以用来追加元素。append 可能会引起底层数据扩容，也可能不会，因此每次调用 append 都必须更新 slice。 小知识，func(y ...int)，...代表 y 接受一个可变长度的参数列表 ","date":"2022-04-26","objectID":"/go-gopl/:3:2","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"3.3 map a := map[string]int{\"hello\":1,\"world\":5,} 创建空 map：make(map[K]V)、map[K]V{} 通过下标的方式插入和访问，使用 delete 移除元素。即使 key 不存在，这些操作也是安全的，访问一个不存在的键时，其值为零值。 map 中元素的迭代顺序不固定 小知识，使用 range 迭代时可以使用空白标识符_忽略一个变量 判断一个 key 是否存在，age,ok := a[xxx] key 的类型必须是能用==比较的类型，所以 key 不能是 slice 可以通过将 slice 映射成一个字符串来解决，例如fmt.Sprintf(\"%q\",[]int{1,2,3})，谓词 q 是将一个值转换为对应的字符形式的字面值 ","date":"2022-04-26","objectID":"/go-gopl/:3:3","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"3.4 结构体 点号既可以用在结构体上，也可以用在结构体指针上 成员首字母大写说明变量可导出 成员变量的顺序对结构体同一性很重要 结构体的零值由结构体成员的零值组成 没有任何成员的结构体被称为空结构体，struct{}，没有长度 如果结构体所有成员都能比较，那么结构体就可以比较（使用==或!=） 匿名成员 如果一个成员是结构体，且不带名称，则为匿名成员 可以直接访问匿名结构体的成员，而不用经过匿名结构体 但初始化时必须把所有中间成员都列出来 成员重名问题，如果匿名成员内部的一个成员和外部的一个成员重名了，访问时访问的是外部成员。如果两个匿名成员之间有成员重名了，则不允许直接访问重名成员，必须要指定中间成员 ","date":"2022-04-26","objectID":"/go-gopl/:3:4","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"3.5 其他 json data,err := json.Marshal(xxx)，Marshal 生成一个字节 slice。 json.MarshalIndent()可以生成一个格式化的 json 字符串。 err := json.Unmarshal(data,\u0026xxx)，Marshal 的逆操作 结构体只有导出的成员才能被 Marshal，json 字段名称默认为成员名（区分大小写） 可以用成员标签定义字段名，例如 type a struct{ Year int `json:\"released\"` } （成员标签由一组空格分割的 key:“value\"组成） 模板（实现格式和代码彻底分离） 模板是一个字符串 一个{{...}}称为操作，可以输出值、选择结构体成员、调用函数、提供控制逻辑、实例化其他模板等 点号'.'表示当前值，最开始表示模板的输入参数 '|'将前一个操作的结果当作下一个操作的输入 将模板定义为一个字符串或文件、初始化时解析模板（并指定自定义函数）、运行时执行模板（提供输入输出） html/template 包会自动对 html 元字符转义，text/template 包不会，一定要用对包。（可以将输入数据指定为template.HTML类型不让 html/template 自动转义，也就是说，template.HTML类型会被看做是 html 数据，而不是纯文本） ","date":"2022-04-26","objectID":"/go-gopl/:3:5","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"四、函数 可以对函数返回值命名，有命名的返回值可以不写在 return 语句里（但是这么做会降低代码可读性）。 错误处理策略 出错后应当能提供一个错误链 错误消息首字母不应该被大写，而且尽量避免换行（方便使用 grep 这样的工具找错误）- 重试 + 超时 匿名函数 可以用来实现闭包 可以在函数内部定义函数，例如 d := func() int { var x int return x * x } fmt.Println(d()) 当匿名函数需要递归时，必须先按照上面这样把函数赋值给一个变量 捕获变量时要注意，如果捕获的是迭代变量，迭代变量是会不断更新的！ 变长函数 在参数列表最后的类型名称之前使用省略号\"...\"，例如func sum(vals ... int) int{...} 如何调用变长函数： sum(1,2,3) //或 values := []int{1,2,3} sum(values...) 延迟函数调用，defer panic，panic 发生时，正常程序会终止执行，goroutine 会执行所有 defer 函数，程序会异常退出并留下日志消息 可以手动触发 panic，例如panic(fmt.Sprint(\"xxx\")) defer 函数以倒序执行，从调用栈最外层的函数开始，一直到 main panic 消息输出到标准错误流，包含调用栈信息 runtime 包提供了获取调用栈的方法，例如 var buf [4096]byte n := runtime.Stack(buf[:],false) os.Stdout.Write(buf[:n]) 从 panic 中恢复，如果在发生 panic 的函数的 defer 语句中调用 recover 函数，panic 发生时程序就不会异常退出，而是将 panic 消息作为 recover 的返回值，如果没有 panic，recover 就返回 nil（可以在 defer 函数中修改函数返回值！），例如 func Parse() err error { defer func(){ if p := recover(); p!=nil{ err = fmt.Errorf(\"%v\",p) //可以在recover时修改函数返回值 } }() } 处理 panic 的一般原则是，不应该去恢复从另一个包发生的 panic，也不应该去恢复不是你维护的代码发生的 panic 有选择性地处理 panic（但还是强调，预期之内的错误不应该通过 panic 来处理） type bailout struct{} ... panic(bailout{}) //在某个地方发生了panic ... defer func() { switch p := recover(); p { case nil: // no panic case bailout{}: // \"expected\" panic err = fmt.Errorf(\"multiple title elements\") default: panic(p) // unexpected panic; carry on panicking } }() ","date":"2022-04-26","objectID":"/go-gopl/:4:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"五、方法 可以将一个方法绑定到一个类型上，例如func (p Point) Distance(a int) int，参数 p 被称为方法的接收者。 go 可以将方法绑定到任何类型上，包括切片类型、甚至是函数类型。 接收者可以是指针类型，但为了避免混淆，不允许绑定本身是指针类型的类型，例如 type P *int func (p P) f(){...} //不允许这样 接收者是指针类型时，可以使用变量本身调用方法，编译器会对变量隐式转换为指针。反过来也是一样的。 设计原则是，同一个类型的方法，接收者要么都是指针类型，要么都是值类型 注意，指针类型和对应的非指针类型是两种类型，只是在调方法时编译器会做隐式转换。 nil 也是合法的接收者（但是要在代码中对 nil 做专门的处理） 结构体嵌套匿名结构体，例如以下嵌套 type Point struct{ X,Y float } type ColorPoint struct{ Point Color color.RGBA } 可以直接通过 ColorPoint 调用 Point 的方法 可以创建一个方法变量，不用提供接收者就能调方法，例如 dis := p.Distance //方法变量 dis(q) 可以创建一个方法表达式，调用时将接收者作为第一个参数，例如 dis := Point.Distance //方法表达式 dis(p, q) fmt 默认调用 String 方法输出类型的值，因此，如果想自定义类型的格式化，可以给类型自定义 String 方法（注意，必须是为值类型定义 String 方法，而不是指针类型） go 封装的单元是包而不是类型，结构体内的字段不管导没导出，对包内的所有代码都是可见的 注意，type关键字并不是定义了一个别名，而是定义了一种新类型，例如，type Newint int定义了一种新类型Newint，绑定到Newint上的方法并不会绑定到int上 ","date":"2022-04-26","objectID":"/go-gopl/:5:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"六、接口 接口是一种抽象类型，里面都是方法，没有数据。 接口可以嵌套，和嵌套匿名结构体类似，嵌套接口时只需要提供一个接口名，可以直接访问嵌套接口的方法。 和结构体嵌套不同，接口嵌套和直接将嵌套接口的方法列出效果是一样的，方法定义的顺序也无所谓。 如果一个类型实现了一个接口的所有方法，那么这个类型实现了这个接口。 当一个类型实现了接口时，该类型才能赋值给接口 T和*T是两个类型，用T实现了一个接口，并不能认为*T也实现了。 空接口类型interface{}可以用来代表任意类型 接口例子 io.writer接口，fmt.Fprintf的第一个参数是io.writer类型 fmt.Printf 和 fmt.Sprintf 都是对 fmt.Fprintf 的封装。 fmt.Printf提供的是*os.File类型（os.Stdout），fmt.Sprintf提供的是*bytes.Buffer。 fmt.Stringer接口，这个接口有一个方法String() string，可以让一个类型自定义输出自己的方法。 flag.Value接口，用于表示一个命令行参数类型，同样有String() string方法。 sort.Interface接口，用于排序。 http.Handler接口，一个http.Handler就是一个 web 接口，可以用ServeMux将多个 handler 组合起来。 web 服务器每次都会用一个新的 goroutine 来调用处理函数，因此处理函数要注意并发问题 error接口，go 预先定义了一些实现了 error 接口的类型，例如*errorString、Errno 对于一个接口变量来说，它有两个类型，静态类型和动态类型，静态类型就是这个接口类型，动态类型是它的实际类型 接口类型的零值是 nil，对于一个 nil 接口，它的动态类型和动态值都是 nil，静态类型还是接口类型 接口值可以使用==和!=比较，当接口值动态类型和动态值都相等时两个接口值相等 如果动态类型不可比较，比较时会 panic 注意区分接口值为 nil 和接口动态值为 nil，容易引起 bug 类型断言，x.(T) 把接口值持有的具体类型T的值提取出来 或者把接口转换为另外一个接口，保留接口的动态类型和动态值（前提是动态类型实现了要转换的接口） 如果接口A是接口B的子集，接口B可以直接赋值给接口A，不需要类型断言，反过来不行 操作数为空接口值时类型断言失败 可以获取类型断言的结果，f,ok := x.(T)，类型断言失败，ok为false，可以利用这个来检查接口是否能转换成一个具体类型或另外一个接口类型 可以使用类型分支来简化一长串类型断言，例如 switch x.(type) { case nil: case int: case bool: default: } //扩展写法，在这种写法中，x被赋予的是接口的动态值而不是类型，可以把这个值拿到case块中去使用 switch x:=x.(type) { case nil: case int: case bool: default: } ","date":"2022-04-26","objectID":"/go-gopl/:6:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"七、协程 主要是goroutine和channel 程序启动时只有一个协程，即main函数所在的协程，称为主协程 启动一个协程，go f() main函数返回时，所有协程终止 channel用于协程间通信。channel有类型，例如chan int是int类型的channel。同种类型的channel可以使用==比较，这时如果它们的引用相同，结果为真，否则为假。 channel操作 创建channel，ch := make(chan int) 把x发送给channel ch，ch \u003c- x 从channel ch中接受数据并赋值给x，x := \u003c- ch 接受并丢弃结果，\u003c- ch 关闭channel，close(ch) 创建channel时可以指定容量，例如ch := make(chan int,3)，不指定容量时容量默认为0，创建出来的叫无缓冲通道 无缓冲通道上的发送操作会阻塞，直到消息被接收，发送协程才会继续执行。反过来，接收操作也会阻塞，直到有协程向channel发送一个消息 换句话说，无缓冲通道会将发送和接收协程同步化，因此无缓冲通道又称为同步通道 通道被关闭后，能收不能发 向关闭的通道发数据会panic 通道被关闭后，未接收完的数据会被继续接收，然后还能继续接收数据，只不过接收到的是零值 x, ok := \u003c- ch，当通道被关闭且数据被接受完后，ok的值为false 也可以采用直接在通道上迭代的形式，通道关闭并且数据全部接收完后退出循环 for x := range ch { ... } close操作不是必须的，只是一种同步手段而已（不像文件，打开后一定要关闭） 单向通道，类型chan \u003c- int只能发送，类型\u003c- chan int只能接收 可以用在函数参数类型上，让参数的用途更清晰 双向通道可以转换为单向的，反过来不行 缓冲通道 缓冲通道满了以后，发送操作会阻塞 使用cap函数获取通道容量 使用len函数获取通道内的数据个数 sync.WaitGroup，有时候创建的协程数量不固定，可以用它来对协程计数，它是并发安全的，下面是例子 r := make(chan int) var wg sync.WaitGroup //主协程，从一个channel获取数据处理，因此事先不知道到底要创建多少协程 for m := range ch { wg.Add(1) //创建协程前计数+1 go func(m string){ defer wg.Done() //在defer中对计数-1，确保一定能-1 r \u003c- 1 }(m) } //等待协程结束必须单独起一个协程，如果把等待操作放在主协程，放在下面这个循环之前，由于channel r是一个无缓冲channel，channel中的数据得不到处理，会导致所有协程都结束不了，如果放在循环后面，由于没人关闭channel r，循环结束不了，所以执行不到等待操作。（由于我们事先不知道到底有多少协程，因此也没办法使用缓冲channel） go func(){ wg.Wait() //等待所有协程结束 close(r) }() total := 0 //等r被关闭后才能结束循环 for i := range r { total += i } 可以利用缓冲通道限制并发数，例如 //设定并发数为20 var tokens = make(chan struct{}, 20) //获取一个token token \u003c- struct{}{} //协程处理... //处理完成后释放token \u003c- token select多路复用（注意不是switch），如下所示，每个case指定一次通道的接收或发送操作，select一次执行一个case，如果同时满足多个case，select随机选择一个 select { case \u003c- ch1: case x := \u003c-ch2: case ch3 \u003c- y: default: } 当我们不想在一个通道还没准备好的情况下被阻塞时，可以使用select多路复用 nil通道 在nil通道上收发是合法的，只是会永远阻塞 select中的nil通道永远不会被选择 小知识：go中的标签不光可以用于goto语句 可以让break跳出好几层，例如 loop: for{ select{ case _,ok := \u003c- ch : if !ok { break loop } } } continue同理，可以跳出多层 关闭通道操作可以作为一种广播机制，创建一个通道，不往里面发送任何数据，只要一关闭通道，所有监听这个通道的协程都会接收到一个零值，它们就知道通道被关闭了 goroutine调式技巧，执行一个panic调用，运行时将转储程序中所有goroutine的栈 总结一下，实现goroutine之间的同步可以采用以下方式： 使用channel发送消息 利用channel关闭实现广播机制 利用sync.WaitGroup对goroutine计数 利用缓冲channel实现一个计数信号量，来限制并发数 容量为1的channel被称为二进制信号量 利用select同时处理多个通道的读写操作 ","date":"2022-04-26","objectID":"/go-gopl/:7:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"八、并发时如何共享变量 竞态，竞态是指并发导致对数据的操作出现冲突的情况。 如何避免竞态（2、3是两种重要方案） 并发前把变量初始化好，并发期间不修改变量 避免多个goroutine访问同一个变量，（go箴言，不要通过共享内存来通信，应该通过通信来共享内存）。一种方法是让一个goroutine代理一个共享变量的操作，其他goroutine通过通道来对这个变量进行操作，这个代理goroutine被称作监控goroutine。 使用互斥机制 互斥锁sync.Mutex 有一种代替的办法是使用一个容量为1的channel作为二进制信号量，把对共享变量的并发访问数限制到1 mutex的用法 var mu sync.Mutex mu.Lock() //...临界区域 mu.UnLock() 为了确保释放锁，unlock操作经常放在defer里 读写锁sync.RWMutex，读锁RLock()、RUnlock()，读写锁Lock()、Unlock() 对一个变量，如果写操作加了锁，那么读操作也应该加锁，原因有两点 防止读操作插入到写操作序列中 现代cpu各个核心有各自独立的缓存，通道通信和互斥量操作等同步原语会导致处理器把积累的写操作刷回到内存，保证操作结果对运行在其他核心的goroutine可见。但是如果不使用同步原语，就有可能发生共享变量在各个核心上的缓存不一致的问题 sync.Once，是一个针对一次性初始化问题的解决方案 一次性初始化问题，实际开发中经常会遇到这样的场景，访问一个共享变量前要先去判断这个变量有没有初始化，如果没有，要先将其初始化然后再访问，这是并发不安全的，用法： var loadonce sync.Once loadonce.Do(initfunc) //initfunc用于初始化变量 //...访问操作 sync.Once内部包含一个互斥量和一个bool变量，bool变量用于标记共享变量是否已完成初始化 竞态检测器 用于分析程序是否存在竞态 在go build、go run、go test命令后面加上-race参数即可 竞态检测器会记录所有对共享变量的访问，会记录所有同步操作 竞态检测器只能检查出运行时发生的竞态，检查不出来没发生的竞态 ","date":"2022-04-26","objectID":"/go-gopl/:8:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"九、goroutine和OS线程 ","date":"2022-04-26","objectID":"/go-gopl/:9:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"9.1 栈 每个OS线程都有一个固定大小的栈空间（通常为2MB），这个栈空间对goroutine来说太大了（go中一次创建十万个goroutine也是常见的），但是对很多递归深度比较深的函数又太小了 goroutine也有栈，但是大小不固定。goroutine刚创建出来时栈很小（典型情况只有2KB），并且可以按需扩大和缩小，最大限制甚至可以达到1GB ","date":"2022-04-26","objectID":"/go-gopl/:9:1","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"9.2 调度 OS线程由操作系统内核来调度，线程切换需要完整的上下文切换，这个操作很耗时。 goroutine由go runtime调度，goroutine运行在线程上，是一种m:n的调度。goroutine调度在用户态完成，开销很小。 Go调度器使用GOMAXPROCS参数确定需要使用多少OS线程，默认是cpu核数 ","date":"2022-04-26","objectID":"/go-gopl/:9:2","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"9.3 标识 线程都有标识，goroutine没有。（不鼓励threadlocal这种东西） ","date":"2022-04-26","objectID":"/go-gopl/:9:3","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"十、包和go工具 ","date":"2022-04-26","objectID":"/go-gopl/:10:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"10.1 go为什么编译快 所有包依赖必须列在文件头部，编译器分析包依赖时不需要读取整个文件 没有循环依赖，依赖构成一个有向无环图，可以包之间可以单独编译甚至并行编译 编译出的目标文件不仅包含它自己的导出信息，还包含依赖包的导出信息，因此go编译一个包时，go只需要去看导入依赖对应的目标文件，不需要层层去找依赖的目标文件 ","date":"2022-04-26","objectID":"/go-gopl/:10:1","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"10.2 包 每个目录下面只能有一个包。 main包会告诉go build调用连接器生成一个可执行文件。 一个目录下可以有一个额外的test包，包名以_test结尾，文件名以_test.go结尾，这会告诉go test两个包都需要构建。 有些依赖管理工具会在包名末尾加上一个版本后缀，实际的包名不包含这个后缀，例如xx/xx/yaml.v2的包名应该是yaml 重命名导入，解决包名冲突 空导入，只导入但是不引用包中的名字，例如import _ \"image/png\"（有时候导入仅仅是为了执行包的初始化） 包的导入路径是相对于$GOPATH/src 包可以自定义导入域名，防止因托管网站的变化导致导入路径变化 常用go工具 go env go get go build、go install go doc、godoc go doc命令用于查看包、成员、方法的声明和注释 godoc命令用于在本地启动一个文档服务器，例如godoc -http=localhost:6060，里面包括所有标准库的包和用户自己的包，需要单独安装这个命令。 go list vendor目录，维护依赖的本地副本 内部包，位于internal目录中，只能被internal的父目录下的包引用 ","date":"2022-04-26","objectID":"/go-gopl/:10:2","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"十一、测试 一个典型的测试命令：go test -v -run=\"xxx\" xxx_test.go，-run是一个正则表达式，用于过滤要测试的函数名，被测试对象不光可以是一个文件，也可以是一个包。 ","date":"2022-04-26","objectID":"/go-gopl/:11:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"11.1 包内测试和外部测试 包内测试是指测试代码和产品代码的包名一致，外部测试是指测试代码在一个单独的包中，以产品包名拼上_test作为包名 有时候会将产品包内的一些方法暴露给测试包，这些方法一般写在一个单独的包内测试文件export_test.go中 ","date":"2022-04-26","objectID":"/go-gopl/:11:1","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"11.2 测试覆盖率 著名计算机科学家Edsger Dijkstra说，“测试的目的是发现bug，而不是证明其不存在” 使用 go tool cover查看覆盖工具的使用方法 简单的测试覆盖率命令，go test -cover 复杂的测试覆盖率命令，go test -coverprofile=c.out -covermode=count，-coverprofile参数将覆盖率数据输出到文件中，-covermode=count表示每个语句块的执行测试将被计数 go tool cover -html=c.out命令将生成一个html版的测试报告 ","date":"2022-04-26","objectID":"/go-gopl/:11:2","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"11.3 其他 testing包还可以用来做基准测试 测试函数前缀是Benchmark，参数是*testing.B 测试命令go test -bench=xxx 性能优化工具pprof 测试命令 go test -cpuprofile=cpu.out go test -blockprofile=block.out go test -memprofile=mem.out 一般都是针对基准测试进行性能分析 go test -run=NONE -bench=xxx -cpuprofile=cpu.out 使用pprof工具生成性能分析报告 go tool pprof ...各种参数 cpu.out 示例函数，函数名的格式为Example拼上被演示函数的函数名，没有参数和返回值， 目的是作为文档，godoc会将示例函数和函数关联到一起 在函数体末尾加上以下注释可以让go test运行示例函数并检查实际输出和注释中的输出是否匹配 // Output: 或 Unordered Output: // Ava // Jess // [Jess Sarah Zoe] ","date":"2022-04-26","objectID":"/go-gopl/:11:3","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"十二、反射 reflect.Type reflect.Type是一个接口类型，这个接口只有一个实现，即类型描述符，接口值中的动态类型就是类型描述符 reflect.TypeOf(x)返回一个类型描述符，并且只会返回具体类型，不会返回接口类型 refect.Value reflect.ValueOf(x)返回一个reflect.Value类型，ValueOf从接口值中提取值部分，所以永远返回一个具体的值 reflect.Value.Type()方法会返回value的类型，返回值是reflect.Type类型 reflect.Value.Interface()方法将一个Value类型转为一个interface{}接口值，是valueof的逆操作 reflect.Value.Kind()方法会返回类型分类（类型分类是reflect.Kind类型，其实是个uint类型，其零值是reflect.Invalid） 使用反射的例子可以参考gopl.io/ch12/format和gopl.io/ch12/display 非导出字段在反射下也是可见的 接口类型的值可以通过从其他Value类型值间接获得 使用reflect.Value设置值 x := 2 //获取一个可寻址的x d := reflect.ValueOf(\u0026x).Elem() //方法1，通过指针修改x的值 px := d.Addr().Interface().(*int) *px = 3 //方法2，通过set方法修改d d.Set(reflect.ValueOf(4)) 在不可寻址的reflect.Value上调用Set会崩溃 （在指向interface{}的reflect.Value上调用SetInt等特化Set方法时会崩溃） 不能更新结构体未导出字段的值 reflect.Value.CanAddr()方法判断变量是否可寻址 reflect.Value.CanSet()方法判断变量是否可寻址且可修改 可以通过reflect.Type.Field方法获取结构体字段名和tag 可以通过reflect.Type.Method方法获取类型的方法，但是只描述方法名和类型 也可以通过reflect.Value.Method方法获取到绑定了接收者的方法，但是只描述方法名和类型，可以用reflect.Value.Call调用函数 慎用反射 反射中存在的类型错误是编译时检查不出来的，只能在运行时以崩溃的方式报告 反射会造成代码的可读性降低 反射慢 ","date":"2022-04-26","objectID":"/go-gopl/:12:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"十三、低级编程 本章主要介绍unsafe包和cgo工具 unsafe是提供了对go内置特性的访问，这些特性不安全，因为他们暴露了go的内存布局。unsafe广泛用在和操作系统交互的底层包中（runtime、os、syscall、net） cgo工具用来调用c程序 ","date":"2022-04-26","objectID":"/go-gopl/:13:0","tags":["golang"],"title":"golang入门笔记","uri":"/go-gopl/"},{"categories":["编程"],"content":"事务（transaction）的目的是要保证一连串数据操作的原子性，并能够支持操作回滚 ","date":"2022-04-20","objectID":"/db-transaction/:0:0","tags":["数据库"],"title":"数据库事务","uri":"/db-transaction/"},{"categories":["编程"],"content":"事务的并发问题 脏读：当前事务可以读取到其他事务未提交的数据 不可重复读：当前事务前后两次使用相同的查询语句查到了不同的数据，原因是在事务执行过程中，有其他事务对这批数据做了增删改操作。如果当前事务的两次读操作分别发生在其他事务开始前和提交后，读到的数据不一致，这就不算脏读，属于不可重复读问题。 幻读：事务进行读操作发现数据不存在，试图插入数据，但是插入失败，或者事务发现数据存在，试图更新数据，但更新失败，原因是事务读数据后，有其他事务对数据做了增删操作。即使数据库能够保证不发生脏读和不可重复读,仍有可能发生幻读，现象是每次读数据结果都是不存在，但就是不能插入数据，或者是每次读数据结果都是存在，但就是更新不了。 ","date":"2022-04-20","objectID":"/db-transaction/:1:0","tags":["数据库"],"title":"数据库事务","uri":"/db-transaction/"},{"categories":["编程"],"content":"参考《mysql必知必会》 ","date":"2021-12-10","objectID":"/mysql-crash-course/:0:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"一、基本概念 模式（schema）：这个概念比较模糊，一个比较常见的定义是，schema是指数据库对象的集合，其中包括表、视图、存储过程、索引等。schema通常是指数据库或表的布局和结构等信息。 主键（primary key）：主键定义在表的一列上，用来唯一地标识每一行，因此主键的值不能重复，每一行对应的主键值都是唯一的。 主键有几个使用习惯，（1）不更新主键，（2）一般把主键定义在自增id列上 外键（foreign key）：外键是表中的一个字段，对应另一个表的主键。 可伸缩性（scale），一个设计良好的数据库能够良好应对数据量的增加，我们把这种情况称为数据库的可伸缩性好，可伸缩性离不开外键的使用。 检索性能可能会受多种因素影响：检索操作（子查询、联表查询…），数据量，是否有索引或键 子句（clause）：SQL由子句构成，例如from、order by等。 完全限定列名：表名.列名，video.md5 ","date":"2021-12-10","objectID":"/mysql-crash-course/:1:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"二、mysql工具 mysql安装包中自带一个命令行工具mysql，这是一个运行在命令行的mysql客户端。 命令用;或\\g结束，\\G可以使横向表格纵向输出 输入help或\\h查看帮助 输入quit或exit退出 mysql默认端口是3306 ","date":"2021-12-10","objectID":"/mysql-crash-course/:2:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"三、使用mysql 一些关于数据库和表的命令： 选择数据库：use xxx; 查看（show） 所有数据库：show databases; 所有表：show tables; 表的列：show columns from xxx; 和desc xxx;作用相同 服务器状态：show status; 权限：show grants; 数据库和表的创建语句：show create database/table xxx; 服务器错误和告警：show errors/warnings; help show ","date":"2021-12-10","objectID":"/mysql-crash-course/:3:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"四、检索（select） ","date":"2021-12-10","objectID":"/mysql-crash-course/:4:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"简单select selectfield1fromtable_hello;selectfield1,field2,field3fromtable_hello;select*fromtable_hello; 字段前面可以加上表名，例如 selecttable_hello.field1fromtable_hello; ","date":"2021-12-10","objectID":"/mysql-crash-course/:4:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"distinct selectdistinctfieldfromtable_hello;selectdistinctfield1,field2fromtable_hello; 功能： 只检索单个字段时，列出字段所有可能的取值 检索多个字段时，列出两个字段取值的笛卡尔积 ","date":"2021-12-10","objectID":"/mysql-crash-course/:4:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"limit 返回前n行 selectfieldfromtable_hellolimitn; 返回m行，从第n行开始（行号从0开始） selectfieldfromtable_hellolimitn,m;-- 或 selectfieldfromtable_hellolimitmoffsetn; ","date":"2021-12-10","objectID":"/mysql-crash-course/:4:3","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"排序（order by子句） 按单个列或多个列排序 selectfield1fromtable_helloorderbyfield2;selectfield1fromtable_helloorderbyfield2limit5;selectfield1fromtable_helloorderbyfield1,field2; limit要放在order by后面（先排序、再选行） 按多个列排序时，先按前面的列排，值相同时，再按后面的列排 同时使用order by和limit时，order by在前，limit在后 排序方向（升序/降序） 升序（asc）：默认是升序 降序（desc）：order by field2 desc desc只对一个列有效，对多个列排序时，必须在想降序排的列后面都加上desc，例如： selectfield1fromtable_helloorderbyfield1desc,field2; ","date":"2021-12-10","objectID":"/mysql-crash-course/:4:4","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"五、过滤条件（where） 操作符： =、!=(也可以用\u003c\u003e表示不等于) \u003c、\u003c=、\u003e、\u003e= between，检索字段值位于一个范围内的数据 is null，检查字段值为null的数据 and、or，and优先级高于or，可以用括号调整优先级 in，后面跟着一个值列表，例如(1,3,5) not，对后面的所有条件取反 like，利用通配符匹配 regexp，利用正则表达式，匹配 between例子： -- 查找值为2~4的数据 select*fromtable_videowheremaudit_statusbetween2and4;-- 或 select*fromtable_videowheremaudit_timebetween\"2022-01-02 00:00:00\"and\"2022-01-03 00:00:00\"; not例子： select*fromtable_videowheremaudit_statusnotin(2,3);-- 或 select*fromtable_videowheremaudit_timebetween\"2022-01-02 00:00:00\"and\"2022-01-03 00:00:00\"; ","date":"2021-12-10","objectID":"/mysql-crash-course/:5:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"通配符 通过like关键字使用通配符匹配 %，匹配任意字符出现任意次数（包括0次） _，下划线，匹配一个任意字符（出现一次，不多不少） ","date":"2021-12-10","objectID":"/mysql-crash-course/:5:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"正则表达式 mysql仅支持正则表达式的一个很小的子集 正则表达式是本身是字符串，因此使用转义字符时要先转义一次\\，所以最终使用转义字符的时候，总是要写\\\\ mysql使用[[:\u003c:]]和[[:\u003e:]]匹配单词的开头和结尾，类似\\b ","date":"2021-12-10","objectID":"/mysql-crash-course/:5:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"六、计算字段（临时生成的字段） 计算字段在select语句中创建（计算字段是指经过计算后得到的临时字段） ","date":"2021-12-10","objectID":"/mysql-crash-course/:6:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1. 拼接字段 concat() 很多dbms使用+或||拼接字段，mysql必须使用concat()函数 例如，select concat(name, '(', status, ')') from table_user order by name limit 3; 将字段name和status拼接成name(status)的形式，会产生以下输出： +--------------------------------+ | concat(name, '(', status, ')') | +--------------------------------+ | 000007e(2) | | 00000b0(4) | | 0000253(2) | +--------------------------------+ 可以使用ltrim()、rtrim()、trim()删除数据左侧、右侧和两侧的空白符 可以使用as关键字为新字段赋予别名，例如select concat(name, '(', status, ')') as new_name ... ","date":"2021-12-10","objectID":"/mysql-crash-course/:6:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2. 算术计算 包括加减乘除和圆括号 select field1*field2 as new_name from ... ","date":"2021-12-10","objectID":"/mysql-crash-course/:6:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"七、数据处理 使用函数进行数据处理 文本处理函数： 去除空白符：trim、ltrim、rtrim 大小写转换：upper、lower 字符串长度：length 定位子串起始下标：locate 查找子串：substring 从左边或右边起获取子字符串：left、right 获取字符串的发音：soundex 日期和时间处理函数： 时间和日期计算（加减天数，或加减时分秒）： adddate, date_add, subdate, date_sub addtime, subtime datediff 格式化：date_format(date,format)，参数date是合法的日期时间，format是日期/时间的输出格式, 例如： mysql\u003eSELECTDATE_FORMAT('1997-10-04 22:23:00','%H %k %I %r %T %S %w');'22 22 10 10:23:00 PM 22:23:00 00 6' 获得当前日期/时间：now, curdate, curtime 返回一个日期时间的特定部分：date, day, dayofweek, hour, minute, month, second, time, year 数值处理 cos, sin, tan, pi abs, exp, sqrt, mod, rand ","date":"2021-12-10","objectID":"/mysql-crash-course/:7:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"八、汇总数据（数据聚合，aggregate） 上面的介绍的数据处理函数是对单条数据的处理。数据聚合是要对表中多条数据进行汇总，比如计算行数，求均值等。 聚集函数运行在整个表上，返回单个值，常用聚集函数有： avg: 计算均值。select avg(price) as avg_price where id=1003 count: 计数。count(*)计算行数，无论行中是否有null值。count(column)对特定列有值的行计数，略过null值。 max、min: 返回指定列中的最大值和最小值 sum: 返回指定列的和。也可以对计算字段求和，例如select sum(price*quantity) as total_price 字段前面可以带参数，select avg(PARAM field) as tmp，参数要放在PARAM的位置，默认参数是all，另外一种参数是distinct，它们的区别是，all对全部行进行聚集，distinct对该列的每个取值只统计一次。 可以在单条语句中执行多个聚集计算，select avg(f1) as tmp1, min(f2) as tmp2... ","date":"2021-12-10","objectID":"/mysql-crash-course/:8:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1.对数据分组（group by） 假设有表staff id name dept salary edlevel hiredate 1 张三 rd 2000 3 2009-10-11 2 李四 rd 2500 3 2009-10-01 3 王五 qa 2600 5 2010-10-02 4 王六 qa 2300 4 2010-10-03 5 马七 qa 2100 4 2010-10-06 6 赵八 pm 3000 5 2010-10-05 7 钱九 pm 3100 7 2010-10-07 8 孙十 pm 3500 7 2010-10-06 执行以下sql SELECTdept,edlevel,MAX(salary)ASmaxsalFROMstaffWHEREhiredate\u003e'2010-01-01'ORDERBYdept,edlevel; 结果 dept edlevel maxsal qa 4 2300 qa 5 2600 pm 5 3000 pm 7 3500 group by用于对数据进行分组，如果检索字段中有聚集函数的话，group by按分组聚集，而不是按整个结果集聚集。规则如下： group by必须位于where和order by之间 group by后面可以跟多个列或表达式（但不能是聚集函数），如果是表达式，select后面必须也有这个表达式 除了聚集函数以外，select后面跟着的每一列都得写到group by后面 group by后面跟的每个列必须都写到select后面 如果select语句中同时有字段和聚集函数，则sql中必须使用group by group by按分组列的笛卡尔积展示结果，也意味着能够利用group by对分组列去重，这也是为什么select中的列group by都要有，因为如果select中有一列group by中没有，比如select a,b from xxx group by a;，当a的同一个取值对应多个b的取值时，group by就没办法按笛卡尔积展示分组结果了（不可能在同一行同时展示b的多个取值） ","date":"2021-12-10","objectID":"/mysql-crash-course/:8:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2.过滤分组（having） having类似where，where对行进行过滤，having对分组进行过滤，例如： selectcust_id,count(*)asordersfromproductsgroupbycust_idhavingcount(*)\u003e=2; having和where的区别是，where在分组前过滤，having在分组后过滤 ","date":"2021-12-10","objectID":"/mysql-crash-course/:8:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"九、select子句顺序 select - from - where - group by - having - order by - limit ","date":"2021-12-10","objectID":"/mysql-crash-course/:9:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十、子查询（select嵌套） 涉及到多个表时可能会用到子查询。子查询嵌套太多会导致性能问题。 例一：利用子查询进行过滤 selectcust_idfromorderswhereorder_numin(selectorder_numfromorderitemswhereprod_id=\"TNT2\"); 应该保证where中的列和子查询中select的列保持一致 例二：将子查询作为字段 selectcust_name,(selectcount(*)fromorderswhereorders.cust_id=customers.cust_id)asordersfromcustomers; 该子查询对从customers表中检索出的每行一次（即，先检索customers表，对检索出的每一行，执行子查询）。这种子查询被称为相关子查询（correlated subquery） ","date":"2021-12-10","objectID":"/mysql-crash-course/:10:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十一、联结表（联表，join） 数据库设计中经常需要配合使用多张互相关联的业务表，目的是降低冗余和解耦 联结是sql执行过程中建立的，表定义中并不存在联结 例一，使用where子句建立联结，如果没有联结条件，会返回笛卡尔积 selectvend_name,prod_name,prod_pricefromvendors,productswherevendors.vend_id=products.vend_idorderbyvend_name,prod_name; 例一这种联结也被称为内部联结，也可以写为 selectvend_name,prod_name,prod_pricefromvendorsINNERJOINproductsONvendors.vend_id=products.vend_id; 例二，联结多个表 selectvend_name,prod_name,prod_price,quantityfromorderitems,vendors,productswherevendors.vend_id=products.vend_idandorderitems.prod_id=products.prod_idandorder_num=20005; ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1.内部联结（等值联结） 见上例 ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2.自联结 表别名：as关键字同样可以给表指定别名 例子：根据某产品id找出生产该产品的厂家生产的其他产品 selectp1.prod_id,p1.prod_namefromproductsasp1,productsasp2wherep1.vend_id=p2.vend_idandp2.prod_id='DTNTR'; ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"3.自然联结 自然联结是指检索结果中没有重复的列(不是行)，可以使用通配符让系统自动去掉重复的列，一般是对某个表使用通配符，然后手动指定其他表中的列，例如： selectc.*,o.order_num,o.order_dateoi.prod_id,oi.quantity,oi.item_pricefromcustomersasc,ordersaso,orderitemsasoiwherec.cust_id=o.cust_idandoi.order_num=o.order_numandprod_id='FB'; ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:3","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"4.外部联结 与内部联结不同，外部联结的执行结果中包含没有产生关联的行。例如，下面这个sql想按客户id（cust_id）建立关联，检索出客户和订单的关系，并要求结果中包含没有订单的客户。 selectcustomers.cust_id,orders.order_numfromcustomersLEFTOUTERJOINordersONcustomers.cust_id=orders.cust_id 关键字： left outer join：left要求结果中包含outer join左边表中的无关联行 right outer join：结果中包含右边表中的无关联行 ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:4","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"5.联结中带聚集函数 selectcustomers.cust_name,customers.cust_id,count(orders.order_num)asnum_ordfromcustomersleftouterjoinordersoncustomers.cust_id=orders.cust_idgroupbycustomers.cust_id; 以上sql的作用是：获得所有客户的订单数，包括哪些没有订单的客户 ","date":"2021-12-10","objectID":"/mysql-crash-course/:11:5","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十二、组合查询（union） 同时执行多个select，并将结果作为单个查询结果集返回。例如 selectvend_id,prod_id,prod_pricefromproductswhereprod_id\u003c=5unionselectvend_id,prod_id,prod_pricefromproductswherevend_idin(1001,1002); union的规则： union中的每个查询必须包含相同的列、表达式或聚集函数 union会自动对返回的行去重，如果不想去重，要使用union all 只能有一个order by，必须放在最后一个select之后。 ","date":"2021-12-10","objectID":"/mysql-crash-course/:12:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十三、全文本搜索 mysql通过建立全文索引（倒排索引）来支持全文搜索。 建表时指定全文检索： createtabledemo{...some_wordstextnull,...fulltext(some_words)}engine=MyISAM; 使用函数 match 和 against 进行全文搜索，match 指定要匹配的列，against 指定要使用的搜索表达式。例如 selectnode_textfromproductnodeswherematch(node_text)against('rabbit'); 搜索不区分大小写。搜索结果默认以匹配接近程度进行排序。 match和against的计算结果实际上是一个匹配等级值，表示匹配的接近程度，例如 selectnode_text,match(node_text)against('rabbit')asmatchrankfromproductnodes; 查询扩展：放宽搜索范围，搜索结果中可能不包含指定的检索词，例如select node_text, match(node_text) against('rabbit' with query expansion) as matchrank from productnodes; 布尔文本搜索：against('xxx' in boolean mode)，性能较差，可以不需要fulltext索引。可以指定要匹配的词，要排斥的词，匹配优先级等。 ","date":"2021-12-10","objectID":"/mysql-crash-course/:13:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十四、数据的插入、删除和更新（增删改） ","date":"2021-12-10","objectID":"/mysql-crash-course/:14:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1.插入 简单写法：insert into customers values(null,'xxx','xxx',null);，各个列必须以它们在表定义中的顺序填充 复杂写法：指定要插入的列 insertintocustomers(name,address,city)values('123','asd',null); 可以给多组value，例如，values('xxx','xxx'),('222',NULL); 插入检索出的数据，例如，insert into table1(xx,xx,xx) select xx,xx,xx from table2 where...; ","date":"2021-12-10","objectID":"/mysql-crash-course/:14:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2.更新 更新操作一定要带上条件，否则就会更新全表 updatetablenamesetcust_email='xxxx',cust_name='sss'wherecust_id=2345; 可以在update语句中使用子查询 ignore关键字：update默认的逻辑是只要有一行数据更新失败就失败，ignore可以跳过更新失败的行，继续更新其他行 ","date":"2021-12-10","objectID":"/mysql-crash-course/:14:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"3.删除 删除操作一定要带上条件，否则就会删除表中的所有数据 delete from customers where cust_id = 1234; 删除全表：truncate table tablename，实际上是直接把表删除后再新建一个表 ","date":"2021-12-10","objectID":"/mysql-crash-course/:14:3","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十五、创建和操作表 ","date":"2021-12-10","objectID":"/mysql-crash-course/:15:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1.创建表 查看数据库和表的创建语句：show create database/table xxx; create语句： CREATETABLEifnotexists`video`(`id`bigint(20)unsignedNOTNULLAUTO_INCREMENTCOMMENT'自增id',`file`varchar(64)NOTNULLDEFAULT''COMMENT'文件名',`maudit_status`tinyint(4)unsignedNOTNULLDEFAULT'0'COMMENT'status of machine audit',`source_url`varchar(510)NOTNULLDEFAULT''COMMENT'原始url',`create_time`timestampNOTNULLDEFAULT'0000-00-00 00:00:00'COMMENT'创建时间',`maudit_result`varchar(4096)NOTNULLDEFAULT''COMMENT'result of machine audit',PRIMARYKEY(`id`),UNIQUEKEY`object_name`(`file`),KEY`idx_src_create_time`(`src_create_time`),)ENGINE=InnoDBAUTO_INCREMENT=1DEFAULTCHARSET=utf8COMMENT='视频表'; 规则： 主键可以是多个列，例如，PRIMARY KEY (id1,id2) 每个表只允许一列auto_increment，并且该列必须能被索引（一般是把这列设置为主键） 不允许使用函数作为默认值，只能用常量 外键不允许跨引擎 ","date":"2021-12-10","objectID":"/mysql-crash-course/:15:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2.修改表 altertablexxxaddphone_numchar(20);--增加列 altertablexxxdropcolumnphone_num;--删除列 altertablexxxaddconstraintxxx_fkforeignkey(vend_id)referencesvendors(id);--添加一个外键约束（在vend_id这一列上，添加一个名为xxx_fk的外键约束） ALTERTABLEstudentsDROPFOREIGNKEYfk_class_id;-- 删除外键约束 droptablexxx;--删除表 renametablexxxtoxxx2;--重命名表 ","date":"2021-12-10","objectID":"/mysql-crash-course/:15:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十六、视图 视图是虚拟的表，它只是把查询封装了一下，里面并不包含数据，因此使用视图时要注意性能问题。可以利用视图简化复杂的联结查询 视图操作： create view, drop view, create or replace view show create view xxx, 查看创建视图的语句 ","date":"2021-12-10","objectID":"/mysql-crash-course/:16:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十七、存储过程 存储过程把一系列操作封装在一起。可以在存储过程中加入事务。 createprocedurexxx()beginselectxxxfromxxx;end; 如果是在mysql命令行客户端使用该语句，要对命令结束符做临时修改，例如: delimiter//createprocedurexxx()beginselectxxxfromxxx;end//delimiter; 执行存储过程：call xxx(); 删除存储过程：drop procedure (if exists) xxx; 查看存储过程创建语句：show create procedure xxx; 查看存储过程信息：show procedure status (like 'procedure_name'); ","date":"2021-12-10","objectID":"/mysql-crash-course/:17:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"1.参数和变量 所有mysql变量都必须以@开头 定义一个用户变量：set @num=1;或set @num:=1; 定义存储过程时带参数： -- in/out/inout分别对应输入变量、输出变量和输入输出变量 createprocedurexxx(invalue1int,outvalue2decimal(8,2),inoutvalue3boolean)comment'This is a comment'beginselectxxxintovalue2from...;end; 执行存储过程： callxxx(20,@v2,@v3); 获取存储过程的输出： select@v2,@v3; 可以在存储过程中写逻辑： declarexxxintdefault6;declarexxx2booleandefaultfalse;ifxxx2then...endif; ","date":"2021-12-10","objectID":"/mysql-crash-course/:17:1","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"2.游标 mysql游标只能用于存储过程和函数。游标可以用来从select返回的结果集中一行一行地取数据。 ","date":"2021-12-10","objectID":"/mysql-crash-course/:17:2","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"3.触发器 触发器可以让mysql在某个表发生更改时自动执行某个动作。触发器可以响应delete、insert或update语句。 ","date":"2021-12-10","objectID":"/mysql-crash-course/:17:3","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十八、事务 一些概念： 事务（transaction）：是指一组sql语句 回滚（rollback）：只能在事务内部使用 提交（commit）：做最终的写入操作 保留点（savepoint）：事务处理中设置的临时占位符，可以回滚到保留点，而不是整个事务 starttransaction;...rollback;...savepointxx;...rollbacktoxx;...commit; ","date":"2021-12-10","objectID":"/mysql-crash-course/:18:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"十九、用户及权限管理 数据库mysql.user表中有所有的用户信息 createuserxxxidentifiedby'password';renameuserxxxtoxxx2;dropuserxxx;showgrantsforxxx;--显示用户权限 grantselectondb.*toxxx;--grant授予权限 revokeselectondb.*toxxx;--revoke撤销权限 setpasswordforxxx=Password('123456');--改密码 ","date":"2021-12-10","objectID":"/mysql-crash-course/:19:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"二十、数据库维护 数据备份 命令行工具：mysqldump、mysqlhotcopy 命令：backup table、select into outfile、restore table、flush tables 检查状态 analyse table、check table 日志 错误日志：data/hostname.err，命令行参数 查询日志：data/hostname.log，记录所有mysql活动 二进制日志：data/hostname-bin，记录数据更新语句 慢查询日志：data/hostname-slow.log，记录执行缓慢的查询 ","date":"2021-12-10","objectID":"/mysql-crash-course/:20:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"二十一、改善性能 使用explain语句让mysql解释它如何执行某个select语句 join、union和子查询的性能不一定谁高谁低，需要具体问题具体分析 不要用select * 使用多条select语句和union来代替or条件 索引提升查询性能，但是会降低插入、删除和更新的性能 like很慢 … ","date":"2021-12-10","objectID":"/mysql-crash-course/:21:0","tags":["mysql","数据库"],"title":"mysql入门笔记","uri":"/mysql-crash-course/"},{"categories":["编程"],"content":"参考MDN css入门教程 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:0:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"导入 css 1、导入外部样式： \u003clink rel=\"stylesheet\" href=\"styles.css\" /\u003e 2、内部样式 使用 style 元素 \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eMy CSS experiment\u003c/title\u003e \u003cstyle\u003e h1 { color: blue; background-color: yellow; border: 1px solid black; } p { color: red; } \u003c/style\u003e \u003c/head\u003e ... \u003c/html\u003e 3、内联样式 使用 style 属性 \u003ch1 style=\"color: blue;background-color: yellow;border: 1px solid black;\"\u003e Hello World! \u003c/h1\u003e ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:1:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"语法 1、选择器+大括号，属性:值; h1 { color: red; font-size: 5em; } 2、函数 width: calc(90% - 30px); 3、@规则 @import：导入样式表 @media：媒体查询（当条件成立时才应用样式） 4、速记属性 允许在一行中设置多个属性值，如 padding、border 等，例如： padding: 10px 15px 15px 5px; /* 等价于 */ padding-top: 10px; padding-right: 15px; padding-bottom: 15px; padding-left: 5px; background: red url(bg-graphic.png) /* 等价于 */ background-color: red; background-image: url(bg-graphic.png); ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:2:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"选择器和选择符 选择器 例子 元素 h1 id #onething 类 .manythings、a.manythings、.classA.classB 伪类 a:link、*:link、:link 属性 a[title]、a[href=\"https://example.com\"]、a[attr~=v]、a[attr|=v]、a[attr]、[attr^=value]、[attr$=value]、[attr*=value]、[attr=value i]（结尾加个 i 代表按大小写不敏感匹配） 伪元素 p::first-line 通用选择器 * 注： 多个选择器连在一起写代表“与”的关系。 伪类代表元素的状态，伪元素是一种虚拟的元素。参考：常见伪类和伪元素 运算符 例子 空格：后代选择器 article p \u003e：子代选择器 article \u003e p +：相邻兄弟选择器 h1 + p ~：通用兄弟选择器 h1 ~ p ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:3:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"继承 继承：有些父元素上的 css 属性可以被子元素继承，有些不能。 使用 inherit、initial、unset、revert 这四个属性值控制继承，例如 .my-class-1 a { color: inherit; } 属性 all 可以用来代表所有属性 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:4:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"层叠 多个相同权重的规则应用到同一个元素时，后面的覆盖前面的 选择器具有优先级，优先级计算公式 千位：style 属性（内联属性）得一分 百位：id 选择器得一分 十位：类选择器、属性选择器、伪类选择器得一分 个位：元素选择器、伪元素选择器得一份 通用选择器 (*)，组合符 (+, \u003e, ~, ' ‘)，和否定伪类 (:not) 不会影响优先级。 计算时不允许进位，无论多少个低位选择器的权重叠加，都不会超过一个高位选择器。 !important：优先级高于其他所有 当浏览器遇到无法解析的 css 时（比如 css 拼写错误）这个 css 会被忽略。 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:5:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"盒子 块级盒子（Block Box）： 盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间 会换行 可以设置宽高（width 和 height） padding、margin 和 border 会把周围的元素推开 内联盒子（Inline Box）： 不会换行 宽高不起作用（width 和 height） 垂直方向的 padding、margin 和 border 不会把其他 inline 盒子推开 水平方向的 padding、margin 和 border 会把其他 inline 盒子推开 盒子的显示类型： 外部显示类型：决定盒子在它的父元素内是如何布局的，display 值为 inline 或 block 内部显示类型：决定盒子内部元素如何布局，display 值为 flex、grid 等。默认为正常文档流（inline 是 inline，block 是 block） 其他类型： inline-flex：外部显示类型为 inline，内部显示类型为 flex inline-block：不换行的 block，能设置高宽、margin 和 padding，能把周围推开 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:6:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"盒模型 完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。 盒模型组成：content、padding、border、margin 标准盒模型：width 和 height 设置的是 content。box-sizing: content-box; 替代（IE）盒模型：width 和 height 设置的是总长宽。box-sizing: border-box; 外边距折叠：如果两个元素相邻，它们之间的距离不是两个元素的 margin 之和，而是取两个元素 margin 的较大值 margin 可以为负值。padding 不可以为负 属性写法（去掉后缀就是简写）：{margin/border/padding}-{top/right/bottom/left}-{width/style/color} ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:7:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"背景和边框 背景（background）: background-image 属性可以有多个图片，图片会叠在一起显示 {background}-{color/image/repeat/size/position/attachment} 可以设置渐变（gradient）背景 边框（border）: {border}-{width/style/color/radius} ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:8:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"文本方向与逻辑属性 writing-mode: horizontal-tb、vertical-rl、vertical-lr 逻辑属性是为了解决文本方向变化时盒子的高宽等属性不能正确变化的问题，例如 inline-size 对应 width block-size 对应 height 内外边距、边框也有对应的逻辑属性 属性值也有对应的逻辑属性值 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:9:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"处理内容溢出 内容溢出 overflow:visible/hidden/scroll/auto overflow-x overflow-y 文本换行 word-break overflow-wraps hyphens ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:10:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"值和单位 参考：CSS 的值与单位 css 值可以使用关键字和值。关键字是指 red、top 等。 数值类型：integer、number、dimension、\u003cpercentage\u003e、\u003clength\u003e 长度（length） 绝对单位：px 相对单位：rem 百分比（percentage） 百分比通常是相对于父元素 颜色（\u003ccolor\u003e） RGB 和 RGBA：RGBA 颜色在 RGB 的基础上增加了一个透明度值，与 opacity 属性不同，opacity 使得元素和它里面的所有东西都不透明，而 RGBA 颜色只让指定的颜色不透明。（可以用 RBGA 颜色来增加一层滤镜） HSL 和 HSLA：RGB 是红绿蓝，HSL 是色调、饱和度和亮度 图片（\u003cimage\u003e）和渐变（\u003cgradient\u003e） 位置（\u003cposition\u003e） 标识符，标识符就是指上面提到的 css 关键字 字符串，例如content: \"This is a string\" 函数，例如 rgb()、url()、calc()等 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:11:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"尺寸 原始尺寸/固有尺寸： 例如图像本身的尺寸 空 div 没有尺寸，高度为 0，宽度由于其是块级元素会扩展到和父元素一样宽。 用百分数设置尺寸时： 对于 width 和 height，是相对于父元素宽度的百分比 对于内外边距，不论是左右边距还是上下边距，都是相对于 inline-size（即宽度）的百分比 min-和 max-尺寸： 如果盒子内容会变化，用 min-和 max-设置最小或最大尺寸，盒子尺寸就会随内容自动变化 这个技术就是用来使图片（\u003cimage\u003e）可响应的，可响应是指图片随设备尺寸自动缩放。 视口尺寸： vw 和 vh ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:12:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"替换元素和表单 替换元素：指图像和视频元素，css 不能影响其内部布局 调整大小，object-fit: cover/contain/fill; 在 flex 和 grid 布局中，元素会被拉伸，而图像不会 表单的样式在不同浏览器上不太统一，需要额外设置 css 样式保证其初始样式一致，已经有一些工具帮开发人员完成了这个工作，例如 Normalize.css。 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:13:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"字体 web 安全字体：可以在任何一种操作系统上找到的字体。参考：cssfontstack 五种字体的大类型： serif，有衬线字体，衬线是指字体笔画尾端的小装饰，常见于印刷体字体 sans-serif，无衬线字体 monospace，等宽字体，通常用于代码 cursive，手写体 fantasy，用来装饰的字体 使用上面这五种字体时，由浏览器决定具体使用什么字体 常见属性属性名： font-family/size/style/weight/transform/decoration color text-shadow text-align line-height letter-spacing word-spacing web 字体：访问时和页面一起下载，本不需要本地事先有这种字体 @font-face { font-family: \"myFont\"; src: url(\"myFont.ttf\"); } 注意： 有些字体有版权，不能随便用 不同浏览器支持的字体格式可能不同，常见的格式有.ttf, .woff, .woff2 等 在线字体服务，例如 google fonts，可以从第三方站点导入字体，例如用\u003clink\u003e或@import导入字体，不需要开发人员自己提供字体 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:14:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"布局 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:0","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"正常布局流 正常布局流是指默认的布局。 块元素的布局方向垂直于书写方向 内联元素的布局方向和书写方向一致 默认的，块元素的宽度是其父元素的 100%，高度与其内容高度一致。内联元素的 height 和 width 与内容一致。 外边距叠加 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:1","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"flexbox（弹性盒子） display:flex flexbox 用于创建横向或纵向的一维布局，里面的子元素被称为 flex 项，flex 有以下特点： 默认方向是横向（父元素 flex-direction:row） 元素会被拉伸到和最高的元素相同（父元素 align-items:stretch） 所有 flex 项都默认从容器的开始位置进行排列，排列成一行后，在尾部留下一片空白。 概念： 主轴是指沿着 flex 项放置方向的轴，交叉轴是指垂直方向的轴 设置了 display:flex 的父元素被称为 flex 容器，里面的子元素被称为 flex 项 方向： flex-direction:row/column/row-reverse/column-reverse，设置主轴方向，-reverse 代表反向排列元素 flex-wrap: wrap，允许换行 flex-flow：以上两项的缩写 动态尺寸： flex:1，无单位的数字代表一个比例，其所占宽度=(1/所有 flex 项所占比例之和)*屏幕宽度 flex:1 200px，该 flex 项至少占 200px，剩余空间按比例分配 flex-grow、flex-basis，分别是以上两个的全写 flex-shrink：指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。 对齐： align-items 控制 flex 项在交叉轴上的位置 justify-content 控制 flex 项在主轴上的位置，其值包括 flex-start、flex-end、flex-around、flex-between 排序：使用 order 属性，默认值是 0，值越大，越往后排 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:2","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"grid（网格） display:grid 默认只有一列，创建多个列： grid-template-columns: 200px 200px 200px; 用fr单位创建多个列，grid-template-columns: 2fr 1fr 1fr，fr定义了一个比例，有点类似于flexbox不带单位的尺寸 grid-template-columns: 300px 2fr 1fr，剩下的两列会根据除去300px后的可用空间按比例分配 使用repeat函数重复生成列 在网格系统中，行和列之间的间隙被称为 gutter（沟槽），如何修改gutter： grid-column/row-gap 显式网格和隐式网格，隐式网格是指浏览器会自动将多出来的内容放到新的行/列里面去： 参数默认是auto，大小会根据放入的内容自动调整 grid-auto-rows/columns，指定显式网格的大小 动态行列尺寸： 使用minmax函数设置行列尺寸，minmax函数可以设置一个取值范围，例如minmax(100px, auto)，下面是一个例子 .container { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); grid-auto-rows: minmax(100px, auto); grid-gap: 20px; } 利用分隔线放置内容 我们的网格有许多分隔线，第一条线的起始点与文档书写模式相关。在英文中，第一条列分隔线（即网格边缘线）在网格的最左边而第一条行分隔线在网格的最上面。 grid-column/row-start/end gird-column/row：同时指定开始线和结束线，要使用/符号分开，例如：grid-column: 1 / 3; 利用grid-template-areas和grid-area放置内容 对于某个横跨多个格子的元素，重复写上那个元素grid-area属性定义的区域名字 所有名字只能出现在一个连续的区域，不能在不同的位置出现 一个连续的区域必须是一个矩形 使用.符号让一个格子留空 .container { display: grid; grid-template-areas: \"header header\" \"sidebar content\" \"footer footer\"; grid-template-columns: 1fr 3fr; grid-gap: 20px; } header { grid-area: header; } article { grid-area: content; } aside { grid-area: sidebar; } footer { grid-area: footer; } ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:3","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"浮动（float） 略 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:4","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"定位（position） 静态定位：position: static;，默认值，将元素放入文档布局流中的正常位置 相对定位：position: relative;，使用top, bottom, left, 和 right定位 绝对定位：position: absolute;，绝对定位的元素不再存在于正常文档布局流中，它在自己的层独立于一切。绝对定位元素相对于其“包含元素定位”。哪个元素是绝对定位元素的“包含元素”取决于绝对定位元素的父元素的position属性 如果父元素都是static，绝对定位元素会被包含在初始快容器中（\u003chtml\u003e元素外面，根据浏览器视口定位） 如何修改绝对定位元素的相对元素？把它的一个父元素设置为相对定位（position: relative）就好了。 z-index：如果有多个绝对定位元素，用z-index指定它们的堆叠顺序（z是指z轴，假设网页有高度）。z-index默认值是0，数字大的在上面，小的在下面。 固定定位：position: fixed;，固定定位固定元素相对于浏览器视口本身。 /*让一个固定定位元素顶部居中*/ h1 { position: fixed; top: 0; margin: 0 auto; /*使用auto居中*/ width: 500px; background: white; padding: 10px; } position: sticky;：相对定位和固定定位的混合体，被定位的元素一开始表现得像相对定位一样，直到它滚动到某个阈值点（例如，距视口顶部1​​0px）后它就变得固定了。 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:5","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"多列布局 通过这两个属性开启多列布局，column-count 或者 column-width column-count属性创建指定列数，由浏览器计算每一列分配多少空间。 column-width属性指定列宽，由浏览器计算创建几列。 用 column-gap 改变列间间隙。 用 column-rule 在列间加入一条分割线。column-rule 是 column-rule-color 和 column-rule-style的缩写，接受和 border 一样的单位。 禁止内容折断：break-inside: avoid 或 page-break-inside: avoid ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:6","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"响应式布局 媒体查询：当满足指定条件时css才会被应用，例如 @media screen and (min-width: 800px) { .container { margin: 1em 2em; } } 断点：媒体查询，以及样式改变时的点，被叫做断点（breakpoints），通常是一个阈值。 现代布局方式，多栏布局，弹性盒子和网格默认是响应式的。 视口元标签： \u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1\"\u003e，它告诉移动端浏览器，应该将视口宽度设定为设备的宽度，将文档放大到其预期大小的100%。如果不加这个，用断点和媒体查询实现的响应式设计不会生效，因为视口大小还是PC端的大小 initial-scale：设定了页面的初始缩放，我们设定为1。 height：特别为视口设定一个高度。 阻止用户缩放 minimum-scale：设定最小缩放级别。 maximum-scale：设定最大缩放级别。 user-scalable：如果设为no的话阻止缩放。 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:7","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"},{"categories":["编程"],"content":"媒体查询 @media media-type and (media-feature-rule) { /* CSS rules go here */ } 它由以下部分组成： 一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）； 它的值可以是：all、print、screen、speech 一个媒体表达式，是一个被包含的CSS生效所需的规则或者测试； min-width、max-width、width等 一组CSS规则，会在测试通过且媒体类型正确的时候应用。 ","date":"2021-11-14","objectID":"/css-mdn-tutorial/:15:8","tags":["css","前端"],"title":"css入门笔记","uri":"/css-mdn-tutorial/"}]