<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>makefile笔记 - 星</title><meta name="Description" content=""><meta property="og:title" content="makefile笔记" />
<meta property="og:description" content="参考 跟我一起写 Makefile系列 GNU make官方文档 Makefile 中:= ?= &#43;= =的区别 Four Dollar signs in Makefile 概述 makefile可以理解成是专门用来在unix下编译工" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.shiwj.top/21.makefile-tutorial/" /><meta property="og:image" content="http://blog.shiwj.top/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-27T13:41:00+08:00" />
<meta property="article:modified_time" content="2022-10-27T13:41:00+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://blog.shiwj.top/logo.png"/>

<meta name="twitter:title" content="makefile笔记"/>
<meta name="twitter:description" content="参考 跟我一起写 Makefile系列 GNU make官方文档 Makefile 中:= ?= &#43;= =的区别 Four Dollar signs in Makefile 概述 makefile可以理解成是专门用来在unix下编译工"/>
<meta name="application-name" content="星">
<meta name="apple-mobile-web-app-title" content="星"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://blog.shiwj.top/21.makefile-tutorial/" /><link rel="prev" href="http://blog.shiwj.top/20.cpp-stl-algorithm-overview/" /><link rel="next" href="http://blog.shiwj.top/22.scl/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "makefile笔记",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/blog.shiwj.top\/21.makefile-tutorial\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "http:\/\/blog.shiwj.top\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048 
                        }],"genre": "posts","keywords": "make","wordcount":  43957 ,
        "url": "http:\/\/blog.shiwj.top\/21.makefile-tutorial\/","datePublished": "2022-10-27T13:41:00+08:00","dateModified": "2022-10-27T13:41:00+08:00","publisher": {
            "@type": "Organization",
            "name": "shiwj","logo": {
                    "@type": "ImageObject",
                    "url": "http:\/\/blog.shiwj.top\/images\/avatar.png",
                    "width":  690 ,
                    "height":  690 
                }},"author": {
                "@type": "Person",
                "name": "shiwj"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 全部 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i>  </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="星"><span class="header-title-pre"><i class='far fa-star-half-alt fa-fw' aria-hidden='true'></i></span>星</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">全部</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="https://github.com/openjz" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">makefile笔记</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/openjz" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>shiwj</a>
</span>&nbsp;<span class="post-category">included in <a href="/categories/%E7%BC%96%E7%A8%8B/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>编程</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-10-27">2022-10-27</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;43957 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;88 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#参考">参考</a></li>
    <li><a href="#概述">概述</a></li>
    <li><a href="#关于程序的编译和链接">关于程序的编译和链接</a></li>
    <li><a href="#makefile介绍">Makefile介绍</a>
      <ul>
        <li><a href="#一makefile的规则">一、Makefile的规则</a></li>
        <li><a href="#二一个示例">二、一个示例</a></li>
        <li><a href="#三make是如何工作的">三、make是如何工作的</a></li>
        <li><a href="#四在makefile中使用变量">四、在makefile中使用变量</a></li>
        <li><a href="#五make自动推导">五、make自动推导</a></li>
        <li><a href="#六多个目标文件依赖相同的文件">六、多个目标文件依赖相同的文件</a></li>
        <li><a href="#七清空目标文件的规则clean">七、清空目标文件的规则（clean）</a></li>
      </ul>
    </li>
    <li><a href="#更详细的makefile介绍">更详细的Makefile介绍</a>
      <ul>
        <li><a href="#一makefile里有什么">一、Makefile里有什么</a></li>
        <li><a href="#二makefile命名">二、Makefile命名</a></li>
        <li><a href="#三引用其它makefile">三、引用其它Makefile</a></li>
        <li><a href="#四环境变量makefiles">四、环境变量MAKEFILES</a></li>
        <li><a href="#五makefile的执行步骤">五、makefile的执行步骤</a></li>
      </ul>
    </li>
    <li><a href="#更更详细的makefile的介绍">更更详细的makefile的介绍</a>
      <ul>
        <li><a href="#一规则举例">一、规则举例</a></li>
        <li><a href="#二规则的语法">二、规则的语法</a></li>
        <li><a href="#三在规则中使用通配符">三、在规则中使用通配符</a></li>
        <li><a href="#四文件搜索"><strong>四、文件搜索</strong></a></li>
        <li><a href="#五伪目标">五、伪目标</a></li>
        <li><a href="#六多个目标依赖相同的文件">六、多个目标依赖相同的文件</a></li>
        <li><a href="#七多目标的静态模式">七、多目标的静态模式</a></li>
        <li><a href="#八自动生成头文件依赖">八、自动生成头文件依赖</a></li>
      </ul>
    </li>
    <li><a href="#书写命令">书写命令</a>
      <ul>
        <li><a href="#一显示命令">一、显示命令</a></li>
        <li><a href="#二命令执行">二、命令执行</a></li>
        <li><a href="#三命令出错">三、命令出错</a></li>
        <li><a href="#四嵌套执行make">四、嵌套执行make</a></li>
        <li><a href="#五定义命令包">五、定义命令包</a></li>
      </ul>
    </li>
    <li><a href="#使用变量">使用变量</a>
      <ul>
        <li><a href="#一变量的基础">一、变量的基础</a></li>
        <li><a href="#二变量中的变量">二、变量中的变量</a></li>
        <li><a href="#三变量高级用法">三、变量高级用法</a></li>
        <li><a href="#四追加变量值">四、追加变量值</a></li>
        <li><a href="#五override指示符">五、override指示符</a></li>
        <li><a href="#六多行变量">六、多行变量</a></li>
        <li><a href="#七环境变量">七、环境变量</a></li>
        <li><a href="#八目标变量">八、目标变量</a></li>
        <li><a href="#九模式变量">九、模式变量</a></li>
      </ul>
    </li>
    <li><a href="#使用条件判断">使用条件判断</a>
      <ul>
        <li><a href="#一示例">一、示例</a></li>
        <li><a href="#二语法">二、语法</a></li>
      </ul>
    </li>
    <li><a href="#使用函数">使用函数</a>
      <ul>
        <li><a href="#一函数的调用语法">一、函数的调用语法</a></li>
        <li><a href="#二字符串处理函数">二、字符串处理函数</a></li>
        <li><a href="#三文件名和目录操作函数">三、文件名和目录操作函数</a></li>
        <li><a href="#四foreach函数">四、foreach函数</a></li>
        <li><a href="#五if函数">五、if函数</a></li>
        <li><a href="#六call函数">六、call函数</a></li>
        <li><a href="#七origin函数">七、origin函数</a></li>
        <li><a href="#八shell函数">八、shell函数</a></li>
        <li><a href="#九控制make的函数">九、控制make的函数</a></li>
        <li><a href="#其他函数">其他函数</a></li>
      </ul>
    </li>
    <li><a href="#make的运行">make的运行</a>
      <ul>
        <li><a href="#一make的退出码">一、make的退出码</a></li>
        <li><a href="#二指定makefile">二、指定Makefile</a></li>
        <li><a href="#三指定目标">三、指定目标</a></li>
        <li><a href="#四检查规则">四、检查规则</a></li>
        <li><a href="#五make的参数">五、make的参数</a></li>
      </ul>
    </li>
    <li><a href="#隐含规则">隐含规则</a>
      <ul>
        <li><a href="#一使用隐含规则">一、使用隐含规则</a></li>
        <li><a href="#二隐含规则一览">二、隐含规则一览</a></li>
        <li><a href="#三隐含规则使用的变量">三、隐含规则使用的变量</a></li>
        <li><a href="#四隐含规则链">四、隐含规则链</a></li>
        <li><a href="#五定义模式规则">五、定义模式规则</a></li>
        <li><a href="#六老式的后缀规则">六、老式的&quot;后缀规则&rdquo;</a></li>
        <li><a href="#七隐含规则搜索算法">七、隐含规则搜索算法</a></li>
      </ul>
    </li>
    <li><a href="#使用make更新函数库文件">使用make更新函数库文件</a>
      <ul>
        <li><a href="#一函数库文件的成员">一、函数库文件的成员</a></li>
        <li><a href="#二函数库成员的隐含规则">二、函数库成员的隐含规则</a></li>
        <li><a href="#三函数库文件的后缀规则">三、函数库文件的后缀规则</a></li>
        <li><a href="#四注意事项">四、注意事项</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="参考">参考</h2>
<p><a href="https://seisman.github.io/how-to-write-makefile/index.html" target="_blank" rel="noopener noreffer">跟我一起写 Makefile系列</a>
<br>
<a href="https://www.gnu.org/software/make/manual/make.pdf" target="_blank" rel="noopener noreffer">GNU make官方文档</a>
<br>
<a href="https://www.cnblogs.com/wanqieddy/archive/2011/09/21/2184257.html" target="_blank" rel="noopener noreffer">Makefile 中:= ?= += =的区别</a>
<br>
<a href="https://stackoverflow.com/questions/1320226/four-dollar-signs-in-makefile" target="_blank" rel="noopener noreffer">Four Dollar signs in Makefile</a>
</p>
<h2 id="概述">概述</h2>
<p>makefile可以理解成是专门用来在unix下编译工程的一个特殊的脚本。makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定哪些文件需要先编译、哪些文件需要后编译、哪些文件需要重新编译，甚至进行更复杂的操作。此外，还能在makefile中执行操作系统的命令。</p>
<p>makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个用来解释makefile语句的命令行程序。</p>
<p>本文默认的编译器是UNIX下的GCC。</p>
<h2 id="关于程序的编译和链接">关于程序的编译和链接</h2>
<p>在此，我想多说关于程序编译的一些规范和方法。一般来说，无论是C还是C++，首先要把源文件编译成目标文件（即Object File），在Windows下是.obj文件，UNIX下是.o文件，这个动作叫做编译（compile）。然后再把大量的目标文件合并成可执行文件，这个动作叫作链接（link）。</p>
<p>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出目标文件。一般来说，每个源文件都应该对应一个目标文件（.o文件或是.obj文件）。</p>
<p>链接时，主要是链接函数和全局变量。链接器并不管源文件，只管目标文件。在大多数时候，由于编译生成的目标文件太多，而在链接时需要明确地指出目标文件名，这就使得编译很不方便。所以我们要给目标文件打个包，在Windows下这种包叫“库文件”（Library File)，在UNIX下是Archive File。</p>
<h2 id="makefile介绍">Makefile介绍</h2>
<p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎样编译和链接程序。</p>
<p>首先我会用一个示例来说明Makefile的书写规则，以便给大家一个直观的认识。这个示例来源于GNU的make使用手册。在这个示例中，我们的工程有8个.c文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：
1）如果这个工程没有编译过，那么我们的所有.c文件都要编译并被链接。
2）如果这个工程的某几个.c文件被修改，那么我们只编译被修改的.c文件，并链接目标程序。
3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的.c文件，并链接目标程序。</p>
<p>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动地根据当前文件的修改情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>
<h3 id="一makefile的规则">一、Makefile的规则</h3>
<p>Makefile的简要规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">target ... </span><span class="o">:</span> <span class="n">prerequisites</span> ...
        <span class="nb">command</span>
        ...
</code></pre></td></tr></table>
</div>
</div><p>target是makefile中的一个目标文件，可以是Object File，也可以是可执行文件，还可以是一个标签（伪目标）。prerequisites表示的是要生成那个target所需要的文件或目标。command也就是make需要执行的命令。（可以是任意的Shell命令）</p>
<p>这是一个文件的依赖关系。也就是说，target这个目标文件依赖于prerequisites中的文件，其生成规则定义在command中。也就是说，prerequisites中如果有一个以上的文件比target文件更新，command所定义的命令就会被执行。这就是Makefile的规则，也是Makefile中最核心的内容。</p>
<h3 id="二一个示例">二、一个示例</h3>
<p>正如前面所说的，如果一个工程有3个头文件，和8个.c文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">edit </span><span class="o">:</span> <span class="n">main</span>.<span class="n">o</span> <span class="n">kbd</span>.<span class="n">o</span> <span class="n">command</span>.<span class="n">o</span> <span class="n">display</span>.<span class="n">o</span> \
        <span class="n">insert</span>.<span class="n">o</span> <span class="n">search</span>.<span class="n">o</span> <span class="n">files</span>.<span class="n">o</span> <span class="n">utils</span>.<span class="n">o</span>
        cc -o edit main.o kbd.o command.o display.o <span class="se">\
</span><span class="se"></span>                    insert.o search.o files.o utils.o

<span class="nf">main.o </span><span class="o">:</span> <span class="n">main</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span>
        cc -c main.c
<span class="nf">kbd.o </span><span class="o">:</span> <span class="n">kbd</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">command</span>.<span class="n">h</span>
        cc -c kbd.c
<span class="nf">command.o </span><span class="o">:</span> <span class="n">command</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">command</span>.<span class="n">h</span>
        cc -c command.c
<span class="nf">display.o </span><span class="o">:</span> <span class="n">display</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span>
        cc -c display.c
<span class="nf">insert.o </span><span class="o">:</span> <span class="n">insert</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span>
        cc -c insert.c
<span class="nf">search.o </span><span class="o">:</span> <span class="n">search</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span>
        cc -c search.c
<span class="nf">files.o </span><span class="o">:</span> <span class="n">files</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span> <span class="n">command</span>.<span class="n">h</span>
        cc -c files.c
<span class="nf">utils.o </span><span class="o">:</span> <span class="n">utils</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span>
        cc -c utils.c
<span class="nf">clean </span><span class="o">:</span>
        rm edit main.o kbd.o command.o display.o <span class="se">\
</span><span class="se"></span>            insert.o search.o files.o utils.o
</code></pre></td></tr></table>
</div>
</div><p>反斜杠（\）是命令换行。这样使Makefile更易读。我们可以把这个内容保存在名为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成可执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。</p>
<p>在这个makefile中，目标文件（target）包括可执行文件edit和所有.o文件，依赖文件（prerequisites）就是冒号后面的那些.c文件和.h文件。每一个.o文件都有一组依赖文件，而这些.o文件又是可执行文件edit的依赖文件。依赖关系实质上就是指目标文件是由哪些文件生成的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>
<p>这里要说明一点的是，clean是一个标签，没有任何一个文件依赖clean，make不会自动执行其后的命令。要执行定义在clean后面的命令，就要在make命令后明确地指出clean这个标签的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<h3 id="三make是如何工作的">三、make是如何工作的</h3>
<p>在默认的情况下，也就是我们只输入make命令。那么，</p>
<p>1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。<br>
2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。<br>
3、如果edit文件不存在，或是edit所依赖的后面的.o文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。<br>
4、如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）<br>
5、当然，你的.c文件和.h文件是存在的啦，于是make会生成.o文件，然后再用.o文件生成可执行文件edit。</p>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。</p>
<p>如果一个工程已被编译过了，当我们修改了其中的一个源文件后，比如file.c，根据文件依赖性，目标file.o会被重编译，重编译后file.o的文件修改时间要比edit要新，所以edit也会被重新链接了。</p>
<p>而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p>
<h3 id="四在makefile中使用变量">四、在makefile中使用变量</h3>
<p>在上面的例子中，先让我们看看edit的规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">edit </span><span class="o">:</span> <span class="n">main</span>.<span class="n">o</span> <span class="n">kbd</span>.<span class="n">o</span> <span class="n">command</span>.<span class="n">o</span> <span class="n">display</span>.<span class="n">o</span> \
            <span class="n">insert</span>.<span class="n">o</span> <span class="n">search</span>.<span class="n">o</span> <span class="n">files</span>.<span class="n">o</span> <span class="n">utils</span>.<span class="n">o</span>
    cc -o edit main.o kbd.o command.o display.o <span class="se">\
</span><span class="se"></span>                insert.o search.o files.o utils.o
</code></pre></td></tr></table>
</div>
</div><p>我们可以看到.o文件被重复了两次，如果我们的工程需要加入一个新的.o文件，那么我们需要在两个地方添加（应该是三个地方，还有一个地方在clean中）。如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。为了使makefile更容易维护，在makefile中我们可以使用变量。</p>
<p>比如，我们要声明一个变量，我们在makefile一开始这样定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">=</span> main.o kbd.o command.o display.o <span class="se">\
</span><span class="se"></span>        insert.o search.o files.o utils.o
</code></pre></td></tr></table>
</div>
</div><p>接下来，我们可以很方便地在我们的makefile中以<code>$(objects)</code>的方式来使用这个变量，于是我们的改良版makefile就变成下面这个样子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">=</span> main.o kbd.o command.o display.o <span class="se">\
</span><span class="se"></span>            insert.o search.o files.o utils.o

<span class="nf">edit </span><span class="o">:</span> <span class="k">$(</span><span class="nv">objects</span><span class="k">)</span>
        cc -o edit <span class="k">$(</span>objects<span class="k">)</span>
<span class="nf">main.o </span><span class="o">:</span> <span class="n">main</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span>
        cc -c main.c
<span class="nf">kbd.o </span><span class="o">:</span> <span class="n">kbd</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">command</span>.<span class="n">h</span>
        cc -c kbd.c
<span class="nf">command.o </span><span class="o">:</span> <span class="n">command</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">command</span>.<span class="n">h</span>
        cc -c command.c
<span class="nf">display.o </span><span class="o">:</span> <span class="n">display</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span>
        cc -c display.c
<span class="nf">insert.o </span><span class="o">:</span> <span class="n">insert</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span>
        cc -c insert.c
<span class="nf">search.o </span><span class="o">:</span> <span class="n">search</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span>
        cc -c search.c
<span class="nf">files.o </span><span class="o">:</span> <span class="n">files</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span> <span class="n">command</span>.<span class="n">h</span>
        cc -c files.c
<span class="nf">utils.o </span><span class="o">:</span> <span class="n">utils</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span>
        cc -c utils.c
<span class="nf">clean </span><span class="o">:</span>
        rm edit <span class="k">$(</span>objects<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果有新的.o文件加入，我们只需简单地修改一下 objects 变量就可以了。</p>
<p><strong>有四种定义变量/为变量赋值的方法</strong>：(参考<a href="https://www.cnblogs.com/wanqieddy/archive/2011/09/21/2184257.html" target="_blank" rel="noopener noreffer">Makefile 中:= ?= += =的区别</a>
  )</p>
<ol>
<li>=，使用最后一个=定义的值作为全局的值</li>
<li>:=，覆盖之前的值，并作为当前值</li>
<li>?=，如果没有被赋值过就赋予等号后面的值</li>
<li>+=，添加等号后面的值</li>
</ol>
<p>“=”和“:=”的区别:<br>
1、“=”<br>
make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。看例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">x</span> <span class="o">=</span> foo
<span class="nv">y</span> <span class="o">=</span> <span class="k">$(</span>x<span class="k">)</span> bar
<span class="nv">x</span> <span class="o">=</span> xyz
</code></pre></td></tr></table>
</div>
</div><p>在上例中，y的值将会是 xyz bar ，而不是 foo bar 。</p>
<p>2、“:=”<br>
“:=”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">x</span> <span class="o">:=</span> foo
<span class="nv">y</span> <span class="o">:=</span> <span class="k">$(</span>x<span class="k">)</span> bar
<span class="nv">x</span> <span class="o">:=</span> xyz
</code></pre></td></tr></table>
</div>
</div><p>在上例中，y的值将会是 foo bar ，而不是 xyz bar。</p>
<h3 id="五make自动推导">五、make自动推导</h3>
<p>make很强大，它可以自动推导文件以及文件依赖关系后面的命令。我们没必要去在每一个.o文件后都写上类似的命令，因为make会自动识别并自己推导命令。</p>
<p>只要make看到一个.o文件，它就会自动的把.c文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c就会是whatever.o的依赖文件。并且<code>cc -c whatever.c</code>也会被推导出来。于是，我们的makefile再也不用写得那么复杂。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">=</span> main.o kbd.o command.o display.o <span class="se">\
</span><span class="se"></span>            insert.o search.o files.o utils.o

<span class="nf">edit </span><span class="o">:</span> <span class="k">$(</span><span class="nv">objects</span><span class="k">)</span>
        cc -o edit <span class="k">$(</span>objects<span class="k">)</span>

<span class="nf">main.o </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span>
<span class="nf">kbd.o </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">command</span>.<span class="n">h</span>
<span class="nf">command.o </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">command</span>.<span class="n">h</span>
<span class="nf">display.o </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span>
<span class="nf">insert.o </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span>
<span class="nf">search.o </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span>
<span class="nf">files.o </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">buffer</span>.<span class="n">h</span> <span class="n">command</span>.<span class="n">h</span>
<span class="nf">utils.o </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span>

<span class="nf">.PHONY </span><span class="o">:</span> <span class="n">clean</span>
<span class="nf">clean </span><span class="o">:</span>
        rm edit <span class="k">$(</span>objects<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。</p>
<h3 id="六多个目标文件依赖相同的文件">六、多个目标文件依赖相同的文件</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">=</span> main.o kbd.o command.o display.o <span class="se">\
</span><span class="se"></span>            insert.o search.o files.o utils.o

<span class="nf">edit </span><span class="o">:</span> <span class="k">$(</span><span class="nv">objects</span><span class="k">)</span>
        cc -o edit <span class="k">$(</span>objects<span class="k">)</span>

<span class="nf">$(objects) </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span>
<span class="nf">kbd.o command.o files.o </span><span class="o">:</span> <span class="n">command</span>.<span class="n">h</span>
<span class="nf">display.o insert.o search.o files.o </span><span class="o">:</span> <span class="n">buffer</span>.<span class="n">h</span>

<span class="nf">.PHONY </span><span class="o">:</span> <span class="n">clean</span>
<span class="nf">clean </span><span class="o">:</span>
        rm edit <span class="k">$(</span>objects<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="七清空目标文件的规则clean">七、清空目标文件的规则（clean）</h3>
<p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也利于保持文件的清洁。一般的风格都是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">clean</span><span class="o">:</span>
    rm edit <span class="k">$(</span>objects<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>更为稳健的做法是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">.PHONY </span><span class="o">:</span> <span class="n">clean</span>
<span class="nf">clean </span><span class="o">:</span>
    -rm edit <span class="k">$(</span>objects<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>前面说过，.PHONY表示clean是一个“伪目标”。</p>
<p>在rm命令前面加了一个小减号的意思就是，如果这条命令执行出错了，则忽略这个错误，继续执行后面的命令。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标。不成文的规矩是——“clean从来都是放在文件的最后”。</p>
<h2 id="更详细的makefile介绍">更详细的Makefile介绍</h2>
<h3 id="一makefile里有什么">一、Makefile里有什么</h3>
<p>Makefile里主要包含了五种东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p>
<p>1、显式规则。显式规则说明了如何生成一个或多个目标文件。这要由Makefile的书写者明确指出要生成的文件、文件的依赖文件和命令。</p>
<p>2、隐晦规则。make有自动推导的功能，所以隐晦规则可以让我们简略地书写Makefile。</p>
<p>3、变量定义。在Makefile中我们要定义一系列变量，变量一般都是字符串。这个有点像C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</p>
<p>4、文件指示。有三类文件指示：（1）在一个Makefile中引用另一个Makefile，就像C语言中的include一样；（2）指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；（3）定义一个多行的命令。这一部分的内容后面再说。</p>
<p>5、注释。Makefile中只有行注释。和UNIX的Shell脚本一样，注释是用“#”字符，如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“<code>\#</code>”。</p>
<p>最后，值得一提的是，Makefile中的命令必须要以Tab键开始。</p>
<h3 id="二makefile命名">二、Makefile命名</h3>
<p>默认情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“&ndash;file”参数，如：<code>make -f Make.Linux</code>或<code>make --file Make.AIX</code>。</p>
<h3 id="三引用其它makefile">三、引用其它Makefile</h3>
<p>在Makefile使用include关键字可以把别的Makefile包含进来，被包含的文件会被原模原样的放在当前文件的包含位置。include的语法是:<br>
<code>include {filename}</code><br>
filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）。<br>
include前面可以有一些空字符，但绝不能以Tab键开始。include和{filename}可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量<code>$(bar)</code>，其包含了e.mk和f.mk，那么，下面的语句：<br>
<code>include foo.make *.mk $(bar)</code><br>
等价于：<br>
<code>include foo.make a.mk b.mk c.mk e.mk f.mk</code></p>
<p>make命令开始时，会查找include所指出的其它Makefile，并把其内容安置在当前的位置。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：<br>
1、如果make执行时有“-I”或“&ndash;include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。<br>
2、如果目录{prefix}/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</p>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重新查找这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：<br>
<code>-include {filename}</code><br>
其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p>
<h3 id="四环境变量makefiles">四、环境变量MAKEFILES</h3>
<p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>
<p>在这里我建议不要使用这个环境变量，因为这个变量一旦被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h3 id="五makefile的执行步骤">五、makefile的执行步骤</h3>
<p>make工作时的执行步骤如下：（其它的make也是类似的）<br>
1、读入所有的Makefile。<br>
2、读入被include的其它Makefile。<br>
3、初始化文件中的变量。<br>
4、推导隐晦规则，并分析所有规则。<br>
5、为所有的目标文件创建依赖关系链。<br>
6、根据依赖关系，决定哪些目标要重新生成。<br>
7、执行生成命令。</p>
<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么make会把其展开在使用的位置。但make并不会把变量马上完全展开，make使用的是拖延策略，如果变量出现在依赖关系的规则中，那么仅当这条规则被决定要使用了，变量才会在其内部展开。</p>
<h2 id="更更详细的makefile的介绍">更更详细的makefile的介绍</h2>
<p>规则包含两个部分，一个是依赖关系，一个是生成目标的命令。</p>
<p>在Makefile中，规则的顺序是很重要的，因为Makefile中应该只有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被默认确立为最终的目标。如果第一条规则中的目标有很多个，那么第一个目标会默认成为最终的目标。</p>
<h3 id="一规则举例">一、规则举例</h3>
<p>略</p>
<h3 id="二规则的语法">二、规则的语法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">targets </span><span class="o">:</span> <span class="n">prerequisites</span>
        <span class="nb">command</span>
        ...
</code></pre></td></tr></table>
</div>
</div><p>或是这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">targets </span><span class="o">:</span> <span class="n">prerequisites</span> ; <span class="n">command</span>
        <span class="nb">command</span>
        ...
</code></pre></td></tr></table>
</div>
</div><p>command是命令行，如果其不与“target:prerequisites”在一行，那么必须以Tab键开头，如果和prerequisites在一行，那么可以用分号做为分隔。这两种写法的含义是不同的。</p>
<h3 id="三在规则中使用通配符">三、在规则中使用通配符</h3>
<p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三种通配符：“*”，“?”和“[&hellip;]”。这是和Unix的B-Shell是相同的。</p>
<p>如果要在文件名中使用“*”字符，可以在前面加上转义字符“\”。</p>
<p>先来看几个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">clean</span><span class="o">:</span>
        rm -f *.o
</code></pre></td></tr></table>
</div>
</div><p>上面这个例子是在命令中的通配符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">print</span><span class="o">:</span> *.<span class="n">c</span>
        lpr -p <span class="nv">$?</span>
        touch print
</code></pre></td></tr></table>
</div>
</div><p>上面这个例子说明了通配符也可以用在规则中，目标print依赖于所有的.c文件。其中的“<code>$?</code>”是一个自动化变量（会列出所有比目标新的依赖文件（可以理解成只列出更新过的依赖）），我们会在后面讨论。</p>
<p>如果将通配符用在变量中，例如<code>objects = *.o</code>。<code>*.o</code>并不会展开，objects的值就是“<code>*.o</code>”！Makefile中的变量类似于C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有.o文件的集合，那么可以这样：</p>
<p><code>objects := $(wildcard *.o)</code></p>
<p>这种用法由关键字“wildcard”指出。关于Makefile的关键字，我们将在后面讨论。</p>
<h3 id="四文件搜索"><strong>四、文件搜索</strong></h3>
<p><strong>注意：vpath只对查找文件的依赖关系有效。即，依赖中的文件名不需要写全路径，而命令中的文件名还是要写全路径！！！</strong><br>
一些大的工程中有大量的源文件，我们通常的做法是把这些源文件分类并存放在不同的目录中。所以，当make需要去查找文件的依赖关系时，你可以在文件前加上路径（<strong>必须要在依赖文件和命令中的文件名前都加上路径才行！</strong>），但最好的方法是把一个路径告诉make，让make在自动去找。</p>
<p>Makefile文件中的特殊变量“VPATH”就是用来完成这个功能的，如果没有定义这个变量，make只会在当前目录中去查找依赖文件。如果定义了这个变量，那么make就会在当前目录找不到的情况下，到指定的目录中去查找文件了。</p>
<p><code>VPATH = src:../headers</code></p>
<p>上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“:”分隔。（当前目录永远是最优先搜索的目录。）</p>
<p>另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的）。这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定在不同的搜索目录中搜索不同的文件。这是一个很灵活的功能。它的使用方法有三种：</p>
<p>1、<code>vpath {pattern} {directories}</code><br>
为符合模式{pattern}的文件指定搜索目录{directories}。</p>
<p>2、<code>vpath {pattern}</code><br>
清除符合模式{pattern}的文件的搜索目录。</p>
<p>3、<code>vpath</code><br>
清除所有已被设置好了的文件搜索目录。</p>
<p>{pattern}需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。{pattern}指定了要搜索的文件集，而{directories}则指定了{pattern}的文件集的搜索的目录。例如：</p>
<p><code>vpath %.h ../headers</code></p>
<p>该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）</p>
<p>我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的{pattern}，或是被重复了的{pattern}，那么，make会按照vpath语句的先后顺序来执行搜索。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">vpath</span> <span class="err">%.c</span> <span class="err">foo</span>
<span class="err">vpath</span> <span class="err">%</span> <span class="err">blish</span>
<span class="err">vpath</span> <span class="err">%.c</span> <span class="err">bar</span>
</code></pre></td></tr></table>
</div>
</div><p>其表示“.c”结尾的文件，先在“foo”目录搜索，然后是“blish”，最后是“bar”目录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">vpath %.c foo</span><span class="o">:</span><span class="n">bar</span>
<span class="err">vpath</span> <span class="err">%</span>   <span class="err">blish</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的语句表示“.c”结尾的文件，先在“foo”目录搜索，然后是“bar”目录，最后才是“blish”目录。</p>
<h3 id="五伪目标">五、伪目标</h3>
<p>在最开始的一个例子中，我们提到过一个名为“clean”的目标，这是一个“伪目标”，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">clean</span><span class="o">:</span>
        rm *.o temp
</code></pre></td></tr></table>
</div>
</div><p>“伪目标”并不是一个文件，只是一个标签，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。“伪目标”的取名不能和文件名重名，不然就失去了“伪目标”的意义了。</p>
<p>为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p>
<p>整个过程可以这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">.PHONY</span><span class="o">:</span> <span class="n">clean</span>
<span class="nf">clean</span><span class="o">:</span>
        rm *.o temp
</code></pre></td></tr></table>
</div>
</div><p>我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个例子就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">all </span><span class="o">:</span> <span class="n">prog</span>1 <span class="n">prog</span>2 <span class="n">prog</span>3
<span class="nf">.PHONY </span><span class="o">:</span> <span class="n">all</span>

<span class="nf">prog1 </span><span class="o">:</span> <span class="n">prog</span>1.<span class="n">o</span> <span class="n">utils</span>.<span class="n">o</span>
        cc -o prog1 prog1.o utils.o

<span class="nf">prog2 </span><span class="o">:</span> <span class="n">prog</span>2.<span class="n">o</span>
        cc -o prog2 prog2.o

<span class="nf">prog3 </span><span class="o">:</span> <span class="n">prog</span>3.<span class="n">o</span> <span class="n">sort</span>.<span class="n">o</span> <span class="n">utils</span>.<span class="n">o</span>
        cc -o prog3 prog3.o sort.o utils.o
</code></pre></td></tr></table>
</div>
</div><p>伪目标同样也可成为依赖。看下面的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">.PHONY</span><span class="o">:</span> <span class="n">cleanall</span> <span class="n">cleanobj</span> <span class="n">cleandiff</span>

<span class="nf">cleanall </span><span class="o">:</span> <span class="n">cleanobj</span> <span class="n">cleandiff</span>
        rm program

<span class="nf">cleanobj </span><span class="o">:</span>
        rm *.o

<span class="nf">cleandiff </span><span class="o">:</span>
        rm *.diff
</code></pre></td></tr></table>
</div>
</div><p>“make cleanall”将清除所有要被清除的文件。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。</p>
<h3 id="六多个目标依赖相同的文件">六、多个目标依赖相同的文件</h3>
<p>Makefile的一个规则中的可以有多个目标。有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似，于是我们就能把其合并起来。</p>
<p>多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过我们可以使用一个自动化变量“$@”，这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，看一个例子吧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">bigoutput littleoutput </span><span class="o">:</span> <span class="n">text</span>.<span class="n">g</span>
        generate text.g -<span class="k">$(</span>subst output,,<span class="nv">$@</span><span class="k">)</span> &gt; <span class="nv">$@</span>
</code></pre></td></tr></table>
</div>
</div><p>上述规则等价于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">bigoutput </span><span class="o">:</span> <span class="n">text</span>.<span class="n">g</span>
        generate text.g -big &gt; bigoutput
<span class="nf">littleoutput </span><span class="o">:</span> <span class="n">text</span>.<span class="n">g</span>
        generate text.g -little &gt; littleoutput
</code></pre></td></tr></table>
</div>
</div><p>其中，<code>-$(subst output,,$@)</code>中的第一个“<code>$</code>”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。subst这个函数的功能是替换字符串（将参数3中包含的参数1替换为参数2），“<code>$@</code>”表示目标的集合，就像一个数组，“<code>$@</code>”依次取出目标，并执于命令。</p>
<h3 id="七多目标的静态模式">七、多目标的静态模式</h3>
<p>使用静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更有弹性和灵活性。我们先来看一下语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">{targets ...}</span><span class="o">:</span> {<span class="n">target</span>-<span class="n">pattern</span>}: {<span class="n">prereq</span>-<span class="n">patterns</span> ...}
        <span class="o">{</span>commands<span class="o">}</span>
        ...
</code></pre></td></tr></table>
</div>
</div><p>targets定义了一系列目标文件，可以有通配符，是目标的一个集合。<br>
target-parrtern指明了targets的模式，也就是目标集模式。<br>
prereq-parrterns是目标的依赖模式，它用target-parrtern进行依赖的模式定义。</p>
<p>举个例子来说明一下吧。如果我们的{target-parrtern}定义成“%.o”，意思是{target}集合中都是以“.o”结尾的，而如果我们的{prereq-parrterns}定义成“%.c”，则取{target-parrtern}模式中的“%”（去掉了.o这个结尾），并为其加上.c这个结尾，形成依赖模式。所以“目标模式”和“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义，来使用“%”这个字符。</p>
<p>看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">=</span> foo.o bar.o

<span class="nf">all</span><span class="o">:</span> <span class="k">$(</span><span class="nv">objects</span><span class="k">)</span>

<span class="nf">$(objects)</span><span class="o">:</span> %.<span class="n">o</span>: %.<span class="n">c</span>
        <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> $&lt; -o <span class="nv">$@</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的例子中，指明了目标从$object中获取，目标模式“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”。依赖模式“%.c”取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是我们的依赖目标就是“foo.c bar.c”。</p>
<p>命令中的“<code>$&lt;</code>”和“<code>$@</code>”是自动化变量，（<code>$&lt;</code>表示依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 <code>$&lt;</code> 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。，“<code>$@</code>”表示目标集，也是一个一个取出来的）。于是，上面的规则展开后等价于下面的规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">foo.o </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">c</span>
        <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> foo.c -o foo.o
<span class="nf">bar.o </span><span class="o">:</span> <span class="n">bar</span>.<span class="n">c</span>
        <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> bar.c -o bar.o
</code></pre></td></tr></table>
</div>
</div><p>“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">files</span> <span class="o">=</span> foo.elc bar.o lose.o

<span class="nf">$(filter %.o,$(files))</span><span class="o">:</span> %.<span class="n">o</span>: %.<span class="n">c</span>
        <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> $&lt; -o <span class="nv">$@</span>
<span class="nf">$(filter %.elc,$(files))</span><span class="o">:</span> %.<span class="n">elc</span>: %.<span class="n">el</span>
        emacs -f batch-byte-compile $&lt;
</code></pre></td></tr></table>
</div>
</div><p><code>$(filter %.o,$(files))</code>表示调用Makefile的filter函数，过滤“<code>$files</code>”集，只要其中模式为“%.o”的内容。这个例子展示了Makefile中更大的弹性。</p>
<h3 id="八自动生成头文件依赖">八、自动生成头文件依赖</h3>
<p>在Makefile中，依赖关系可能会包含一系列的头文件。比如，如果main.c中有一句<code>#include &quot;defs.h&quot;</code>，那么依赖关系应该是：</p>
<p><code>main.o : main.c defs.h</code></p>
<p>但是对于一个大型的工程，你必须清楚哪些.c文件包含了哪些头文件。并且，在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：</p>
<p><code>cc -M main.c</code></p>
<p>其输出是：</p>
<p><code>main.o : main.c defs.h</code></p>
<p>这是由编译器自动生成的依赖关系，这样一来，我们就不必再手动书写某些文件的依赖关系，而是由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。</p>
<p>例如<code>gcc -M main.c</code>的输出是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">main.o</span><span class="o">:</span> <span class="n">main</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> /<span class="n">usr</span>/<span class="n">include</span>/<span class="n">stdio</span>.<span class="n">h</span> /<span class="n">usr</span>/<span class="n">include</span>/<span class="n">features</span>.<span class="n">h</span> /
        /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h /
        /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h /
        /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h /
        /usr/include/bits/sched.h /usr/include/libio.h /
        /usr/include/_G_config.h /usr/include/wchar.h /
        /usr/include/bits/wchar.h /usr/include/gconv.h /
        /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h /
        /usr/include/bits/stdio_lim.h
</code></pre></td></tr></table>
</div>
</div><p>而<code>gcc -MM main.c</code>的输出则是：</p>
<p><code>main.o: main.c defs.h</code></p>
<p>那么，如何把编译器的这个功能与我们的Makefile联系在一起呢？GNU建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，即为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，.d文件中就存放对应.c文件的依赖关系。</p>
<p>然后我们可以写出.c文件和.d文件的依赖关系，让make自动更新或生成.d文件，并将其包含在我们的主Makefile中。这样，我们就可以自动化地生成每个文件的依赖关系了。</p>
<p>这里，我们给出了一个模式规则来产生.d文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"> %.d: %.c
    @set -e<span class="p">;</span> rm -f <span class="nv">$@</span><span class="p">;</span> <span class="se">\
</span><span class="se"></span>     <span class="k">$(</span>CC<span class="k">)</span> -M <span class="k">$(</span>CPPFLAGS<span class="k">)</span> $&lt; &gt; <span class="nv">$@</span>.<span class="nv">$$$$</span><span class="p">;</span> <span class="se">\
</span><span class="se"></span>     sed ’s,<span class="se">\(</span><span class="nv">$*</span><span class="se">\)\.</span>o<span class="o">[</span> :<span class="o">]</span>*,<span class="se">\1</span>.o <span class="nv">$@</span> : ,g’ &lt; <span class="nv">$@</span>.<span class="nv">$$$$</span> &gt; <span class="nv">$@</span><span class="p">;</span> <span class="se">\
</span><span class="se"></span>     rm -f <span class="nv">$@</span>.<span class="nv">$$$$</span>
</code></pre></td></tr></table>
</div>
</div><p>这个规则的意思是，所有的.d文件依赖于.c文件，<code>rm -f $@</code>的意思是删除所有的目标，也就是.d文件。第二行的意思是，为每个依赖文件“<code>$&lt;</code>”（也就是.c文件）生成目标文件的依赖，“<code>$@</code>”表示模式“%.d”文件，如果有一个.c文件是name.c，那么“%”就是“name”，<code>“$$$$”</code>生成一个随机编号，第二行生成的文件有可能是“name.d.12345”。第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p>
<p>这里解释一下<code>$</code>这个字符。在makefile中，用<code>$</code>来展开变量或调用函数等等。makefile中有一个开启二级扩展（Enable secondary expansion）的功能，当二级扩展未开启时，连续的两个<code>$</code>，即<code>$$</code>，用来表示<code>$</code>这个字符，类似于在前面加了一个转义字符。当二级扩展开启后，<code>$$</code>这种写法不再有转义字符的含义，如果这时再想使用<code>$</code>这个字符，需要写四个<code>$</code>，即<code>$$$$</code>。</p>
<p>上面这个例子未开启二级扩展，因此<code>$$$$</code>就表示连续的两个<code>$</code>字符，在Unix Shell中，<code>$$</code>表示要输出进程ID，这个例子把进程ID当作随机数使用</p>
<p>以上关于<code>$</code>字符的解释参考<a href="https://stackoverflow.com/questions/1320226/four-dollar-signs-in-makefile" target="_blank" rel="noopener noreffer">Four Dollar signs in Makefile</a>
</p>
<p>上面例子中的sed命令把依赖关系：</p>
<p><code>main.o : main.c defs.h</code></p>
<p>转换为了：</p>
<p><code>main.o main.d : main.c defs.h</code></p>
<p>这样我们的.d文件也会自动生成和自动更新了。当然，你在这个.d文件中可以加入的不只是依赖关系，命令也可一并加入，让每个.d文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">sources</span> <span class="o">=</span> foo.c bar.c
<span class="nf">include $(sources</span><span class="o">:</span>.<span class="n">c</span>=.<span class="n">d</span>)
</code></pre></td></tr></table>
</div>
</div><p>上述语句中的<code>“$(sources:.c=.d)”</code>中的“.c=.d”的意思是做一个替换，把变量<code>$(sources)</code>中所有.c字串都替换成.d。当然，你得注意次序，因为include是按次来载入文件，最先载入的.d文件中的目标会成为默认目标。</p>
<h2 id="书写命令">书写命令</h2>
<p>规则中的命令和Shell的命令是一致的。make会按顺序一条一条的执行命令，每条命令的开头必须以Tab键开头，除非命令是紧跟在依赖规则后面的分号后的。在命令之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p>
<p>我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的，除非你指定一个其它Shell。Makefile中“#”是注释符。</p>
<h3 id="一显示命令">一、显示命令</h3>
<p>通常，make会把要执行的命令输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：</p>
<p><code>@echo 正在编译XXX模块......</code></p>
<p>当make执行时，会输出“正在编译XXX模块&hellip;&hellip;”，但不会输出命令本身，如果没有“@”，那么，make将输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">echo 正在编译XXX模块......`
正在编译XXX模块......
</code></pre></td></tr></table>
</div>
</div><p>如果make执行时，带入make参数“-n”或“&ndash;just-print”，那么make只是显示命令，但不会执行命令。这个功能有利于我们调试Makefile，看看我们书写的命令是以什么顺序执行的。</p>
<p>而make参数“-s”或“&ndash;slient”则是全面禁止命令的显示。</p>
<h3 id="二命令执行">二、命令执行</h3>
<p>当依赖比目标更新时，也就是当规则中的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，**如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。**比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：</p>
<p>示例一：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">exec</span><span class="o">:</span>
        <span class="nb">cd</span> /home/hchen
        <span class="nb">pwd</span>
</code></pre></td></tr></table>
</div>
</div><p>示例二：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">exec</span><span class="o">:</span>
        <span class="nb">cd</span> /home/hchen<span class="p">;</span> <span class="nb">pwd</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</p>
<p>make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。</p>
<h3 id="三命令出错">三、命令出错</h3>
<p>每当命令运行完后，make会检测每个命令的返回码。如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p>
<p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p>
<p>为了忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">clean</span><span class="o">:</span>
        -rm -f *.o
</code></pre></td></tr></table>
</div>
</div><p>还有一个全局的办法是，给make加上“-i”或是“&ndash;ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>
<p>还要提一下make的参数“-k”或“&ndash;keep-going”，这两个参数表示，如果规则中的命令出错了，那么就终止该规则的执行，继续执行其它规则。</p>
<h3 id="四嵌套执行make">四、嵌套执行make</h3>
<p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">subsystem</span><span class="o">:</span>
        <span class="nb">cd</span> subdir <span class="o">&amp;&amp;</span> <span class="k">$(</span>MAKE<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>其等价于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">subsystem</span><span class="o">:</span>
        <span class="k">$(</span>MAKE<span class="k">)</span> -C subdir
</code></pre></td></tr></table>
</div>
</div><p>定义<code>$(MAKE)</code>宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。</p>
<p>我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（通过显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。</p>
<p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：</p>
<p><code>export {variable ...}</code></p>
<p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：</p>
<p><code>unexport {variable ...}</code></p>
<p>如：
示例一：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="k">export </span><span class="nv">variable</span> <span class="o">=</span> value

<span class="err">等价于：</span>
<span class="nv">variable</span> <span class="o">=</span> value
<span class="k">export</span> <span class="nv">variable</span>

<span class="err">等价于：</span>
<span class="k">export </span><span class="nv">variable</span> <span class="o">:=</span> value

<span class="err">等价于：</span>
<span class="nv">variable</span> <span class="o">:=</span> value
<span class="k">export</span> <span class="nv">variable</span>
</code></pre></td></tr></table>
</div>
</div><p>示例二：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="k">export </span><span class="nv">variable</span> <span class="o">+=</span> value

<span class="err">等价于：</span>

<span class="nv">variable</span> <span class="o">+=</span> value
<span class="k">export</span> <span class="nv">variable</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你要传递所有的变量，那么只要一个export就行了，后面什么也不用跟。</p>
<p>需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p>
<p>但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">subsystem</span><span class="o">:</span>
        <span class="nb">cd</span> subdir <span class="o">&amp;&amp;</span> <span class="k">$(</span>MAKE<span class="k">)</span> <span class="nv">MAKEFLAGS</span><span class="o">=</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么make时可能会得到让人意想不到的结果。</p>
<p>还有一个在“嵌套执行”中比较有用的参数，“-w”或是“&ndash;print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：</p>
<p>make: Entering directory `/home/hchen/gnu/make'</p>
<p>而在完成下层make后离开目录时，我们会看到：</p>
<p>make: Leaving directory `/home/hchen/gnu/make'</p>
<p>当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“&ndash;slient”）或是“&ndash;no-print-directory”，那么，“-w”总是失效的。</p>
<h3 id="五定义命令包">五、定义命令包</h3>
<p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">define</span> <span class="err">run-yacc</span>
<span class="err">yacc</span> <span class="k">$(</span><span class="nv">firstword</span> <span class="k">$</span>^<span class="k">)</span>
<span class="err">mv</span> <span class="err">y.tab.c</span> <span class="k">$@</span>
<span class="err">endef</span>
</code></pre></td></tr></table>
</div>
</div><p>“run-yacc”是这个命令包的名字。命令包的名字不能和Makefile中的变量重名。在“define”和“endef”之间的两行就是命令序列。这个命令包中的第一个命令是运行yacc程序，因为yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。下面是一个命令包的使用示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">foo.c </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">y</span>
        <span class="k">$(</span>run-yacc<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，使用命令包就好像使用变量一样。在这个例子中，命令包“run-yacc”中的“<code>$^</code>”就是“foo.y”，“<code>$@</code>”就是“foo.c”（有关这种以“<code>$</code>”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h2 id="使用变量">使用变量</h2>
<p>在Makefile中的定义的变量，就像C/C++中的宏一样，代表了一个文本字串。在Makefile中执行的时候其会展开在所使用的地方。与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖”，“命令”或是Makefile的其它部分中。</p>
<p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。推荐使用大小写搭配的变量名，这样可以避免和系统的变量冲突。</p>
<p>有一些变量是很奇怪字串，如“<code>$&lt;</code>”、“<code>$@</code>”等，这些是自动化变量，会在后面介绍。</p>
<p>有三种变量：环境变量、在make的参数中定义的变量、在makefile中定义的变量。</p>
<p><strong>同名变量优先级：make参数变量 &gt; makefile中的变量 &gt; 环境变量。</strong></p>
<p><strong>嵌套makefile时的变量传递：默认传递make参数变量，用export关键字传递makefile中的变量。这些传递的变量会被下一级makefile看作环境变量。</strong></p>
<h3 id="一变量的基础">一、变量的基础</h3>
<p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“<code>$</code>”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。如果你要使用真实的“<code>$</code>”字符，那么你需要用“<code>$$</code>”来表示。</p>
<p>变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">=</span> program.o foo.o utils.o
<span class="nf">program </span><span class="o">:</span> <span class="k">$(</span><span class="nv">objects</span><span class="k">)</span>
        cc -o program <span class="k">$(</span>objects<span class="k">)</span>

<span class="nf">$(objects) </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span>
</code></pre></td></tr></table>
</div>
</div><p>另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>
<h3 id="二变量中的变量">二、变量中的变量</h3>
<p>我们可以使用其它变量来定义变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>第一种方式是使用“=”号，在“=”左侧是变量，右侧是变量的值。右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">foo</span> <span class="o">=</span> <span class="k">$(</span>bar<span class="k">)</span>
<span class="nv">bar</span> <span class="o">=</span> <span class="k">$(</span>ugh<span class="k">)</span>
<span class="nv">ugh</span> <span class="o">=</span> Huh?

<span class="nf">all</span><span class="o">:</span>
        <span class="nb">echo</span> <span class="k">$(</span>foo<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>我们执行“make all”将会打出变量<code>$(foo)</code>的值是“Huh?”（ <code>$(foo)</code>的值是<code>$(bar)</code>，<code>$(bar)</code>的值是<code>$(ugh)</code>，<code>$(ugh)</code>的值是“Huh?”）可见，用“=”定义的变量是可以使用后面定义的变量来定义的。</p>
<p>这种形式有不好的地方，那就是递归定义，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">CFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> -O

<span class="err">或：</span>

<span class="nv">A</span> <span class="o">=</span> <span class="k">$(</span>B<span class="k">)</span>
<span class="nv">B</span> <span class="o">=</span> <span class="k">$(</span>A<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这会让make陷入无限的变量展开过程中去。当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上述问题，我们可以使用make中另一种方法定义变量。这种方法使用的是“:=”操作符，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">x</span> <span class="o">:=</span> foo
<span class="nv">y</span> <span class="o">:=</span> <span class="k">$(</span>x<span class="k">)</span> bar
<span class="nv">x</span> <span class="o">:=</span> later

<span class="err">其等价于：</span>

<span class="nv">y</span> <span class="o">:=</span> foo bar
<span class="nv">x</span> <span class="o">:=</span> later
</code></pre></td></tr></table>
</div>
</div><p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">y</span> <span class="o">:=</span> <span class="k">$(</span>x<span class="k">)</span> bar
<span class="nv">x</span> <span class="o">:=</span> foo
</code></pre></td></tr></table>
</div>
</div><p>那么，y的值是“bar”，而不是“foo bar”。</p>
<p>上面都是一些简单的变量使用，让我们来看一个复杂的例子。这个例子中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">ifeq</span> <span class="err">(0,${MAKELEVEL})</span>
<span class="nv">cur-dir</span>   <span class="o">:=</span> <span class="k">$(</span>shell <span class="nb">pwd</span><span class="k">)</span>
<span class="nv">whoami</span>    <span class="o">:=</span> <span class="k">$(</span>shell whoami<span class="k">)</span>
<span class="nv">host-type</span> <span class="o">:=</span> <span class="k">$(</span>shell arch<span class="k">)</span>
<span class="nv">MAKE</span> <span class="o">:=</span> <span class="si">${</span><span class="nv">MAKE</span><span class="si">}</span> host-type<span class="o">=</span><span class="si">${</span><span class="nv">host</span><span class="p">-type</span><span class="si">}</span> <span class="nv">whoami</span><span class="o">=</span><span class="si">${</span><span class="nv">whoami</span><span class="si">}</span>
<span class="err">endif</span>
</code></pre></td></tr></table>
</div>
</div><p>关于条件表达式和函数，我们在后面再说。对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。</p>
<p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">nullstring</span> <span class="o">:=</span>
<span class="nv">space</span> <span class="o">:=</span> <span class="k">$(</span>nullstring<span class="k">)</span>  <span class="c1">#end of the line</span>

<span class="err">或者：</span>
<span class="nv">nullstring</span> <span class="o">:=</span>
<span class="nv">space</span> <span class="o">:=</span> <span class="k">$(</span>nullstring<span class="k">)</span> <span class="k">$(</span>nullstring<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>nullstring是一个空变量，其中什么也没有，而我们的space的值是一个空格。在操作符的右边是很难描述一个空格的，但这里采用的技术很管用。先用一个空变量标明变量的值开始了，后面采用“#”注释符来表示变量定义的终止。这样，我们可以定义出值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</p>
<p><code>dir :=/foo/bar    #directory to put the frobs in</code></p>
<p>dir这个变量的值是“/foo/bar    ”，注意后面还跟了4个空格。如果我们使用这样的变量来指定目录——<code>“$(dir)/file”</code>那么就完蛋了。</p>
<p>还有一个比较有用的操作符是“?=”。例如：FOO ?= bar。其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">ifeq</span> <span class="err">(</span><span class="k">$(</span><span class="nv">origin</span> <span class="nv">FOO</span><span class="k">)</span><span class="err">,</span> <span class="err">undefined)</span>
    <span class="nv">FOO</span> <span class="o">=</span> bar
<span class="err">endif</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="三变量高级用法">三、变量高级用法</h3>
<p>这里介绍两种变量的高级使用方法。第一种方法是变量值的替换，格式是<code>“$(var:a=b)”</code>或是<code>“${var:a=b}”</code>，意思是，把变量“var”中所有以“a”结尾的字符串替换成“b”字符串。这里的“结尾”意思是后面是“空格”或“结束符”。</p>
<p>看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">foo</span> <span class="o">:=</span> a.o b.o c.o
<span class="nv">bar</span> <span class="o">:=</span> <span class="k">$(</span>foo:.o<span class="o">=</span>.c<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这个示例中，我们先定义了一个<code>“$(foo)”</code>变量，第二行是把<code>“$(foo)”</code>中结尾的“.o”全部替换成“.c”，所以我们的<code>“$(bar)”</code>的值就是“a.c b.c c.c”。</p>
<p>另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">foo</span> <span class="o">:=</span> a.o b.o c.o
<span class="nv">bar</span> <span class="o">:=</span> <span class="k">$(</span>foo:%.o<span class="o">=</span>%.c<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让<code>$(bar)</code>变量的值为“a.c b.c c.c”。</p>
<p>第二种高级用法是——“把变量的值再当成变量”。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">x</span> <span class="o">=</span> y
<span class="nv">y</span> <span class="o">=</span> z
<span class="nv">a</span> <span class="o">:=</span> <span class="k">$($(</span>x<span class="k">))</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个例子中，<code>$(x)</code>的值是“y”，所以<code>$($(x))</code>就是<code>$(y)</code>，于是<code>$(a)</code>的值就是“z”。（注意，是“x=y”，而不是<code>“x=$(y)”</code>）</p>
<p>还可以使用更多的层次：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">x</span> <span class="o">=</span> y
<span class="nv">y</span> <span class="o">=</span> z
<span class="nv">z</span> <span class="o">=</span> u
<span class="nv">a</span> <span class="o">:=</span> <span class="k">$($($(</span>x<span class="k">)))</span>
</code></pre></td></tr></table>
</div>
</div><p>再复杂一点，我们在变量定义中加上函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">x</span> <span class="o">=</span> variable1
<span class="nv">variable2</span> <span class="o">:=</span> Hello
<span class="nv">y</span> <span class="o">=</span> <span class="k">$(</span>subst 1,2,<span class="k">$(</span>x<span class="k">))</span>
<span class="nv">z</span> <span class="o">=</span> y
<span class="nv">a</span> <span class="o">:=</span> <span class="k">$($($(</span>z<span class="k">)))</span>
</code></pre></td></tr></table>
</div>
</div><p>这个例子中，<code>$($($(z)))</code>扩展为<code>$($(y))</code>，而其再次被扩展为<code>$($(subst 1,2,$(x)))</code>。<code>$(x)</code>的值是<code>variable1</code>，<code>subst</code>函数把<code>variable1</code>中的所有<code>1</code>字串替换成<code>2</code>字串，于是，<code>variable1</code>变成<code>variable2</code>，再取其值，所以，最终，<code>$(a)</code>的值就是<code>$(variable2)</code>的值——<code>Hello</code>。（喔，好不容易）</p>
<p><strong>也可以使用多个变量来组成一个变量的名字，然后再取其值：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">first_second</span> <span class="o">=</span> Hello
<span class="nv">a</span> <span class="o">=</span> first
<span class="nv">b</span> <span class="o">=</span> second
<span class="nv">all</span> <span class="o">=</span> <span class="k">$(</span><span class="nv">$a_$b</span><span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这里的<code>“$a_$b”</code>组成了“first_second”，于是，<code>$(all)</code>的值就是“Hello”。</p>
<p>再来看一个变量、函数与条件语句一同使用的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">ifdef</span> <span class="err">do_sort</span>
<span class="nv">func</span> <span class="o">:=</span> sort
<span class="err">else</span>
<span class="nv">func</span> <span class="o">:=</span> strip
<span class="err">endif</span>

<span class="nv">bar</span> <span class="o">:=</span> a d b g q c
<span class="nv">foo</span> <span class="o">:=</span> <span class="k">$($(</span>func<span class="k">)</span> <span class="k">$(</span>bar<span class="k">))</span>
</code></pre></td></tr></table>
</div>
</div><p>这个示例中，如果定义了“do_sort”，那么<code>foo := $(sort a d b g q c)</code>，于是<code>$(foo)</code>的值就是“a b c d g q”，而如果没有定义“do_sort”，那么<code>foo := $(sort a d b g q c)</code>调用的就是strip函数。</p>
<p><strong>“把变量的值再当成变量”这种用法，同样可以用在操作符的左边：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">dir</span> <span class="o">=</span> foo
<span class="nv">$(dir)_sources</span> <span class="o">:=</span> <span class="k">$(</span>wildcard <span class="k">$(</span>dir<span class="k">)</span>/*.c<span class="k">)</span>
<span class="err">define</span> <span class="k">$(</span><span class="nv">dir</span><span class="k">)</span><span class="err">_print</span>
<span class="err">lpr</span> <span class="k">$($(</span><span class="nv">dir</span><span class="k">)</span><span class="nv">_sources</span><span class="k">)</span>
<span class="err">endef</span>
</code></pre></td></tr></table>
</div>
</div><p>这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。</p>
<h3 id="四追加变量值">四、追加变量值</h3>
<p>我们可以使用“+=”操作符给变量追加值，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">=</span> main.o foo.o bar.o utils.o
<span class="nv">objects</span> <span class="o">+=</span> another.o
</code></pre></td></tr></table>
</div>
</div><p>于是，我们的<code>$(objects)</code>值变成了“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）。</p>
<p>上面这个例子等价于下面这种写法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">=</span> main.o foo.o bar.o utils.o
<span class="nv">objects</span> <span class="o">:=</span> <span class="k">$(</span>objects<span class="k">)</span> another.o
</code></pre></td></tr></table>
</div>
</div><p>所不同的是，使用“+=”更为简洁。</p>
<p>如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">variable</span> <span class="o">:=</span> value
<span class="nv">variable</span> <span class="o">+=</span> more
</code></pre></td></tr></table>
</div>
</div><p>等价于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">variable</span> <span class="o">:=</span> value
<span class="nv">variable</span> <span class="o">:=</span> <span class="k">$(</span>variable<span class="k">)</span> more
</code></pre></td></tr></table>
</div>
</div><p>但如果是这种情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">variable</span> <span class="o">=</span> value
<span class="nv">variable</span> <span class="o">+=</span> more
</code></pre></td></tr></table>
</div>
</div><p>由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义吗，这是我们不希望看到的，所幸make会为我们解决这个问题。</p>
<h3 id="五override指示符">五、override指示符</h3>
<p>**如果有变量是通过make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。**如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p>
<p><code>override {variable} = {value}</code><br>
或
<code>override {variable} := {value}</code><br>
或
<code>override {variable} += {more text}</code></p>
<p>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用overide指示符，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">override</span> <span class="err">define</span> <span class="err">foo</span>
<span class="err">bar</span>
<span class="err">endef</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="六多行变量">六、多行变量</h3>
<p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用define实现的）。</p>
<p>define后面跟的是变量的名字，以endef关键字结束定义。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以Tab键开头，所以如果你用define定义的命令变量中没有以Tab键开头，那么make就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">define</span> <span class="err">two-lines</span>
<span class="err">echo</span> <span class="err">foo</span>
<span class="err">echo</span> <span class="k">$(</span><span class="nv">bar</span><span class="k">)</span>
<span class="err">endef</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="七环境变量">七、环境变量</h3>
<p><strong>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。</strong>（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，很像“全局变量”和“局部变量”的特性。</p>
<p><strong>当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。</strong></p>
<h3 id="八目标变量">八、目标变量</h3>
<p>在Makefile中定义的变量都是“全局变量”，在整个文件中都可以访问这些变量。然而“自动化变量”除外，例如<code>“$&lt;”</code>这样的变量。自动化变量属于“规则型变量”，这种变量的值依赖于规则的目标和依赖的定义。</p>
<p>我样同样可以为某个目标设置局部变量，这种变量被称为目标变量（Target-specific Variable），它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以它的值也只在作用范围内有效，不会影响规则链以外的“全局变量”的值。</p>
<p>目标变量的语法是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">{target ...} </span><span class="o">:</span> {<span class="n">variable</span>-<span class="n">assignment</span>}
<span class="err">或</span>
<span class="nf">{target ...} </span><span class="o">:</span> <span class="n">override</span> {<span class="n">variable</span>-<span class="n">assignment</span>}
</code></pre></td></tr></table>
</div>
</div><p>{variable-assignment}可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”和“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">prog </span><span class="o">:</span> <span class="n">CFLAGS</span> = -<span class="n">g</span>
<span class="nf">prog </span><span class="o">:</span> <span class="n">prog</span>.<span class="n">o</span> <span class="n">foo</span>.<span class="n">o</span> <span class="n">bar</span>.<span class="n">o</span>
        <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> prog.o foo.o bar.o

<span class="nf">prog.o </span><span class="o">:</span> <span class="n">prog</span>.<span class="n">c</span>
        <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> prog.c

<span class="nf">foo.o </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">c</span>
        <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> foo.c

<span class="nf">bar.o </span><span class="o">:</span> <span class="n">bar</span>.<span class="n">c</span>
        <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> bar.c
</code></pre></td></tr></table>
</div>
</div><p>在这个示例中，不管全局的<code>$(CFLAGS)</code>的值是什么，<strong>在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），<code>$(CFLAGS)</code>的值都是“-g”。</strong></p>
<h3 id="九模式变量">九、模式变量</h3>
<p>在GNU的make中，还支持模式变量（Pattern-specific Variable）。通过目标变量我们可以了解到变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以.o结尾的目标定义目标变量：</p>
<p><code>%.o : CFLAGS = -O</code></p>
<p>同样，模式变量的语法和“目标变量”一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">{pattern ...} </span><span class="o">:</span> {<span class="n">variable</span>-<span class="n">assignment</span>}
<span class="err">或</span>
<span class="nf">{pattern ...} </span><span class="o">:</span> <span class="n">override</span> {<span class="n">variable</span>-<span class="n">assignment</span>}
</code></pre></td></tr></table>
</div>
</div><h2 id="使用条件判断">使用条件判断</h2>
<p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或者是比较变量和常量的值。</p>
<h3 id="一示例">一、示例</h3>
<p>下面的例子，判断<code>$(CC)</code>变量是否等于“gcc”，如果是的话，则使用GNU函数编译目标。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">libs_for_gcc</span> <span class="o">=</span> -lgnu
<span class="nv">normal_libs</span> <span class="o">=</span>
<span class="c">#在规则中使用条件语句
</span><span class="c"></span><span class="nf">foo</span><span class="o">:</span> <span class="k">$(</span><span class="nv">objects</span><span class="k">)</span>
<span class="err">ifeq</span> <span class="err">(</span><span class="k">$(</span><span class="nv">CC</span><span class="k">)</span><span class="err">,gcc)</span>
        <span class="k">$(</span><span class="nv">CC</span><span class="k">)</span> <span class="err">-o</span> <span class="err">foo</span> <span class="k">$(</span><span class="nv">objects</span><span class="k">)</span> <span class="k">$(</span><span class="nv">libs_for_gcc</span><span class="k">)</span>
<span class="err">else</span>
        <span class="k">$(</span><span class="nv">CC</span><span class="k">)</span> <span class="err">-o</span> <span class="err">foo</span> <span class="k">$(</span><span class="nv">objects</span><span class="k">)</span> <span class="k">$(</span><span class="nv">normal_libs</span><span class="k">)</span>
<span class="err">endif</span>
</code></pre></td></tr></table>
</div>
</div><p>在上面的这个例子中，目标“foo”可以根据变量<code>“$(CC)”</code>值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq表示条件语句的开始，并指定一个条件表达式。表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束。</p>
<p>我们可以把上面的那个例子写得更简洁一些：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">libs_for_gcc</span> <span class="o">=</span> -lgnu
<span class="nv">normal_libs</span> <span class="o">=</span>

<span class="c">#在规则外使用条件语句
</span><span class="c"></span><span class="err">ifeq</span> <span class="err">(</span><span class="k">$(</span><span class="nv">CC</span><span class="k">)</span><span class="err">,gcc)</span>
    <span class="nv">libs</span><span class="o">=</span><span class="k">$(</span>libs_for_gcc<span class="k">)</span>
<span class="err">else</span>
    <span class="nv">libs</span><span class="o">=</span><span class="k">$(</span>normal_libs<span class="k">)</span>
<span class="err">endif</span>

<span class="nf">foo</span><span class="o">:</span> <span class="k">$(</span><span class="nv">objects</span><span class="k">)</span>
        <span class="k">$(</span>CC<span class="k">)</span> -o foo <span class="k">$(</span>objects<span class="k">)</span> <span class="k">$(</span>libs<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二语法">二、语法</h3>
<p>条件表达式的语法为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">{conditional-directive}</span>
<span class="err">{text-if-true}</span>
<span class="err">endif</span>

<span class="err">以及：</span>

<span class="err">{conditional-directive}</span>
<span class="err">{text-if-true}</span>
<span class="err">else</span>
<span class="err">{text-if-false}</span>
<span class="err">endif</span>
</code></pre></td></tr></table>
</div>
</div><p>其中{conditional-directive}表示条件语句。条件语句有四个关键字。</p>
<p>第一个是“ifeq”，比较参数“arg1”和“arg2”的值是否相同。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">ifeq</span> <span class="err">({arg1},</span> <span class="err">{arg2})</span>
<span class="err">ifeq</span> <span class="s1">&#39;{arg1}&#39;</span> <span class="s1">&#39;{arg2}&#39;</span>
<span class="err">ifeq</span> <span class="s2">&#34;{arg1}&#34;</span> <span class="s2">&#34;{arg2}&#34;</span>
<span class="err">ifeq</span> <span class="s2">&#34;{arg1}&#34;</span> <span class="s1">&#39;{arg2}&#39;</span>
<span class="err">ifeq</span> <span class="s1">&#39;{arg1}&#39;</span> <span class="s2">&#34;{arg2}&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>我们还可以在参数中使用make的函数。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">ifeq</span> <span class="err">(</span><span class="k">$(</span><span class="nv">strip</span> <span class="k">$(</span><span class="nv">foo</span><span class="k">))</span><span class="err">,)</span>
<span class="err">{text-if-empty}</span>
<span class="err">endif</span>
</code></pre></td></tr></table>
</div>
</div><p>这个示例中使用了“strip”函数，如果这个函数的返回值是空，那么{text-if-empty}就生效。</p>
<p>第二个条件关键字是“ifneq”，和“ifeq”是相反的。语法是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">ifneq</span> <span class="err">({arg1},</span> <span class="err">{arg2})</span>
<span class="err">ifneq</span> <span class="s1">&#39;{arg1}&#39;</span> <span class="s1">&#39;{arg2}&#39;</span>
<span class="err">ifneq</span> <span class="s2">&#34;{arg1}&#34;</span> <span class="s2">&#34;{arg2}&#34;</span>
<span class="err">ifneq</span> <span class="s2">&#34;{arg1}&#34;</span> <span class="s1">&#39;{arg2}&#39;</span>
<span class="err">ifneq</span> <span class="s1">&#39;{arg1}&#39;</span> <span class="s2">&#34;{arg2}&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>第三个条件关键字是“ifdef”。语法是：</p>
<p><code>ifdef {variable-name}</code></p>
<p>如果变量{variable-name}的值非空，那到表达式为真。否则，表达式为假。当然，{variable-name}同样可以是一个函数的返回值。<strong>注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置</strong>。来看两个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="c">#示例一：
</span><span class="c"></span><span class="nv">bar</span> <span class="o">=</span>
<span class="nv">foo</span> <span class="o">=</span> <span class="k">$(</span>bar<span class="k">)</span>
<span class="err">ifdef</span> <span class="err">foo</span>
<span class="nv">frobozz</span> <span class="o">=</span> yes
<span class="err">else</span>
<span class="nv">frobozz</span> <span class="o">=</span> no
<span class="err">endif</span>

<span class="c">#示例二：
</span><span class="c"></span><span class="nv">foo</span> <span class="o">=</span>
<span class="err">ifdef</span> <span class="err">foo</span>
<span class="nv">frobozz</span> <span class="o">=</span> yes
<span class="err">else</span>
<span class="nv">frobozz</span> <span class="o">=</span> no
<span class="err">endif</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>第一个例子中，“<code>$(frobozz)</code>”值是“yes”，第二个则是“no”。</strong></p>
<p>第四个条件关键字是“ifndef”，和“ifdef”是相反的。语法是：</p>
<p><code>ifndef {variable-name}</code></p>
<p>在{conditional-directive}这一行上，多余的空格是被允许的，但是不能以Tab键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也一样，只要不是以Tab键开始就行了。</p>
<p><strong>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“<code>$@</code>”等）放入条件表达式中，因为自动化变量是在运行时才有的。</strong></p>
<p>而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h2 id="使用函数">使用函数</h2>
<h3 id="一函数的调用语法">一、函数的调用语法</h3>
<p>函数调用，和变量的使用一样，也是以<code>“$”</code>来标识的。语法如下：</p>
<p><code>$({function} {arguments})</code></p>
<p>或</p>
<p><code>$&lt;{function} {arguments}}</code></p>
<p>这里，{function}就是函数名，make支持的函数不多。{arguments}是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以<code>“$”</code>开头，以圆括号或花括号把函数名和参数括起。函数中的参数可以使用变量，如<code>“$(subst a,b,$(x))”</code>这样的形式。</p>
<p>来看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">comma</span><span class="o">:=</span> ,
<span class="nv">empty</span><span class="o">:=</span>
<span class="nv">space</span><span class="o">:=</span> <span class="k">$(</span>empty<span class="k">)</span> <span class="k">$(</span>empty<span class="k">)</span>
<span class="nv">foo</span><span class="o">:=</span> a b c
<span class="nv">bar</span><span class="o">:=</span> <span class="k">$(</span>subst <span class="k">$(</span>space<span class="k">)</span>,<span class="k">$(</span>comma<span class="k">)</span>,<span class="k">$(</span>foo<span class="k">))</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个示例中，<code>$(comma)</code>的值是一个逗号。<code>$(space)</code>使用了<code>$(empty)</code>定义了一个空格，<code>$(foo)</code>的值是“a b c”，<code>$(bar)</code>的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把<code>$(foo)</code>中的空格替换成逗号，所以<code>$(bar)</code>的值是“a,b,c”。</p>
<h3 id="二字符串处理函数">二、字符串处理函数</h3>
<ul>
<li>
<p><code>$(subst {from},{to},{text})</code><br>
字符串替换函数。<br>
功能：把字符串{text}中的{from}替换成{to}。<br>
返回：被替换过后的字符串。<br>
示例：<br>
<code>$(subst ee,EE,feet on the street)</code></p>
<p>把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。</p>
</li>
<li>
<p><code>$(patsubst {pattern},{replacement},{text})</code><br>
模式字符串替换函数。<br>
功能：查找{text}中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式{pattern}，如果匹配的话，则以{replacement}替换。{pattern}可以包括通配符“%”，表示任意长度的字串。如果{replacement}中也包含“%”，那么{replacement}中的这个“%”将是{pattern}中的那个“%”所代表的字串。（可以用“\”来转义，以“%”来表示真实含义的“%”字符）<br>
返回：被替换过后的字符串。</p>
<p>示例：<br>
<code>$(patsubst %.c,%.o,x.c.c bar.c)</code></p>
<p>把字符串“x.c.c bar.c”符合模式%.c的单词替换成%.o，返回结果是“x.c.o bar.o”</p>
<p>备注：<br>
这和我们前面“变量”章节说过的相关知识有点相似。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">“$(var</span><span class="o">:</span>{<span class="n">pattern</span>}={<span class="n">replacement</span>})”
<span class="c">#相当于
</span><span class="c"></span><span class="err">“</span><span class="k">$(</span><span class="nv">patsubst</span> {<span class="nv">pattern</span>},{<span class="nv">replacement</span>},<span class="k">$(</span><span class="nv">var</span><span class="k">))</span><span class="err">”，</span>

<span class="nf">“$(var</span><span class="o">:</span> {<span class="n">suffix</span>}={<span class="n">replacement</span>})”
<span class="c">#相当于
</span><span class="c"></span><span class="err">“</span><span class="k">$(</span><span class="nv">patsubst</span> %{<span class="nv">suffix</span>},%{<span class="nv">replacement</span>},<span class="k">$(</span><span class="nv">var</span><span class="k">))</span><span class="err">”。</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>$(strip {string})</code><br>
去空格函数。<br>
功能：去掉{string}字符串中开头和结尾的空字符。<br>
返回：被去掉空格的字符串值。<br>
示例：<br>
<code>$(strip a b c )</code></p>
<p>把字符串“a b c ”去到开头和结尾的空格，结果是“a b c”。</p>
</li>
<li>
<p><code>$(findstring {find},{in})</code><br>
查找字符串函数。<br>
功能：在字串{in}中查找{find}字串。<br>
返回：如果找到，那么返回{find}，否则返回空字符串。<br>
示例：<br>
<code>$(findstring a,a b c)</code><br>
<code>$(findstring a,b c)</code></p>
<p>第一个函数返回“a”字符串，第二个返回空字符串</p>
</li>
<li>
<p><code>$(filter {pattern...},{text})</code><br>
过滤函数。<br>
功能：以{pattern}模式过滤{text}字符串中的单词，保留符合模式{pattern}的单词。可以有多个模式。<br>
返回：符合模式{pattern}的字串。<br>
示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">sources</span> <span class="o">:=</span> foo.c bar.c baz.s ugh.h
<span class="nf">foo</span><span class="o">:</span> <span class="k">$(</span><span class="nv">sources</span><span class="k">)</span>
        cc <span class="k">$(</span>filter %.c %.s,<span class="k">$(</span>sources<span class="k">))</span> -o foo
</code></pre></td></tr></table>
</div>
</div><p>$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。</p>
</li>
<li>
<p><code>$(filter-out {pattern...},{text})</code><br>
反过滤函数。<br>
功能：以{pattern}模式过滤{text}字符串中的单词，去除符合模式{pattern}的单词。可以有多个模式。<br>
返回：不符合模式{pattern}的字符串。<br>
示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span><span class="o">=</span>main1.o foo.o main2.o bar.o
<span class="nv">mains</span><span class="o">=</span>main1.o main2.o

<span class="k">$(</span><span class="nv">filter</span>-<span class="nv">out</span> <span class="k">$(</span><span class="nv">mains</span><span class="k">)</span>,<span class="k">$(</span><span class="nv">objects</span><span class="k">))</span>
<span class="c">#返回值是“foo.o bar.o”。
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>$(sort {list})</code><br>
排序函数。
功能：给字符串{list}中的单词排序（升序），<strong>去掉{list}中相同的单词</strong>。<br>
返回：排序后的字符串。<br>
示例：<code>$(sort foo bar lose)</code>返回“bar foo lose” 。</p>
</li>
<li>
<p><code>$(word {n},{text})</code><br>
取单词函数。<br>
功能：取字符串{text}中第{n}个单词。（从1开始）<br>
返回：字符串{text}中第{n}个单词。如果{n}比{text}中的单词数要大，那么返回空字符串。<br>
示例：<code>$(word 2, foo bar baz)</code>返回值是“bar”。</p>
</li>
<li>
<p><code>$(wordlist {s},{e},{text})</code><br>
取单词串函数。<br>
功能：从字符串{text}中取从{s}开始到{e}的单词串。{s}和{e}是一个数字。<br>
返回：字符串{text}中从{s}到{e}的单词字串。如果{s}比{text}中的单词数要大，那么返回空字符串。如果{e}大于{text}的单词数，那么返回从{s}开始，到{text}结束的单词串。<br>
示例： <code>$(wordlist 2, 3, foo bar baz)</code>返回值是“bar baz”。</p>
</li>
<li>
<p><code>$(words {text})</code><br>
单词个数统计函数。<br>
功能：统计{text}中字符串中的单词个数。<br>
返回：返回{text}中的单词数。<br>
示例：<code>$(words, foo bar baz)</code>返回值是“3”。<br>
备注：如果我们要取{text}中最后的一个单词，我们可以这样：<code>$(word $(words {text}),{text})</code>。</p>
</li>
<li>
<p><code>$(firstword {text})</code>  、
取首单词函数。<br>
功能：取字符串{text}中的第一个单词。<br>
返回：返回字符串{text}的第一个单词。<br>
示例：<code>$(firstword foo bar)</code>返回值是“foo”。<br>
备注：这个函数可以用word函数来实现：<code>$(word 1,{text})</code>。</p>
</li>
</ul>
<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个实际的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：</p>
<p><code>override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))</code></p>
<p>如果我们的“$(VPATH)”值是“src:../headers”，那么“$(patsubst %,-I%,$(subst :, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数。</p>
<h3 id="三文件名和目录操作函数">三、文件名和目录操作函数</h3>
<p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p>
<ul>
<li>
<p><code>$(dir {names...})</code>
取目录函数。<br>
功能：从文件名序列{names}中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。<br>
返回：文件名序列{names}的目录部分。<br>
示例： <code>$(dir src/foo.c hacks)</code>返回值是“src/ ./”。</p>
</li>
<li>
<p><code>$(notdir {names...})</code><br>
取文件名函数。<br>
功能：从文件名序列{names}中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。<br>
返回：文件名序列{names}的非目录部分。<br>
示例： <code>$(notdir src/foo.c hacks)</code>返回值是“foo.c hacks”。</p>
</li>
<li>
<p><code>$(suffix {names...})</code><br>
取后缀函数。<br>
功能：从文件名序列{names}中取出各个文件名的后缀。<br>
返回：文件名序列{names}的后缀序列，如果文件没有后缀，则返回空字串。<br>
示例：<code>$(suffix src/foo.c src-1.0/bar.c hacks)</code>返回值是“.c .c”。</p>
</li>
<li>
<p><code>$(basename {names...})</code></p>
<p>取前缀函数。<br>
功能：从文件名序列{names}中取出各个文件名的前缀部分。<br>
返回：文件名序列{names}的前缀序列，如果文件没有前缀，则返回空字串。<br>
示例：<code>$(basename src/foo.c src-1.0/bar.c hacks)</code>返回值是“src/foo src-1.0/bar hacks”。</p>
</li>
<li>
<p><code>$(addsuffix {suffix},{names...})</code></p>
<p>加后缀函数。<br>
功能：把后缀{suffix}加到{names}中的每个单词后面。<br>
返回：加过后缀的文件名序列。<br>
示例：<code>$(addsuffix .c,foo bar)</code>返回值是“foo.c bar.c”。</p>
</li>
<li>
<p><code>$(addprefix {prefix},{names...})</code></p>
<p>加前缀函数。<br>
功能：把前缀{prefix}加到{names}中的每个单词后面。<br>
返回：加过前缀的文件名序列。<br>
示例：<code>$(addprefix src/,foo bar)</code>返回值是“src/foo src/bar”。</p>
</li>
<li>
<p><code>$(join {list1},{list2})</code></p>
<p>连接函数。<br>
功能：把{list2}中的单词对应地加到{list1}的单词后面。如果{list1}的单词个数要比{list2}的多，那么{list1}中的多出来的单词将保持原样。如果{list2}的单词个数要比{list1}多，那么{list2}多出来的单词将被复制到{list1}中。<br>
返回：连接过后的字符串。<br>
示例：<code>$(join aaa bbb , 111 222 333)</code>返回值是“aaa111 bbb222 333”。</p>
</li>
</ul>
<h3 id="四foreach函数">四、foreach函数</h3>
<p>foreach函数是用来做循环用的，Makefile中的foreach函数几乎是完全仿照Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：</p>
<p><code>$(foreach {var},{list},{text})</code></p>
<p>这个函数的意思是，把参数{list}中的单词逐一取出放到参数{var}所指定的变量中，然后再执行{text}所包含的表达式。每一次{text}会返回一个字符串。循环过程中，{text}所返回的每个字符串会以空格分隔。当整个循环结束时，{text}所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>
<p>所以，{var}最好是一个变量名，{list}可以是一个表达式，而{text}中一般会使用{var}这个参数来依次枚举{list}中的单词。举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">names</span> <span class="o">:=</span> a b c d

<span class="nv">files</span> <span class="o">:=</span> <span class="k">$(</span>foreach n,<span class="k">$(</span>names<span class="k">)</span>,<span class="k">$(</span>n<span class="k">)</span>.o<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。</p>
<p>注意，foreach中的{var}参数是一个临时的局部变量。foreach函数执行完后，参数{var}的变量将不再起作用，其作用域只在foreach函数当中。</p>
<h3 id="五if函数">五、if函数</h3>
<p>if函数很像条件语句ifeq。if函数的语法是：</p>
<p><code>$(if {condition},{then-part})</code><br>
或<br>
<code>$(if {condition},{then-part},{else-part})</code></p>
<p>可见，if函数可以包含“else”部分。{condition}参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，这时{then-part}会被计算，否则{else-part}会被计算。</p>
<p>如果{condition}为真（非空字符串），那么{then-part}会是整个if函数的返回值；如果{condition}为假（空字符串），那么{else-part}会是整个if函数的返回值，此时如果{else-part}没有被定义，那么整个函数返回空字串。</p>
<h3 id="六call函数">六、call函数</h3>
<p>call函数是一个可以用来创建新函数的函数。你可以写一个非常复杂的表达式，在这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p>
<p><code>$(call {expression},{parm1},{parm2},{parm3}...)</code></p>
<p>当make执行这个函数时，{expression}的参数，如$(1)，$(2)，$(3)等，会被参数{parm1}，{parm2}，{parm3}依次取代。而{expression}的返回值就是call函数的返回值。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">reverse</span> <span class="o">=</span>  <span class="k">$(</span>1<span class="k">)</span> <span class="k">$(</span>2<span class="k">)</span>
<span class="nv">foo</span> <span class="o">=</span> <span class="k">$(</span>call reverse,a,b<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>foo的值就是“a b”。参数的次序是可以自定义的，不一定是顺序的，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">reverse</span> <span class="o">=</span>  <span class="k">$(</span>2<span class="k">)</span> <span class="k">$(</span>1<span class="k">)</span>
<span class="nv">foo</span> <span class="o">=</span> <span class="k">$(</span>call reverse,a,b<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>此时的foo的值就是“b a”。</p>
<h3 id="七origin函数">七、origin函数</h3>
<p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是从哪里来的。语法是：</p>
<p><code>$(origin {variable})</code></p>
<p>{variable}是变量的名字，而不应该是引用。所以不要在{variable}中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面是origin函数的返回值:</p>
<ul>
<li>“undefined”<br>
如果{variable}从来没有定义过，origin函数返回这个值“undefined”。</li>
<li>“default”<br>
如果{variable}是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</li>
<li>“environment”<br>
如果{variable}是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。</li>
<li>“file”
如果{variable}这个变量被定义在Makefile中。</li>
<li>“command line”
如果{variable}这个变量是被命令行定义的。</li>
<li>“override”
如果{variable}是被override指示符重新定义的。</li>
<li>“automatic”
如果{variable}是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</li>
</ul>
<p>这些信息对于我们编写Makefile是非常有用的。假设我们有一个Makefile，其中包含了一个定义文件Make.def。在Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时我们想判断一下，如果变量来源于环境，那么我们就重定义这个变量，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">ifdef</span> <span class="err">bletch</span>
<span class="err">ifeq</span> <span class="s2">&#34;$(origin bletch)&#34;</span> <span class="s2">&#34;environment&#34;</span>
<span class="nv">bletch</span> <span class="o">=</span> barf, gag, etc.
<span class="err">endif</span>
</code></pre></td></tr></table>
</div>
</div><p>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是<strong>override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的</strong>。</p>
<h3 id="八shell函数">八、shell函数</h3>
<p>shell函数的参数是Shell命令。它和反引号“`”是相同的功能。shell函数把执行操作系统命令后的输出作为返回值返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<p><code>contents := $(shell cat foo)</code><br>
<code>files := $(shell echo *.c)</code></p>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以要注意其运行性能。如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h3 id="九控制make的函数">九、控制make的函数</h3>
<p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定是让make继续执行还是停止。</p>
<ul>
<li>
<p><code>$(error {text ...})</code><br>
产生一个致命的错误并使make停止执行，{text &hellip;}是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</p>
<p>示例一：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">ifdef</span> <span class="err">ERROR_001</span>
<span class="k">$(</span><span class="nv">error</span> <span class="nv">error</span> <span class="nv">is</span> <span class="k">$(</span><span class="nv">ERROR_</span>001<span class="k">))</span>
<span class="err">endif</span>
</code></pre></td></tr></table>
</div>
</div><p>示例二：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">ERR</span> <span class="o">=</span> <span class="k">$(</span>error found an error!<span class="k">)</span>
<span class="nf">.PHONY</span><span class="o">:</span> <span class="n">err</span>
<span class="nf">err</span><span class="o">:</span> ; <span class="k">$(</span><span class="nv">ERR</span><span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>示例一会在变量ERROR_001定义了后产生error调用，而示例二则在目标err被执行时才发生error调用。</p>
</li>
<li>
<p><code>$(warning {text ...})</code><br>
这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p>
</li>
</ul>
<h3 id="其他函数">其他函数</h3>
<ul>
<li><code>$(wildcard *.c)</code><br>
wildcard函数用来展开通配符。</li>
</ul>
<h2 id="make的运行">make的运行</h2>
<p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会去找当前目录下的makefile来执行。有时你也许只想让make重新编译某些文件，而不是整个工程。有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p>
<h3 id="一make的退出码">一、make的退出码</h3>
<p>make命令执行后有三个退出码：</p>
<p>0 —— 表示成功执行。<br>
1 —— 如果make运行时出现任何错误，返回1。<br>
2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</p>
<p>Make的相关参数我们会在后续章节中讲述。</p>
<h3 id="二指定makefile">二、指定Makefile</h3>
<p>前面我们说过，GNU make寻找默认Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。</p>
<p>我们也可以通过使用make的“-f”、“&ndash;file”或者“&ndash;makefile”参数给make指定Makefile。例如，我们有个makefile的名字是“hchen.mk”，那么我们可以这样来让make来执行这个文件：<br>
<code>make –f hchen.mk</code></p>
<p>（？？？如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。）</p>
<h3 id="三指定目标">三、指定目标</h3>
<p>一般来说，make的默认目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）。</p>
<p>任何在makefile中的目标都可以被指定成最终目标（除了以“-”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量），甚至没有被我们明确写出来的目标也可以成为make的最终目标。也就是说，只要make可以找到隐含规则，那么这个隐含目标同样可以被指定成最终目标。</p>
<p>有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的最终目标的列表。如果在命令行上没有指定目标，那么这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">sources</span> <span class="o">=</span> foo.c bar.c
<span class="err">ifneq</span> <span class="err">(</span> <span class="k">$(</span><span class="nv">MAKECMDGOALS</span><span class="k">)</span><span class="err">,clean)</span>
<span class="nf">include $(sources</span><span class="o">:</span>.<span class="n">c</span>=.<span class="n">d</span>)
<span class="err">endif</span>
</code></pre></td></tr></table>
</div>
</div><p>基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。</p>
<p>使用指定最终目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">.PHONY</span><span class="o">:</span> <span class="n">all</span>
<span class="nf">all</span><span class="o">:</span> <span class="n">prog</span>1 <span class="n">prog</span>2 <span class="n">prog</span>3 <span class="n">prog</span>4
</code></pre></td></tr></table>
</div>
</div><p>在上面这个例子中，我们可以使用“make all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。</p>
<p>在Unix软件发布时，特别是GNU这种开源软件发布时，其makefile都包含了编译、安装、打包等功能。以下是一些约定俗成的伪目标：</p>
<ul>
<li>“all”<br>
这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</li>
<li>“clean”<br>
这个伪目标功能是删除所有被make创建的文件。</li>
<li>“install”<br>
这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</li>
<li>“print”<br>
这个伪目标的功能是列出改变过的源文件。</li>
<li>“tar”<br>
这个伪目标功能是把源程序打包备份。也就是一个tar文件。</li>
<li>“dist”<br>
这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。</li>
<li>“TAGS”<br>
这个伪目标功能是更新所有的目标，以备完整地重编译使用。</li>
<li>“check”和“test”<br>
这两个伪目标一般用来测试makefile的流程。</li>
</ul>
<p>如果你要在makefile里加上这些功能，最好使用上面的名字命名你的目标，这样会规范一些。规范的好处就是不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业。</p>
<h3 id="四检查规则">四、检查规则</h3>
<p>有时候我们不想执行makefile，只想检查一下命令执行的顺序。我们可以使用make命令的下列参数：</p>
<ul>
<li>
<p>“-n”<br>
“&ndash;just-print”<br>
“&ndash;dry-run”<br>
“&ndash;recon”<br>
这些参数只是打印命令，但不执行。</p>
</li>
<li>
<p>“-t”<br>
“&ndash;touch”<br>
这个参数是把目标文件的时间更新，但不更改目标文件。也就是说，make不真正编译目标，只是把目标变成已编译过的状态。</p>
</li>
<li>
<p>“-q”<br>
“&ndash;question”<br>
这个参数的行为是找目标。如果目标存在，那么make什么也不会输出，也不会执行编译。如果目标不存在，其会打印出一条出错信息。</p>
</li>
<li>
<p>“-W {file}”<br>
“&ndash;what-if={file}”<br>
“&ndash;assume-new={file}”<br>
“&ndash;new-file={file}”<br>
这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</p>
<p>另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。</p>
</li>
</ul>
<h3 id="五make的参数">五、make的参数</h3>
<p>下面列举了所有GNU make 3.80版本的参数定义。</p>
<ul>
<li>
<p>“-b”<br>
“-m”<br>
这两个参数的作用是忽略和其它版本make的兼容性。</p>
</li>
<li>
<p>“-B”<br>
“&ndash;always-make”<br>
认为所有的目标都需要更新（重新编译）。</p>
</li>
<li>
<p>“-C {dir}”<br>
“&ndash;directory={dir}”<br>
指定makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。</p>
</li>
<li>
<p>“—debug[={options}]”<br>
输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是{options}的取值：<br>
 a — 也就是all，输出所有的调试信息。<br>
 b — 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。<br>
 v — 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。<br>
 i — 也就是implicit，输出所以的隐含规则。<br>
 j — 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。<br>
 m — 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</p>
</li>
<li>
<p>“-d”<br>
相当于“&ndash;debug=a”。</p>
</li>
<li>
<p>“-e”<br>
“&ndash;environment-overrides”<br>
指明环境变量的值覆盖makefile中定义的变量的值。</p>
</li>
<li>
<p>“-f={file}”<br>
“&ndash;file={file}”<br>
“&ndash;makefile={file}”<br>
指定需要执行的makefile。</p>
</li>
<li>
<p>“-h”<br>
“&ndash;help”<br>
显示帮助信息。</p>
</li>
<li>
<p>“-i”<br>
“&ndash;ignore-errors”<br>
在执行时忽略所有的错误。</p>
</li>
<li>
<p>“-I {dir}”<br>
“&ndash;include-dir={dir}”<br>
指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</p>
</li>
<li>
<p>“-j [{jobsnum}]”<br>
“&ndash;jobs[={jobsnum}]”<br>
指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）</p>
</li>
<li>
<p>“-k”<br>
“&ndash;keep-going”<br>
出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>
</li>
<li>
<p>“-l {load}”<br>
“&ndash;load-average[={load}]”<br>
“—max-load[={load}]”<br>
指定make运行命令的负载。</p>
</li>
<li>
<p>“-n”<br>
“&ndash;just-print”<br>
“&ndash;dry-run”<br>
“&ndash;recon”<br>
仅输出执行过程中的命令序列，但并不执行。</p>
</li>
<li>
<p>“-o {file}”<br>
“&ndash;old-file={file}”<br>
“&ndash;assume-old={file}”<br>
不重新生成的指定的{file}，即使这个目标的依赖文件新于它。</p>
</li>
<li>
<p>“-p”<br>
“&ndash;print-data-base”<br>
输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。<br>
如果你只是想输出信息而不想执行makefile，你可以使用“make -qp”命令。<br>
如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p>
</li>
<li>
<p>“-q”<br>
“&ndash;question”<br>
不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0，则说明要更新；如果是2，则说明有错误发生。</p>
</li>
<li>
<p>“-r”<br>
“&ndash;no-builtin-rules”<br>
禁止make使用任何隐含规则。</p>
</li>
<li>
<p>“-R”<br>
“&ndash;no-builtin-variabes”<br>
禁止make使用任何影响隐含规则的变量定义。</p>
</li>
<li>
<p>“-s”<br>
“&ndash;silent”<br>
“&ndash;quiet”<br>
在命令运行时不输出命令的输出。</p>
</li>
<li>
<p>“-S”<br>
“&ndash;no-keep-going”<br>
“&ndash;stop”<br>
取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</p>
</li>
<li>
<p>“-t”<br>
“&ndash;touch”<br>
相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>
</li>
<li>
<p>“-v”<br>
“&ndash;version”<br>
输出make程序的版本、版权等关于make的信息。</p>
</li>
<li>
<p>“-w”<br>
“&ndash;print-directory”<br>
输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p>
</li>
<li>
<p>“&ndash;no-print-directory”<br>
禁止“-w”选项。</p>
</li>
<li>
<p>“-W {file}”<br>
“&ndash;what-if={file}”<br>
“&ndash;new-file={file}”<br>
“&ndash;assume-file={file}”<br>
假定目标{file}需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得{file}的修改时间为当前时间。</p>
</li>
<li>
<p>“&ndash;warn-undefined-variables”<br>
只要make发现有未定义的变量，那么就输出警告信息。</p>
</li>
</ul>
<h2 id="隐含规则">隐含规则</h2>
<p>本章讲述的就是一些在Makefile中的隐含的，不需要我们再写出来的规则。</p>
<p>“隐含规则”是一种不需要写出来的规则。例如，把.c文件编译成.o文件这一规则，我们不用写出来，make会自动推导出这种规则，并生成我们需要的.o文件。</p>
<p>“隐含规则”会使用一些系统变量，我们可以改变这些系统变量的值来修改隐含规则运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</p>
<p>（？？？我们还可以利用“模式规则”写自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。）</p>
<h3 id="一使用隐含规则">一、使用隐含规则</h3>
<p>我们有下面这样一个Makefile：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">foo </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">o</span> <span class="n">bar</span>.<span class="n">o</span>
        cc –o foo foo.o bar.o <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这个Makefile中并没有写下生成foo.o和bar.o这两个目标的规则，make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖和命令。</p>
<p>make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，就会使用。如果找不到，就会报错。在上面的例子中，make调用的隐含规则是，把.o目标的依赖设置成.c，并使用C的编译命令<code>“cc –c $(CFLAGS) .c”</code>来生成.o。</p>
<p><strong>在make的“隐含规则库”中，每一条隐含规则都有其顺序，越靠前的是越被经常使用的，所以，这会导致有些时候即使我们显示地指定了目标依赖，make也不会管</strong>。如下面这条规则（没有命令）：</p>
<p><code>foo.o : foo.p</code></p>
<p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过“foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后。所以，make找到可以生成foo.o的C的规则后就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么你就不要只写出“依赖规则”，而不写命令。</p>
<h3 id="二隐含规则一览">二、隐含规则一览</h3>
<p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则。我们也可以使用make的参数“-r”或“&ndash;no-builtin-rules”选项来取消所有的预设置的隐含规则。</p>
<p>然而，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多隐含规则都是使用了“后缀规则”来定义的。所以，只要隐含规则中有“后缀列表”（也就是系统定义在目标.SUFFIXES的依赖），那么隐含规则就会生效。<strong>默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el</strong>。具体的细节，我们会在后面讲述。</p>
<p>以下是常用的隐含规则：</p>
<p>1、编译C程序的隐含规则。<br>
“{n}.o”目标的依赖会自动推导为“{n}.c”，并且其生成命令是<code>“$(CC) –c $(CPPFLAGS) $(CFLAGS)”</code></p>
<p>2、编译C++程序的隐含规则。<br>
“{n}.o”的目标的依赖目标会自动推导为“{n}.cc”或是“{n}.C”，并且其生成命令是<code>“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”</code>。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）</p>
<p>3、编译Pascal程序的隐含规则。<br>
“{n}.o”的目标的依赖目标会自动推导为“{n}.p”，并且其生成命令是<code>“$(PC) –c  $(PFLAGS)”</code>。</p>
<p>4、编译Fortran/Ratfor程序的隐含规则。<br>
“{n}.o”的目标的依赖目标会自动推导为“{n}.r”或“{n}.F”或“{n}.f”，并且其生成命令是:<br>
<code>“.f”  “$(FC) –c  $(FFLAGS)”</code><br>
<code>“.F”  “$(FC) –c  $(FFLAGS) $(CPPFLAGS)”</code> <br>
<code>“.f”  “$(FC) –c  $(FFLAGS) $(RFLAGS)”</code></p>
<p>5、预处理Fortran/Ratfor程序的隐含规则。<br>
“{n}.f”的目标的依赖目标会自动推导为“{n}.r”或“{n}.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：<br>
<code>“.F”  “$(FC) –F $(CPPFLAGS) $(FFLAGS)”</code><br>
<code>“.r”  “$(FC) –F $(FFLAGS) $(RFLAGS)”</code></p>
<p>6、编译Modula-2程序的隐含规则。<br>
“{n}.sym”的目标的依赖目标会自动推导为“{n}.def”，并且其生成命令是：<code>“$(M2C) $(M2FLAGS) $(DEFFLAGS)”</code>。“{n.o}” 的目标的依赖目标会自动推导为“{n}.mod”，并且其生成命令是：<code>“$(M2C) $(M2FLAGS) $(MODFLAGS)”</code>。</p>
<p>7、汇编和汇编预处理的隐含规则。<br>
“{n}.o” 的目标的依赖目标会自动推导为“{n}.s”，默认使用编译品“as”，并且其生成命令是：<code>“$(AS) $(ASFLAGS)”</code>。“{n}.s” 的目标的依赖目标会自动推导为“{n}.S”，默认使用C预编译器“cpp”，并且其生成命令是：<code>“$(AS) $(ASFLAGS)”</code>。</p>
<p>8、链接Object文件的隐含规则。<br>
“{n}”目标依赖于“{n}.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：<code>“$(CC) $(LDFLAGS) {n}.o $(LOADLIBES) $(LDLIBS)”</code>。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：<br>
<code>x : y.o z.o</code><br>
并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile">    cc -c x.c -o x.o
    cc -c y.c -o y.o
    cc -c z.c -o z.o
    cc x.o y.o z.o -o x
    rm -f x.o
    rm -f y.o
    rm -f z.o
</code></pre></td></tr></table>
</div>
</div><p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<p>9、Yacc C程序时的隐含规则。<br>
“{n}.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：<code>“$(YACC) $(YFALGS)”</code>。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</p>
<p>10、Lex C程序时的隐含规则。<br>
“{n}.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：<code>“$(LEX) $(LFALGS)”</code>。（关于“Lex”的细节请查看相关资料）</p>
<p>11、Lex Ratfor程序时的隐含规则。<br>
“{n}.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：<code>“$(LEX) $(LFALGS)”</code>。</p>
<p>12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。<br>
“{n}.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：<code>“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”</code>。对于“{n}.y”和“{n}.l”也是同样的规则。</p>
<h3 id="三隐含规则使用的变量">三、隐含规则使用的变量</h3>
<p>隐含规则基本上都使用了一些预先设置的变量，你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值。无论怎么样，只要设置了这些特定的变量，那么就会对隐含规则起作用。你也可以利用make的“-R”或“&ndash;no–builtin-variables”参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是<code>“$(CC) –c $(CFLAGS) $(CPPFLAGS)”</code>。Make默认的编译命令是“cc”，如果你把变量<code>“$(CC)”</code>重定义成“gcc”，把变量<code>“$(CFLAGS)”</code>重定义成“-g”，那么，隐含规则中的命令全部会以<code>“gcc –c -g $(CPPFLAGS)”</code>来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：</p>
<p>1、关于命令的变量。</p>
<p>AR<br>
  函数库打包程序。默认命令是“ar”。<br>
AS<br>
  汇编语言编译程序。默认命令是“as”。<br>
CC<br>
  C语言编译程序。默认命令是“cc”。<br>
CXX<br>
  C++语言编译程序。默认命令是“g++”。<br>
CO<br>
  从 RCS文件中扩展文件程序。默认命令是“co”。<br>
CPP<br>
  C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。<br>
FC<br>
  Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。<br>
GET<br>
  从SCCS文件中扩展文件的程序。默认命令是“get”。<br>
LEX<br>
  Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。<br>
PC<br>
  Pascal语言编译程序。默认命令是“pc”。<br>
YACC<br>
  Yacc文法分析器（针对于C程序）。默认命令是“yacc”。<br>
YACCR<br>
  Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。<br>
MAKEINFO<br>
  转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。<br>
TEX<br>
  从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。<br>
TEXI2DVI<br>
  从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。<br>
WEAVE<br>
  转换Web到TeX的程序。默认命令是“weave”。<br>
CWEAVE<br>
  转换C Web 到 TeX的程序。默认命令是“cweave”。<br>
TANGLE<br>
  转换Web到Pascal语言的程序。默认命令是“tangle”。<br>
CTANGLE<br>
  转换C Web 到 C。默认命令是“ctangle”。<br>
RM<br>
  删除文件命令。默认命令是“rm –f”。</p>
<p>2、关于命令参数的变量</p>
<p>下面的这些变量都是上面的命令的参数。其<strong>默认值都是空</strong>。</p>
<p>ARFLAGS<br>
  函数库打包程序AR命令的参数。默认值是“rv”。<br>
ASFLAGS<br>
  汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。<br>
CFLAGS<br>
  C语言编译器参数。<br>
CXXFLAGS<br>
  C++语言编译器参数。<br>
COFLAGS<br>
  RCS命令参数。<br>
CPPFLAGS<br>
  C预处理器参数。（ C 和 Fortran 编译器也会用到）。<br>
FFLAGS<br>
  Fortran语言编译器参数。<br>
GFLAGS<br>
  SCCS “get”程序参数。<br>
LDFLAGS<br>
  链接器参数。（如：“ld”）<br>
LFLAGS<br>
  Lex文法分析器参数。<br>
PFLAGS<br>
  Pascal语言编译器参数。<br>
RFLAGS<br>
  Ratfor 程序的Fortran 编译器参数。<br>
YFLAGS<br>
  Yacc文法分析器参数。</p>
<h3 id="四隐含规则链">四、隐含规则链</h3>
<p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个.o文件的生成，可能会是先通过Yacc的.y文件生成.c，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件.c存在，那么就直接调用C编译器的隐含规则。如果没有.c文件，但有一个.y文件，那么Yacc的隐含规则会被调用，生成.c文件，然后再调用C编译的隐含规则生成.o文件，最终达到目标。</p>
<p>我们把这种.c文件叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少。所以有些时候可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p>
<p>在默认情况下，中间目标和一般的目标在两个地方有所不同：（1）只有中间目标不存在时才会引发中间规则。（2）只要成功生成最终目标，所产生的中间目标文件会被以“rm -f”删除。</p>
<p>通常，一个被makefile指定成目标或依赖的文件不能被当作中介。然而，你可以明确地指定一个文件或目标为中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE : mid ）</p>
<p>你也可以阻止make自动删除中间目标。要做到这一点，使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标以模式的方式（如：%.o）来指定成伪目标“.PRECIOUS”的依赖，以保留被隐含规则生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规则就不会生成中间文件。</p>
<h3 id="五定义模式规则">五、定义模式规则</h3>
<p>你可以使用模式规则来定义一个隐含规则。在模式规则中，目标的定义需要有&quot;%&ldquo;字符。&quot;%&ldquo;的意思是表示一个或多个任意字符。在依赖中同样可以使用&rdquo;%&quot;，只是依赖中的&rdquo;%&ldquo;的取值取决于其目标。</p>
<p>有一点需要注意的是，&quot;%&ldquo;的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的&rdquo;%&ldquo;则发生在运行时。</p>
<p>1、模式规则介绍</p>
<p>模式规则中，至少在规则的目标定义中要包含&rdquo;%&quot;，否则就是一般的规则。目标中的&rdquo;%&ldquo;定义表示对文件名的匹配，&quot;%&ldquo;表示长度任意的非空字符串。例如：&quot;%.c&quot;表示以&rdquo;.c&quot;结尾的文件名（文件名的长度至少为3），而&quot;s.%.c&quot;则表示以&quot;s.&ldquo;开头，&quot;.c&quot;结尾的文件名（文件名的长度至少为5）。</p>
<p>如果&rdquo;%&ldquo;定义在目标中，那么，目标中的&rdquo;%&ldquo;的值决定了依赖中的&rdquo;%&ldquo;的值。例如有一个模式规则如下：</p>
<p><code>%.o : %.c ; {command ......}</code></p>
<p>这个模式规则指出了怎么从所有的.c文件生成相应的.o文件的规则。如果要生成的目标是&quot;a.o b.o&rdquo;，那么&rdquo;%c&quot;就是&quot;a.c b.c&quot;。</p>
<p>一旦依赖目标中的&quot;%&ldquo;模式被确定，make就会被要求去匹配当前目录下所有的文件名，一旦找到，make就会执行规则下的命令。所以在模式规则中，目标可能会有多个。</p>
<p>2、模式规则示例</p>
<p>下面这个例子表示了,把所有的.c文件都编译成.o文件.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">c</span>
        <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> $&lt; -o <span class="nv">$@</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，<code>&quot;$@&quot;</code>和<code>&quot;$&lt;&quot;</code>是&quot;自动化变量&rdquo;，后面会详细讲述。</p>
<p>下面的这个例子中有两个模式目标：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">%.tab.c %.tab.h</span><span class="o">:</span> %.<span class="n">y</span>
        bison -d $&lt;
</code></pre></td></tr></table>
</div>
</div><p>这条规则告诉make把所有的.y]文件都以&quot;bison -d {n}.y&quot;执行，然后生成&quot;{n}.tab.c&quot;和&quot;{n}.tab.h&quot;文件。假设我们的执行程序&quot;foo&quot;依赖于文件&quot;parse.tab.o&quot;和&quot;scan.o&quot;，并且文件&quot;scan.o&quot;依赖于文件&quot;parse.tab.h&quot;，如果&quot;parse.y&quot;文件被更新了，那么根据上述的规则，&ldquo;bison -d parse.y&quot;就会被执行一次，于是&quot;parse.tab.o&quot;和&quot;scan.o&quot;的依赖文件就齐了。（假设&quot;parse.tab.o&quot;由&quot;parse.tab.c&quot;生成，并且&quot;scan.o&quot;由&quot;scan.c&quot;生成，而&quot;foo&quot;由&quot;parse.tab.o&quot;和&quot;scan.o&quot;链接生成，而且foo和.o文件的依赖关系也写好，那么所有的目标都会得到满足。）</p>
<p>3、自动化变量</p>
<p>在上述的模式规则中，目标和依赖都是一系列文件，那么我们如何书写一个命令来完成从不同的依赖生成相应的目标？</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提及，所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明（注意：“集合”和“依次取出”是不同的）：</p>
<p><code>$@</code><br>
  表示规则中的目标文件集。展开时依次取出。</p>
<p><code>$%</code><br>
  仅当目标是库文件时，表示规则中的目标成员名。例如，如果一个目标是&quot;foo.a(bar.o)&quot;，那么，<code>&quot;$%&quot;</code>就是&quot;bar.o&rdquo;，<code>&quot;$@&quot;</code>就是&quot;foo.a&quot;。如果目标不是函数库文件（Unix下是.a，Windows下是.lib），那么，其值为空。</p>
<p><code>$&lt;</code>
  依赖中的第一个名字。如果依赖是以模式（即&quot;%&quot;）定义的，那么<code>&quot;$&lt;&quot;</code>将是符合模式的一系列的文件集。注意，是一个一个取出来的。</p>
<p><code>$?</code>
  所有比目标新的依赖目标的集合。以空格分隔。</p>
<p><code>$^</code>
  所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p>
<p><code>$+</code><br>
  这个变量很像<code>&quot;$^&quot;</code>，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p>
<p><code>$*</code><br>
  这个变量表示目标模式中&quot;%&ldquo;及其之前的部分。如果目标是&quot;dir/a.foo.b&rdquo;，并且目标的模式是&quot;a.%.b&quot;，那么，<code>&quot;$*&quot;</code>的值就是&quot;dir/a.foo&quot;。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么<code>&quot;$*&quot;</code>也就不能被推导出。但是，如果目标文件的后缀是make所识别的，那么<code>&quot;$*&quot;</code>就是除了后缀的那一部分。例如：如果目标是&quot;foo.c&quot;，因为&quot;.c&quot;是make所能识别的后缀名，所以，<code>&quot;$*&quot;</code>的值就是&quot;foo&quot;。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用<code>&quot;$*&quot;</code>，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么<code>&quot;$*&quot;</code>就是空值。</p>
<p>当你希望只对更新过的依赖文件进行操作时，<code>&quot;$?&quot;</code>在显式规则中很有用。例如，假设有一个函数库文件叫&quot;lib&quot;，由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">lib </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">o</span> <span class="n">bar</span>.<span class="n">o</span> <span class="n">lose</span>.<span class="n">o</span> <span class="n">win</span>.<span class="n">o</span>
        ar r lib <span class="nv">$?</span>
</code></pre></td></tr></table>
</div>
</div><p>在上述所列出来的自动量变量中，<code>$@</code>、<code>$&lt;</code>、<code>$%</code>和<code>$*</code>在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上&quot;D&quot;或&quot;F&quot;字样。这是GNU make中老版本的特性，在新版本中，我们使用函数&quot;dir&quot;或&quot;notdir&quot;就可以做到了。&ldquo;D&quot;的含义就是Directory，就是目录，&ldquo;F&quot;的含义就是File，就是文件。</p>
<p>下面是对于上面的七个变量分别加上&quot;D&quot;或是&quot;F&quot;的含义：</p>
<p><code>$(@D)</code><br>
  表示<code>&quot;$@&quot;</code>的目录部分（不以斜杠作为结尾），如果<code>&quot;$@&quot;</code>值是&quot;dir/foo.o&rdquo;，那么<code>&quot;$(@D)&quot;</code>就是&quot;dir&rdquo;，而如果<code>&quot;$@&quot;</code>中没有包含斜杠的话，其值就是&quot;.&quot;（当前目录）。</p>
<p><code>$(@F)</code><br>
  表示<code>&quot;$@&quot;</code>的文件部分，如果<code>&quot;$@&quot;</code>值是&quot;dir/foo.o&quot;，那么<code>&quot;$(@F)&quot;</code>就是&quot;foo.o&quot;，<code>&quot;$(@F)&quot;</code>相当于函数<code>&quot;$(notdir $@)&quot;</code>。</p>
<p><code>&quot;$(*D)&quot;</code><br>
<code>&quot;$(*F)&quot;</code><br>
  和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，<code>&quot;$(*D)&quot;</code>返回&quot;dir&quot;，而<code>&quot;$(*F)&quot;</code>返回&quot;foo&quot;</p>
<p><code>&quot;$(%D)&quot;</code><br>
<code>&quot;$(%F)&quot;</code><br>
  分别表示了函数包文件成员的目录部分和文件部分。这对于形同&quot;archive(member)&ldquo;形式的目标中的&quot;member&quot;中包含了不同的目录很有用。</p>
<p><code>&quot;$({D)&quot;</code><br>
<code>&quot;$({F)&quot;</code><br>
  分别表示依赖文件的目录部分和文件部分。</p>
<p><code>&quot;$(^D)&quot;</code><br>
<code>&quot;$(^F)&quot;</code><br>
  分别表示所有依赖文件的目录部分和文件部分。（无相同的）</p>
<p><code>&quot;$(+D)&quot;</code><br>
<code>&quot;$(+F)&quot;</code><br>
  分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</p>
<p><code>&quot;$(?D)&quot;</code><br>
<code>&quot;$(?F)&quot;</code><br>
  分别表示被更新的依赖文件的目录部分和文件部分。</p>
<p>最后，对于<code>&quot;$&lt;&quot;</code>，为了避免产生不必要的麻烦，我们最好给<code>$</code>后面的那个特定字符都加上圆括号。比如，&quot;<code>$(&lt;)&quot;</code>就要比<code>&quot;$&lt;&quot;</code>要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是&quot;显式规则&quot;和&quot;静态模式规则&rdquo;（参见前面&quot;书写规则&quot;一章）。在隐含规则中并没有意义。</p>
<p>4、模式的匹配</p>
<p>一般来说，一个目标的模式有一个有前缀或是后缀的&quot;%&quot;，或是没有前后缀，直接就是一个&quot;%&quot;。因为&quot;%&ldquo;代表一个或多个字符，所以在定义好的模式中，我们把&rdquo;%&ldquo;所匹配的内容叫做&quot;词干&rdquo;（stem），例如&quot;%.c&quot;所匹配的文件&quot;test.c&quot;中&quot;test&quot;就是&quot;词干&quot;。目标和依赖目标中同时有&quot;%&ldquo;时，目标的&quot;词干&quot;会传给依赖，作为依赖中的&quot;词干&rdquo;。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，在进行模式匹配时目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行&quot;词干&quot;的传递时，我们需要知道这个步骤。例如有一个模式&quot;e%t&quot;，文件&quot;src/eat&quot;匹配于该模式，于是&quot;src/a&quot;就是其&quot;词干&quot;，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式&quot;c%r&quot;，那么，目标就是&quot;src/car&quot;。（&ldquo;词干&quot;被传递）</p>
<p>5、重载内建隐含规则</p>
<p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">c</span>
        <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CPPFLAGS<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> -D<span class="k">$(</span>date<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>也可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">s</span>
</code></pre></td></tr></table>
</div>
</div><p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h3 id="六老式的后缀规则">六、老式的&quot;后缀规则&rdquo;</h3>
<p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：&ldquo;双后缀&quot;和&quot;单后缀&rdquo;。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如&quot;.c.o&quot;相当于&quot;%o : %c&quot;。单后缀规则只定义一个后缀，也就是源文件的后缀。如&quot;.c&quot;相当于&quot;% : %.c&quot;。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：&quot;.c&quot;和&quot;.o&quot;都是make所知道。因而，如果你定义了一个规则是&quot;.c.o&quot;那么其就是双后缀规则，意义就是&quot;.c&quot;是源文件的后缀，&quot;.o&quot;是目标文件的后缀。如下示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">.c.o</span><span class="o">:</span>
        <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> -o <span class="nv">$@</span> $&lt;
</code></pre></td></tr></table>
</div>
</div><p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">.c.o</span><span class="o">:</span> <span class="n">foo</span>.<span class="n">h</span>
        <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> -o <span class="nv">$@</span> $&lt;
</code></pre></td></tr></table>
</div>
</div><p>这个例子，就是说，文件&quot;.c.o&quot;依赖于文件&quot;foo.h&quot;，而不是我们想要的这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">%.o</span><span class="o">:</span> %.<span class="n">c</span> <span class="n">foo</span>.<span class="n">h</span>
        <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> -o <span class="nv">$@</span> $&lt;
</code></pre></td></tr></table>
</div>
</div><p>后缀规则中，如果没有命令，那是毫无意义的。make不会用一个没有命令的后缀规则覆盖内建的隐含规则。</p>
<p>而要让make知道一些特定的后缀，我们可以使用伪目标&quot;.SUFFIXES&quot;来定义或是删除，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">.SUFFIXES</span><span class="o">:</span> .<span class="n">hack</span> .<span class="n">win</span>
</code></pre></td></tr></table>
</div>
</div><p>把后缀.hack和.win加入后缀列表中的末尾。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">.SUFFIXES</span><span class="o">:</span>              <span class="c">#删除默认的后缀
</span><span class="c"></span><span class="nf">.SUFFIXES</span><span class="o">:</span> .<span class="n">c</span> .<span class="n">o</span> .<span class="n">h</span>   <span class="c">#定义自己的后缀
</span></code></pre></td></tr></table>
</div>
</div><p>先清除默认后缀，后定义自己的后缀列表。</p>
<p>注意：你可以用&quot;.SUFFIXES&quot;来改变后缀列表，但请不要改变变量&quot;SUFFIXE&quot;的值。</p>
<p>make的参数&quot;-r&quot;或&quot;-no-builtin-rules&quot;也会使用得默认的后缀列表为空。</p>
<h3 id="七隐含规则搜索算法">七、隐含规则搜索算法</h3>
<p>比如我们有一个目标叫T。下面是搜索目标T的规则的算法。请注意，在下面我们没有提到后缀规则，原因是在Makefile被载入内存时所有的后缀规则会被转换成模式规则。如果目标是&quot;archive(member)&ldquo;的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，第二次会把&quot;member&quot;当作T来搜索。</p>
<p>1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是&quot;src/foo.o&rdquo;，那么，D就是&quot;src/&quot;，N就是&quot;foo.o&quot;）</p>
<p>2、创建所有匹配于T或是N的模式规则列表。</p>
<p>3、如果在模式规则列表中有匹配所有文件的模式，如&quot;%&quot;，那么从列表中移除其它的模式。</p>
<p>4、移除列表中没有命令的规则。</p>
<p>5、对于第一个在列表中的模式规则：<br>
  1）推导其&quot;词干&quot;S，S应该是T或N匹配于模式中&quot;%&ldquo;非空的部分。<br>
  2）计算依赖文件。把依赖文件中的&rdquo;%&ldquo;都替换成&quot;词干&quot;S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。<br>
  3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫&quot;理当存在&rdquo;。）<br>
  4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</p>
<p>6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<br>
  1）如果规则是终止规则，那就忽略它，继续下一条模式规则。<br>
  2）计算依赖文件。（同第5步）<br>
  3）测试所有的依赖文件是否存在或是理当存在。<br>
  4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。<br>
  5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</p>
<p>7、如果没有隐含规则可以使用，查看&quot;.DEFAULT&quot;规则，如果有，把&quot;.DEFAULT&quot;的命令给T使用。</p>
<p>一旦规则被找到，就会执行相应的命令。直到此时，我们的自动化变量的值才会生成。</p>
<h2 id="使用make更新函数库文件">使用make更新函数库文件</h2>
<p>函数库文件(Archive File)也就是对Object文件的打包。在Unix下，一般是由命令&quot;ar&quot;来完成打包工作。</p>
<h3 id="一函数库文件的成员">一、函数库文件的成员</h3>
<p>一个函数库文件可以由多个文件组成。你可以用如下格式指定函数库文件及其组成：</p>
<p><code>archive(member)</code></p>
<p>这不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为&quot;ar&quot;命令服务的。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">foolib(hack.o) </span><span class="o">:</span> <span class="n">hack</span>.<span class="n">o</span>
        ar cr foolib hack.o

<span class="c">#如果要指定多个member，那就以空格分开，如：
</span><span class="c"></span><span class="err">foolib(hack.o</span> <span class="err">kludge.o)</span>

<span class="c">#等价于：
</span><span class="c"></span><span class="err">foolib(hack.o)</span> <span class="err">foolib(kludge.o)</span>

<span class="c">#你还可以使用Shell的文件通配符来定义，如：
</span><span class="c"></span>
<span class="err">foolib(*.o)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二函数库成员的隐含规则">二、函数库成员的隐含规则</h3>
<p>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是&quot;a(m)&ldquo;形式的，其会把目标变成&rdquo;(m)&quot;。于是，如果我们的成员是&quot;%.o&quot;的模式定义，并且如果我们使用&quot;make foo.a(bar.o)&ldquo;的形式调用Makefile时，隐含规则会去找&quot;bar.o&quot;的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">cc</span> <span class="err">-c</span> <span class="err">bar.c</span> <span class="err">-o</span> <span class="err">bar.o</span>
<span class="err">ar</span> <span class="err">r</span> <span class="err">foo.a</span> <span class="err">bar.o</span>
<span class="err">rm</span> <span class="err">-f</span> <span class="err">bar.o</span>
</code></pre></td></tr></table>
</div>
</div><p>还有一个变量要注意的是<code>&quot;$%&quot;</code>，这是专属函数库文件的自动化变量，有关其说明请参见&quot;自动化变量&quot;一节。</p>
<h3 id="三函数库文件的后缀规则">三、函数库文件的后缀规则</h3>
<p>你可以使用&quot;后缀规则&quot;和&quot;隐含规则&quot;来生成函数库打包文件，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile">    .c.a:
            <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> -c $&lt; -o <span class="nv">$*</span>.o
            <span class="k">$(</span>AR<span class="k">)</span> r <span class="nv">$@</span> <span class="nv">$*</span>.o
            <span class="k">$(</span>RM<span class="k">)</span> <span class="nv">$*</span>.o

<span class="err">等价于：</span>
    <span class="nf">(%.o) </span><span class="o">:</span> %.<span class="n">c</span>
            <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> -c $&lt; -o <span class="nv">$*</span>.o
            <span class="k">$(</span>AR<span class="k">)</span> r <span class="nv">$@</span> <span class="nv">$*</span>.o
            <span class="k">$(</span>RM<span class="k">)</span> <span class="nv">$*</span>.o
</code></pre></td></tr></table>
</div>
</div><h3 id="四注意事项">四、注意事项</h3>
<p>在进行函数库打包文件生成时，请小心使用make的并行机制（&quot;-j&quot;参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。但就目前而言，还是应该尽量不要使用&rdquo;-j&quot;参数。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2022-10-27</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/21.makefile-tutorial/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/make/">make</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/20.cpp-stl-algorithm-overview/" class="prev" rel="prev" title="c&#43;&#43;标准库算法概览"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>c&#43;&#43;标准库算法概览</a>
            <a href="/22.scl/" class="next" rel="next" title="scl-rhel/centos软件运行环境">scl-rhel/centos软件运行环境<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/openjz" target="_blank">shiwj</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp">津ICP备2020010292号-1</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
