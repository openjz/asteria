<!DOCTYPE html>
<html lang="zh" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="寻找两个正序数组的中位数 #  给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数
方法1-归并法 #  方法1，按归并的思路，每次排除一个数，直到找到中位数为止。时间复杂度O(m&#43;n)
方法2-改良的归并法 #  方法1是一种比较符合直觉的方法，更进一步，我们考虑每次多排除一些数，以提高算法的执行速度。
寻找中位数问题可以视为寻找第k大数问题的特殊情况，现在设中位数是第k大的数为Kth，我们每次比较k/2个数，就能每次排除掉k/2个数。随着被排除的数逐渐增多，k会逐渐变小，当k变为1的时候，比较最后一次，就找到了Kth。由于k每次缩小一半，时间复杂度为O(log(m&#43;n))
这里面有一个关键问题，为什么比较步长是k/2？
为了解释这个问题，先看一个例子，
A：1，2，3，8 B：4，5，6，7有递增序列A和B，现在我们想找到第4大的数（即4），如果将比较步长设置为4，即直接比较7和8，会导致4,5,6,7全都被排除掉，最后无法找到4。所以我们必须设置合理的比较步长，来避免这种情况。
下面说明为什么是k/2
在对位于比较点的两个数做比较后，我们会将较小数及其之前的数排除掉。为了保证一定能够排除较小数及其之前的数，我们必须保证Kth不在被排除的数中，换言之，我们一定不能让位于比较点的两个数都大于Kth。
假设有以下两个序列
A：a0,a1,...,amB: b0,b1,...,bn假设比较步长为p，位于比较点的两个数是ap，bp，现在对Kth所在位置分情况讨论
 ap和bp都在Kth之前 ap在Kth之前，bp在Kth之后（即Kth∈[b0,bp]） ap在Kth之后（即Kth∈[a0,ap]），bp在Kth之前  情况1不做讨论，排除哪个都行。
情况2和情况3是等价的，现在假设Kth∈[a0,ap]，即a0 &lt;= kth &lt;= ap，如果我们想排除[b0,bp]，就必须保证bp &lt;= Kth &lt;= ap，即不能让位于比较点的两个数都大于等于Kth
当比较步长p为k/2时，[a0,ap]和[b0,bp]加起来一共k个数，如果ap和bp都大于Kth，[a0,ap]和[b0,bp]加起来一定会超过k个数，前后矛盾。所以当比较步长为k/2时必不可能出现比较点的两个数都大于Kth这个情况，反之当比较步长大于k/2时，被比较的两个子序列的数字量大于k，就有可能出现这个情况。
相应的，如果有三个有序数列，比较步长最长为k/3，有四个序列，比较步长最长为k/4，以此类推。
方法3-二分法 #  方法2是将问题转化为求第K大的数，而方法3是利用了中位数的以下性质：
 中位数两边的数个数相等 中位数左边最大的数小于右边最小的数、  具体方法是分别将序列1和序列2一分为2，将左序列1&#43;左序列2视为左半部分，将右序列1&#43;右序列2视为右半部分，保证左半部分的数字个数等于右半部分的数字个数，并且左半部分的最大值大于右半部分的最小值。
那如何找到切分位置？在较短序列上进行二分搜索即可
正则表达式匹配 #  给你一个字符串s和一个字符规律p，请你来实现一个支持&#39;.&lsquo;和&rsquo;*&lsquo;的正则表达式匹配。
 &lsquo;.&lsquo;匹配任意单个字符 &lsquo;*&lsquo;匹配零个或多个前面的那一个元素  所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。
方法-动态规划 #   将问题转化为求f[i][j]的问题，f[i][j]是指字符串s的前i个字符和模式p的前j个字符是否匹配。 以下是该问题的求解方程 1.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="算法题" />
<meta property="og:description" content="寻找两个正序数组的中位数 #  给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数
方法1-归并法 #  方法1，按归并的思路，每次排除一个数，直到找到中位数为止。时间复杂度O(m&#43;n)
方法2-改良的归并法 #  方法1是一种比较符合直觉的方法，更进一步，我们考虑每次多排除一些数，以提高算法的执行速度。
寻找中位数问题可以视为寻找第k大数问题的特殊情况，现在设中位数是第k大的数为Kth，我们每次比较k/2个数，就能每次排除掉k/2个数。随着被排除的数逐渐增多，k会逐渐变小，当k变为1的时候，比较最后一次，就找到了Kth。由于k每次缩小一半，时间复杂度为O(log(m&#43;n))
这里面有一个关键问题，为什么比较步长是k/2？
为了解释这个问题，先看一个例子，
A：1，2，3，8 B：4，5，6，7有递增序列A和B，现在我们想找到第4大的数（即4），如果将比较步长设置为4，即直接比较7和8，会导致4,5,6,7全都被排除掉，最后无法找到4。所以我们必须设置合理的比较步长，来避免这种情况。
下面说明为什么是k/2
在对位于比较点的两个数做比较后，我们会将较小数及其之前的数排除掉。为了保证一定能够排除较小数及其之前的数，我们必须保证Kth不在被排除的数中，换言之，我们一定不能让位于比较点的两个数都大于Kth。
假设有以下两个序列
A：a0,a1,...,amB: b0,b1,...,bn假设比较步长为p，位于比较点的两个数是ap，bp，现在对Kth所在位置分情况讨论
 ap和bp都在Kth之前 ap在Kth之前，bp在Kth之后（即Kth∈[b0,bp]） ap在Kth之后（即Kth∈[a0,ap]），bp在Kth之前  情况1不做讨论，排除哪个都行。
情况2和情况3是等价的，现在假设Kth∈[a0,ap]，即a0 &lt;= kth &lt;= ap，如果我们想排除[b0,bp]，就必须保证bp &lt;= Kth &lt;= ap，即不能让位于比较点的两个数都大于等于Kth
当比较步长p为k/2时，[a0,ap]和[b0,bp]加起来一共k个数，如果ap和bp都大于Kth，[a0,ap]和[b0,bp]加起来一定会超过k个数，前后矛盾。所以当比较步长为k/2时必不可能出现比较点的两个数都大于Kth这个情况，反之当比较步长大于k/2时，被比较的两个子序列的数字量大于k，就有可能出现这个情况。
相应的，如果有三个有序数列，比较步长最长为k/3，有四个序列，比较步长最长为k/4，以此类推。
方法3-二分法 #  方法2是将问题转化为求第K大的数，而方法3是利用了中位数的以下性质：
 中位数两边的数个数相等 中位数左边最大的数小于右边最小的数、  具体方法是分别将序列1和序列2一分为2，将左序列1&#43;左序列2视为左半部分，将右序列1&#43;右序列2视为右半部分，保证左半部分的数字个数等于右半部分的数字个数，并且左半部分的最大值大于右半部分的最小值。
那如何找到切分位置？在较短序列上进行二分搜索即可
正则表达式匹配 #  给你一个字符串s和一个字符规律p，请你来实现一个支持&#39;.&lsquo;和&rsquo;*&lsquo;的正则表达式匹配。
 &lsquo;.&lsquo;匹配任意单个字符 &lsquo;*&lsquo;匹配零个或多个前面的那一个元素  所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。
方法-动态规划 #   将问题转化为求f[i][j]的问题，f[i][j]是指字符串s的前i个字符和模式p的前j个字符是否匹配。 以下是该问题的求解方程 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.shiwj.top/posts/algorithm-problem/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-06T11:37:09+08:00" />
<meta property="article:modified_time" content="2022-07-07T18:43:59+08:00" />

<title>算法题 | 星星</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css" integrity="sha256-gsXb0jRHzuC0wqo&#43;0Izglh&#43;qQOH6Nw7uT4yfAuDUa18=" crossorigin="anonymous">
  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>星星</span>
  </a>
</h2>













  












  
<ul>
  
  <li>
    <a href="/posts/" >
        Blog
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>算法题</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#寻找两个正序数组的中位数">寻找两个正序数组的中位数</a>
          <ul>
            <li><a href="#方法1-归并法">方法1-归并法</a></li>
            <li><a href="#方法2-改良的归并法">方法2-改良的归并法</a></li>
            <li><a href="#方法3-二分法">方法3-二分法</a></li>
          </ul>
        </li>
        <li><a href="#正则表达式匹配">正则表达式匹配</a>
          <ul>
            <li><a href="#方法-动态规划">方法-动态规划</a></li>
          </ul>
        </li>
        <li><a href="#求最长回文子串">求最长回文子串</a>
          <ul>
            <li><a href="#方法-动态规划-1">方法-动态规划</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown">
  <h1>
    <a href="/posts/algorithm-problem/">算法题</a>
  </h1>
  
  <h5>July 6, 2022</h5>



  
  <div>
    
      <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
  </div>
  

  
  <div>
    
      <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
  </div>
  



<h2 id="寻找两个正序数组的中位数">
  寻找两个正序数组的中位数
  <a class="anchor" href="#%e5%af%bb%e6%89%be%e4%b8%a4%e4%b8%aa%e6%ad%a3%e5%ba%8f%e6%95%b0%e7%bb%84%e7%9a%84%e4%b8%ad%e4%bd%8d%e6%95%b0">#</a>
</h2>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数</p>
<h3 id="方法1-归并法">
  方法1-归并法
  <a class="anchor" href="#%e6%96%b9%e6%b3%951-%e5%bd%92%e5%b9%b6%e6%b3%95">#</a>
</h3>
<p>方法1，按归并的思路，每次排除一个数，直到找到中位数为止。时间复杂度O(m+n)</p>
<h3 id="方法2-改良的归并法">
  方法2-改良的归并法
  <a class="anchor" href="#%e6%96%b9%e6%b3%952-%e6%94%b9%e8%89%af%e7%9a%84%e5%bd%92%e5%b9%b6%e6%b3%95">#</a>
</h3>
<p>方法1是一种比较符合直觉的方法，更进一步，我们考虑每次多排除一些数，以提高算法的执行速度。</p>
<p><strong>寻找中位数问题可以视为寻找第k大数问题的特殊情况</strong>，现在设中位数是第k大的数为<code>Kth</code>，我们每次比较k/2个数，就能每次排除掉k/2个数。随着被排除的数逐渐增多，k会逐渐变小，当k变为1的时候，比较最后一次，就找到了<code>Kth</code>。由于k每次缩小一半，时间复杂度为O(log(m+n))</p>
<p><strong>这里面有一个关键问题，为什么比较步长是k/2</strong>？</p>
<p>为了解释这个问题，先看一个例子，</p>
<pre tabindex="0"><code>A：1，2，3，8  
B：4，5，6，7
</code></pre><p>有递增序列A和B，现在我们想找到第4大的数（即4），如果将比较步长设置为4，即直接比较7和8，会导致4,5,6,7全都被排除掉，最后无法找到4。所以我们必须设置合理的比较步长，来避免这种情况。</p>
<p>下面说明为什么是k/2</p>
<p>在对位于比较点的两个数做比较后，我们会将较小数及其之前的数排除掉。为了保证一定能够排除较小数及其之前的数，我们必须保证<code>Kth</code>不在被排除的数中，换言之，<strong>我们一定不能让位于比较点的两个数都大于<code>Kth</code></strong>。</p>
<p>假设有以下两个序列</p>
<pre tabindex="0"><code>A：a0,a1,...,am
B: b0,b1,...,bn
</code></pre><p>假设比较步长为p，位于比较点的两个数是<code>ap</code>，<code>bp</code>，现在对<code>Kth</code>所在位置分情况讨论</p>
<ol>
<li><code>ap</code>和<code>bp</code>都在<code>Kth</code>之前</li>
<li><code>ap</code>在<code>Kth</code>之前，<code>bp</code>在<code>Kth</code>之后（即<code>Kth∈[b0,bp]</code>）</li>
<li><code>ap</code>在<code>Kth</code>之后（即<code>Kth∈[a0,ap]</code>），<code>bp</code>在<code>Kth</code>之前</li>
</ol>
<p>情况1不做讨论，排除哪个都行。</p>
<p>情况2和情况3是等价的，现在假设<code>Kth∈[a0,ap]</code>，即<code>a0 &lt;= kth &lt;= ap</code>，如果我们想排除<code>[b0,bp]</code>，就必须保证<code>bp &lt;= Kth &lt;= ap</code>，即不能让位于比较点的两个数都大于等于<code>Kth</code></p>
<p>当比较步长p为k/2时，<code>[a0,ap]</code>和<code>[b0,bp]</code>加起来一共k个数，如果<code>ap</code>和<code>bp</code>都大于<code>Kth</code>，<code>[a0,ap]</code>和<code>[b0,bp]</code>加起来一定会超过k个数，前后矛盾。所以当比较步长为k/2时必不可能出现比较点的两个数都大于<code>Kth</code>这个情况，反之当比较步长大于k/2时，被比较的两个子序列的数字量大于k，就有可能出现这个情况。</p>
<p>相应的，如果有三个有序数列，比较步长最长为k/3，有四个序列，比较步长最长为k/4，以此类推。</p>
<h3 id="方法3-二分法">
  方法3-二分法
  <a class="anchor" href="#%e6%96%b9%e6%b3%953-%e4%ba%8c%e5%88%86%e6%b3%95">#</a>
</h3>
<p>方法2是将问题转化为求第K大的数，而方法3是利用了中位数的以下性质：</p>
<ol>
<li>中位数两边的数个数相等</li>
<li>中位数左边最大的数小于右边最小的数、</li>
</ol>
<p>具体方法是分别将序列1和序列2一分为2，将左序列1+左序列2视为左半部分，将右序列1+右序列2视为右半部分，保证左半部分的数字个数等于右半部分的数字个数，并且左半部分的最大值大于右半部分的最小值。</p>
<p>那如何找到切分位置？在较短序列上进行二分搜索即可</p>
<h2 id="正则表达式匹配">
  正则表达式匹配
  <a class="anchor" href="#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%8c%b9%e9%85%8d">#</a>
</h2>
<p>给你一个字符串s和一个字符规律p，请你来实现一个支持'.&lsquo;和&rsquo;*&lsquo;的正则表达式匹配。</p>
<ul>
<li>&lsquo;.&lsquo;匹配任意单个字符</li>
<li>&lsquo;*&lsquo;匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。</p>
<h3 id="方法-动态规划">
  方法-动态规划
  <a class="anchor" href="#%e6%96%b9%e6%b3%95-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h3>
<ol>
<li>将问题转化为求<code>f[i][j]</code>的问题，<code>f[i][j]</code>是指字符串s的前i个字符和模式p的前j个字符是否匹配。</li>
<li>以下是该问题的求解方程
<pre tabindex="0"><code>1. 当p[j-1]不是'*'时，
    如果p[j-1]和s[i-1]匹配，
        f[i][j] = f[i-1][j-1]
    否则
        f[i][j] = false
2. 当p[j-1]是'*'时（要看'*'前面那个字符），
    如果p[j-2]不和s[i-1]匹配(字母和'*'的组合被干掉)，
        f[i][j] = f[i][j-2]
    否则，既可以字母和'*'的组合被干掉也可以s[i-1]被干掉
        f[i][j] = f[i][j-2] or f[i-1][j]
</code></pre></li>
<li>当s和p都为空时，视为匹配，即<code>f[0][0]=True</code>。p为空，s为空时，一定不匹配，即<code>f[0][x]=False</code>。<strong>而s为空，p不为空时，不一定匹配，例如p为<code>a*a*</code>时，可以和空串形成匹配，因此在循环时，i要从0开始，j可以从1开始</strong>。</li>
</ol>
<h2 id="求最长回文子串">
  求最长回文子串
  <a class="anchor" href="#%e6%b1%82%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e5%ad%90%e4%b8%b2">#</a>
</h2>
<p>给你一个字符串s，找到s中最长的回文子串。</p>
<p>示例 1：</p>
<p>输入：s = &ldquo;babad&rdquo;<br>
输出：&ldquo;bab&rdquo;<br>
（&ldquo;aba&rdquo; 同样是符合题意的答案。）</p>
<h3 id="方法-动态规划-1">
  方法-动态规划
  <a class="anchor" href="#%e6%96%b9%e6%b3%95-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92-1">#</a>
</h3>
<p>将问题转换为求<code>f[i][j]</code>的问题，<code>f[i][j]</code>是指s的子串<code>s[i,j]</code>是否为回文串，求<code>f[i][j]</code>之前要先求出<code>f[i+1][j-1]</code></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/alex-shpak/hugo-book/commit/5c09194a4aa5e3b547df3fa335ac1ad5c1c46096" title='最后修改者 shiwenjie | July 7, 2022' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>July 7, 2022</span>
    </a>
  </div>




</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        <footer class="flex flex-wrap justify-between">
    <div>
      <p>
        &copy; 2022 shiwj all rights reserved.
      </p>
      <p>
        津ICP备2020010292号-1
      </p>
    </div>
  </footer>
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#寻找两个正序数组的中位数">寻找两个正序数组的中位数</a>
          <ul>
            <li><a href="#方法1-归并法">方法1-归并法</a></li>
            <li><a href="#方法2-改良的归并法">方法2-改良的归并法</a></li>
            <li><a href="#方法3-二分法">方法3-二分法</a></li>
          </ul>
        </li>
        <li><a href="#正则表达式匹配">正则表达式匹配</a>
          <ul>
            <li><a href="#方法-动态规划">方法-动态规划</a></li>
          </ul>
        </li>
        <li><a href="#求最长回文子串">求最长回文子串</a>
          <ul>
            <li><a href="#方法-动态规划-1">方法-动态规划</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












